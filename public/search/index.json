[{"content":"AES加密 1.核心原理 AES为分组密码，将明文分为一组一组，每次加密一组数据，直到加密完所有明文。\nAES标准规范中，分组长度只能是128位，即每个分组为16个字节。\n密钥的长度可以为128，192，256位。根据密钥长度不同，推荐的加密轮数也不同\nAES 密钥长度（32位比特字) 分组长度(32位比特字) 加密轮数 AES-128 4 4 10 AES-192 6 4 12 AES-256 8 4 14 状态矩阵 AES算法中的核心，一个状态矩阵为4x4的字节矩阵，共16个字节，作为一组明文或者加密的中间结果展现。排列规则为 “按列填充”—— 即明文第 1-4 字节为第 1 列，第 5-8 字节为第 2 列，第 9-12 字节为第 3 列，第 13-16 字节为第 4 列。 例：128 位明文00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff（16 字节），状态矩阵为：\n列0 列1 列2 列3 00 44 88 cc 11 55 99 dd 22 66 aa ee 33 77 bb ff 轮密钥 原始密钥通过密钥拓展的方式生成，每轮迭代需要1个与状态矩阵等大的4*4轮密钥，因此总的轮密钥数 = 轮数 + 1。（第0轮为 初始轮密钥，用于首轮“轮密钥加”）\n有限域运算 AES 的 “列混合” 和 “密钥扩展” 依赖GF (2⁸) 有限域（即 8 位字节的二元域）运算，确保所有变换在固定范围内可逆\n填充 假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行填充。\nnopadding 不做任何填充，但是要求明文必须是16字节的整数倍。\nPKCS5Padding（默认）： 如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。\n比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}\niso10126padding 如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。\n比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}\n2.算法原理 加密阶段（AES-128） 对应解密阶段（AES-128） 关键差异 最终轮（字节代换→行移位→轮密钥加） 初始轮（轮密钥加→逆行移位→逆字节代换） 解密初始轮需先抵消加密的 “轮密钥加”，再逆序还原 “行移位” 和 “字节代换” 第 9~1 轮（字节代换→行移位→列混合→轮密钥加） 第 1~9 轮（轮密钥加→逆列混合→逆行移位→逆字节代换） 解密轮需先 “轮密钥加”（抵消加密的最后一步），再逆序还原 “列混合”“行移位”“字节代换” 初始轮密钥加 最终轮密钥加 解密最终轮仅需 “轮密钥加”，直接还原明文 轮密钥使用顺序：K₀→K₁→…→K₁₀ 轮密钥使用顺序：K₁₀→K₉→…→K₀ 解密轮密钥完全逆序，与加密互补 字节代换 定义S盒和逆S盒的查表操作\n行移位 1.行移位操作 行移位是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节 2.行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节，第3行右移3字节。\n列混合 列混合操作\n列混合变换是通过矩阵相乘来实现的,经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵\n列混合逆运算\n逆向列混合变换可由下图的矩阵乘法定义： 可以验证，逆变换矩阵同正变换矩阵的乘积恰好为单位矩阵。\n轮密钥加 1238位密钥同状态矩阵中的数据进行诸位异或操作，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节\n轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与W[4i]的异或运算。\n轮密钥加的逆运算同正向的轮密钥加运算完全一致，这是因为异或的逆操作是其自身。轮密钥加非常简单，但却能够影响S数组中的每一位\n密钥扩展 AES首先将初始密钥输入到一个44的状态矩阵中，如下图所示。 这个44矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为W[0]、W[1]、W[2]和W[3]，它们构成一个以字为单位的数组W。例如，设密钥K为\u0026quot;abcdefghijklmnop\u0026quot;,则K0 = ‘a’,K1 = ‘b’, K2 = ‘c’,K3 = ‘d’,W[0] = “abcd”。 接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列以如下的递归方式产生：\n如果i不是4的倍数，那么第i列由如下等式确定： W[i]=W[i-4]⨁W[i-1]\n如果i是4的倍数，那么第i列由如下等式确定：\nW[i]=W[i-4]⨁T(W[i-1])\n其中，T是一个有点复杂的函数。\n函数T由3部分组成：字循环、字节代换和轮常量异或，这3部分的作用分别如下。\n字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]。 字节代换：对字循环的结果使用S盒进行字节代换。 轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。 轮常量Rcon[j]是一个字，其值见下表。 j 1 2 3 4 5 Rcon[j] 01 00 00 00 02 00 00 00 04 00 00 00 08 00 00 00 10 00 00 00 j 6 7 8 9 10 Rcon[j] 20 00 00 00 40 00 00 00 80 00 00 00 1B 00 00 00 36 00 00 00 设初始的128位密钥为： 3C A1 0B 21 57 F0 19 16 90 2E 13 80 AC C1 07 BD 那么4个初始值为： W[0] = 3C A1 0B 21 W[1] = 57 F0 19 16 W[2] = 90 2E 13 80 W[3] = AC C1 07 BD 下面求扩展的第1轮的子密钥(W[4],W[5],W[6],W[7])。 由于4是4的倍数，所以： W[4] = W[0] ⨁ T(W[3]) T(W[3])的计算步骤如下：\n循环地将W[3]的元素移位：AC C1 07 BD变成C1 07 BD AC; 将 C1 07 BD AC 作为S盒的输入，输出为78 C5 7A 91; 将78 C5 7A 91与第一轮轮常量Rcon[1]进行异或运算，将得到79 C5 7A 91，因此，T(W[3])=79 C5 7A 91，故 W[4] = 3C A1 0B 21 ⨁ 79 C5 7A 91 = 45 64 71 B0 其余的3个子密钥段的计算如下： W[5] = W[1] ⨁ W[4] = 57 F0 19 16 ⨁ 45 64 71 B0 = 12 94 68 A6 W[6] = W[2] ⨁ W[5] =90 2E 13 80 ⨁ 12 94 68 A6 = 82 BA 7B 26 W[7] = W[3] ⨁ W[6] = AC C1 07 BD ⨁ 82 BA 7B 26 = 2E 7B 7C 9B 所以，第一轮的密钥为 45 64 71 B0 12 94 68 A6 82 BA 7B 26 2E 7B 7C 9B。 3.算法实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * 参数 p: 明文的字符串数组。 * 参数 plen: 明文的长度。 * 参数 key: 密钥的字符串数组。 */ void aes(char *p, int plen, char *key){ int keylen = strlen(key); if(plen == 0 || plen % 16 != 0) { printf(\u0026#34;明文字符长度必须为16的倍数！\\n\u0026#34;); exit(0); } if(!checkKeyLen(keylen)) { printf(\u0026#34;密钥字符长度错误！长度必须为16、24和32。当前长度为%d\\n\u0026#34;,keylen); exit(0); } extendKey(key);//扩展密钥 int pArray[4][4]; for(int k = 0; k \u0026lt; plen; k += 16) { convertToIntArray(p + k, pArray); addRoundKey(pArray, 0);//一开始的轮密钥加 for(int i = 1; i \u0026lt; 10; i++){//前9轮 subBytes(pArray);//字节代换 shiftRows(pArray);//行移位 mixColumns(pArray);//列混合 addRoundKey(pArray, i); } //第10轮 subBytes(pArray);//字节代换 shiftRows(pArray);//行移位 addRoundKey(pArray, 10); convertArrayToStr(pArray, p + k); } } 各个对应函数的实现 1 密钥拓展 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //密钥对应的扩展数组 static int w[44]; /** * 扩展密钥，结果是把w[44]中的每个元素初始化 */ static void extendKey(char *key) { for(int i = 0; i \u0026lt; 4; i++) w[i] = getWordFromStr(key + i * 4); for(int i = 4, j = 0; i \u0026lt; 44; i++) { if( i % 4 == 0) { w[i] = w[i - 4] ^ T(w[i - 1], j); j++;//下一轮 }else { w[i] = w[i - 4] ^ w[i - 1]; } } } T函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * 常量轮值表 */ static const int Rcon[10] = { 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000 }; /** * 密钥扩展中的T函数 */ static int T(int num, int round) { int numArray[4]; splitIntToArray(num, numArray); leftLoop4int(numArray, 1);//字循环 //字节代换 for(int i = 0; i \u0026lt; 4; i++) numArray[i] = getNumFromSBox(numArray[i]); int result = mergeArrayToInt(numArray); return result ^ Rcon[round]; } 2 字节代换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * 根据索引，从S盒中获得元素 */ static int getNumFromSBox(int index) { int row = getLeft4Bit(index); int col = getRight4Bit(index); return S[row][col]; } /** * 字节代换 */ static void subBytes(int array[4][4]){ for(int i = 0; i \u0026lt; 4; i++) for(int j = 0; j \u0026lt; 4; j++) array[i][j] = getNumFromSBox(array[i][j]); } 3 行移位的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * 将数组中的元素循环左移step位 */ static void leftLoop4int(int array[4], int step) { int temp[4]; for(int i = 0; i \u0026lt; 4; i++) temp[i] = array[i]; int index = step % 4 == 0 ? 0 : step % 4; for(int i = 0; i \u0026lt; 4; i++){ array[i] = temp[index]; index++; index = index % 4; } } /** * 行移位 */ static void shiftRows(int array[4][4]) { int rowTwo[4], rowThree[4], rowFour[4]; //复制状态矩阵的第2,3,4行 for(int i = 0; i \u0026lt; 4; i++) { rowTwo[i] = array[1][i]; rowThree[i] = array[2][i]; rowFour[i] = array[3][i]; } //循环左移相应的位数 leftLoop4int(rowTwo, 1); leftLoop4int(rowThree, 2); leftLoop4int(rowFour, 3); //把左移后的行复制回状态矩阵中 for(int i = 0; i \u0026lt; 4; i++) { array[1][i] = rowTwo[i]; array[2][i] = rowThree[i]; array[3][i] = rowFour[i]; } } 4 列混合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 /** * 列混合要用到的矩阵 */ static const int colM[4][4] = { 2, 3, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 3, 1, 1, 2 }; static int GFMul2(int s) { int result = s \u0026lt;\u0026lt; 1; int a7 = result \u0026amp; 0x00000100; if(a7 != 0) { result = result \u0026amp; 0x000000ff; result = result ^ 0x1b; } return result; } static int GFMul3(int s) { return GFMul2(s) ^ s; } /** * GF上的二元运算 */ static int GFMul(int n, int s) { int result; if(n == 1) result = s; else if(n == 2) result = GFMul2(s); else if(n == 3) result = GFMul3(s); else if(n == 0x9) result = GFMul9(s); else if(n == 0xb)//11 result = GFMul11(s); else if(n == 0xd)//13 result = GFMul13(s); else if(n == 0xe)//14 result = GFMul14(s); return result; } /** * 列混合 */ static void mixColumns(int array[4][4]) { int tempArray[4][4]; for(int i = 0; i \u0026lt; 4; i++) for(int j = 0; j \u0026lt; 4; j++) tempArray[i][j] = array[i][j]; for(int i = 0; i \u0026lt; 4; i++) for(int j = 0; j \u0026lt; 4; j++){ array[i][j] = GFMul(colM[i][0],tempArray[0][j]) ^ GFMul(colM[i][1],tempArray[1][j]) ^ GFMul(colM[i][2],tempArray[2][j]) ^ GFMul(colM[i][3], tempArray[3][j]); } } 5 轮钥加密 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * 轮密钥加 */ static void addRoundKey(int array[4][4], int round) { int warray[4]; for(int i = 0; i \u0026lt; 4; i++) { splitIntToArray(w[ round * 4 + i], warray); for(int j = 0; j \u0026lt; 4; j++) { array[j][i] = array[j][i] ^ warray[j]; } } } AES解密 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /** * 参数 c: 密文的字符串数组。 * 参数 clen: 密文的长度。 * 参数 key: 密钥的字符串数组。 */ void deAes(char *c, int clen, char *key) { int keylen = strlen(key); if(clen == 0 || clen % 16 != 0) { printf(\u0026#34;密文字符长度必须为16的倍数！现在的长度为%d\\n\u0026#34;,clen); exit(0); } if(!checkKeyLen(keylen)) { printf(\u0026#34;密钥字符长度错误！长度必须为16、24和32。当前长度为%d\\n\u0026#34;,keylen); exit(0); } extendKey(key);//扩展密钥 int cArray[4][4]; for(int k = 0; k \u0026lt; clen; k += 16) { convertToIntArray(c + k, cArray); addRoundKey(cArray, 10); int wArray[4][4]; for(int i = 9; i \u0026gt;= 1; i--) { deSubBytes(cArray); deShiftRows(cArray); deMixColumns(cArray); getArrayFrom4W(i, wArray); deMixColumns(wArray); addRoundTowArray(cArray, wArray); } deSubBytes(cArray); deShiftRows(cArray); addRoundKey(cArray, 0); convertArrayToStr(cArray, c + k); } } ","date":"2025-12-21T00:00:00Z","image":"http://localhost:1313/bj.jpg","permalink":"http://localhost:1313/p/12-21-2025-jiami/","title":"12-21 AES加密"},{"content":"API 它预先把这些复杂的操作写在一个函数里面，编译成一个组件（一般是动态链接库），随操作系统一起发布，并配上说明文档，程序员只需要简单地调用这些函数就可以完成复杂的工作，让编程变得简单有趣。这些封装好的函数，就叫做API(Application Programming Interface)，即应用程序编程接口。\nAPI（Application Programming Interface）是软件系统之间的桥梁，定义了一套规则，使得调用方（客户端）可以通过接口与服务端进行交互，而无需了解服务端的内部实现。例如，当你在应用中查询天气或进行支付时，实际上是通过 API 与天气服务或支付系统进行通信。\nOLLVM OLLVM是一款针对于LLVM的代码混淆工具，整个项目包含数个独立功能的LLVM Pass，每个pass对应实现一种特定的混淆方式，这些pass将在后面进行细说，通过pass可以改变源程序的CFG和源程序的结构。\n三大功能 （1）指令替换功能：随机选择一种功能上等效但更复杂的指令序列替换标准二元运算符；适用范围：加法操作、减法操作、布尔操作（与或非操作）且只能为整数类型。\n（2）混淆控制流功能：\n1.在当前基本块之前添加基本块来修改函数调用图。\n2.原始基本块也被克隆并填充随机选择的垃圾指令。\n（3）控制流平展功能：目的是完全展平程序的控制流程图。\n将 if/else、for 等结构转为 switch + 状态机\n“压扁逻辑”：所有分支从同一个入口进入\n二、原始 C 代码示例 1 2 3 4 5 6 7 8 9 10 11 12 // original.c int main() { int x = 5; if (x \u0026gt; 0) { printf(\u0026#34;Positive\\n\u0026#34;); } else if (x \u0026lt; 0) { printf(\u0026#34;Negative\\n\u0026#34;); } else { printf(\u0026#34;Zero\\n\u0026#34;); } return 0; } 这是一个典型的三路分支结构。\n应用 -bcf（虚假控制流） 效果：插入看似有用、实则无害的“垃圾分支”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int main() { int x = 5; // 虚假分支 1（永远不执行） if ((rand() % 100) \u0026lt; -1) { dummy_function(); // 无副作用 } if (x \u0026gt; 0) { printf(\u0026#34;Positive\\n\u0026#34;); } // 虚假分支 2 else if ((x ^ x) == 1) { // 永远 false fake_print(); } else if (x \u0026lt; 0) { printf(\u0026#34;Negative\\n\u0026#34;); } // 虚假分支 3 else if (0) { unreachable_code(); } else { printf(\u0026#34;Zero\\n\u0026#34;); } // 更多无意义跳转... goto label_end; label_end: return 0; } 原逻辑不变 多出很多“看起来像分支”的代码 反编译后流程图变得杂乱 应用 -fla（控制流平展） 效果：把 if-else 变成 switch + 状态变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int main() { int x = 5; int state = 0; // 初始化状态 if (x \u0026gt; 0) state = 1; else if (x \u0026lt; 0) state = 2; else state = 3; // 平展后的主循环 while (1) { switch (state) { case 1: printf(\u0026#34;Positive\\n\u0026#34;); state = 4; // 跳转到结束 break; case 2: printf(\u0026#34;Negative\\n\u0026#34;); state = 4; break; case 3: printf(\u0026#34;Zero\\n\u0026#34;); state = 4; break; case 4: goto end_loop; // 结束 } } end_loop: return 0; } 特点：\n所有逻辑都在 switch 里 原始条件判断被“隐藏”在状态赋值中 静态分析难以还原 if-else 结构 应用 -split（基本块分割） 效果：把一行代码拆成多行，插入无意义中间变量。\n原始片段：\n1 printf(\u0026#34;Positive\\n\u0026#34;); 分割后可能变成：\n1 2 3 4 5 6 char* str1 = \u0026#34;Pos\u0026#34;; char* str2 = \u0026#34;itive\\n\u0026#34;; char full[20]; strcpy(full, str1); strcat(full, str2); printf(\u0026#34;%s\u0026#34;, full); ","date":"2025-12-20T00:00:00Z","image":"http://localhost:1313/p/12-20-2025-biji/bj_hu_c5de23cd89bf6059.jpg","permalink":"http://localhost:1313/p/12-20-2025-biji/","title":"12-20 笔记"},{"content":"1\n凯撒密码 一种经典的替换加密技术，将字母按字母表的顺序向前或者向后移动固定的位数来加密信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char passwd[100], encrypted[100]; int i, j, k, t, move, tmp; printf(\u0026#34;加密选择1，解密选择2：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;tmp); if (tmp == 1) { printf(\u0026#34;输入原文:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, \u0026amp;passwd); printf(\u0026#34;自定义密匙(1-25):\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;move); for (i = 0; i \u0026lt; strlen(passwd); i++) { if (passwd[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; passwd[i] \u0026lt;= \u0026#39;Z\u0026#39;) { passwd[i] = ((passwd[i] - \u0026#39;A\u0026#39;) + move) % 26 + \u0026#39;A\u0026#39;; } else if (passwd[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; passwd[i] \u0026lt;= \u0026#39;z\u0026#39;) { passwd[i] = ((passwd[i] - \u0026#39;a\u0026#39;) + move) % 26 + \u0026#39;a\u0026#39;; } } printf(\u0026#34;加密后的密文\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, passwd); } else { printf(\u0026#34;输入密文:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, \u0026amp;passwd); printf(\u0026#34;密匙为(1-25):\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;move); for (i = 0; i \u0026lt; strlen(passwd); i++) { if (passwd[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; passwd[i] \u0026lt;= \u0026#39;Z\u0026#39;) { passwd[i] = ((passwd[i] - \u0026#39;A\u0026#39;) + 26 - move) % 26 + \u0026#39;A\u0026#39;; } else if (passwd[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; passwd[i] \u0026lt;= \u0026#39;z\u0026#39;) { passwd[i] = ((passwd[i] - \u0026#39;a\u0026#39;) + 26 - move) % 26 + \u0026#39;a\u0026#39;; } } printf(\u0026#34;解密后的原文\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, passwd); } return 0; } 变种 ROT13 特殊变种，偏移量为13，属于f函数对称加密，加密和解密过程相同。\n回转13位，将明文中的每个字母都向后移动13位\nASCII码变种 一般的凯撒密码只加密字母，二ascii码可以将数字和其他字符根据ascii精选偏移，实现更复杂的加密\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define MIN_ASCII 32 // 空格 #define MAX_ASCII 126 // ~ #define RANGE (MAX_ASCII - MIN_ASCII + 1) // 可打印字符范围 // 加密函数 void caesar_encrypt(char *text, int shift) { // 确保移位在合理范围内 shift = shift % RANGE; if (shift \u0026lt; 0) { shift += RANGE; // 处理负移位 } for (int i = 0; text[i] != \u0026#39;\\0\u0026#39;; i++) { // 只加密可打印ASCII字符 if (text[i] \u0026gt;= MIN_ASCII \u0026amp;\u0026amp; text[i] \u0026lt;= MAX_ASCII) { // 计算新字符位置 int original = text[i] - MIN_ASCII; int encrypted = (original + shift) % RANGE; text[i] = encrypted + MIN_ASCII; } // 非可打印字符保持不变 } } // 解密函数 void caesar_decrypt(char *text, int shift) { // 解密是加密的逆操作 caesar_encrypt(text, -shift); } 变异凯撒密码 基础：采用逐字符增加的偏移量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 基础变异凯撒：移位值随位置递增 void variant_caesar_encrypt(char *text, int base_shift) { int position = 0; for (int i = 0; text[i] != \u0026#39;\\0\u0026#39;; i++) { if (isalpha(text[i])) { // 计算当前字符的移位值 int shift = base_shift + position; char base = isupper(text[i]) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; int offset = text[i] - base; // 应用移位（对26取模） offset = (offset + shift) % 26; if (offset \u0026lt; 0) offset += 26; text[i] = base + offset; position++; // 位置递增 } // 非字母字符保持原样，但位置也递增（可选） // else { position++; } } } void variant_caesar_decrypt(char *text, int base_shift) { int position = 0; for (int i = 0; text[i] != \u0026#39;\\0\u0026#39;; i++) { if (isalpha(text[i])) { int shift = base_shift + position; char base = isupper(text[i]) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; int offset = text[i] - base; offset = (offset - shift) % 26; if (offset \u0026lt; 0) offset += 26; text[i] = base + offset; position++; } } } 2. 基于斐波那契数列的变异凯撒 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; // 生成斐波那契数列移位值 void generate_fibonacci_shifts(int *shifts, int length, int start1, int start2) { if (length \u0026gt;= 1) shifts[0] = start1; if (length \u0026gt;= 2) shifts[1] = start2; for (int i = 2; i \u0026lt; length; i++) { shifts[i] = shifts[i-1] + shifts[i-2]; } // 对26取模，确保在字母范围内 for (int i = 0; i \u0026lt; length; i++) { shifts[i] = shifts[i] % 26; if (shifts[i] \u0026lt; 0) shifts[i] += 26; } } void fibonacci_caesar_encrypt(char *text, int fib1, int fib2) { int len = strlen(text); int *shifts = (int*)malloc(len * sizeof(int)); generate_fibonacci_shifts(shifts, len, fib1, fib2); for (int i = 0; i \u0026lt; len; i++) { if (isalpha(text[i])) { char base = isupper(text[i]) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; int offset = text[i] - base; offset = (offset + shifts[i]) % 26; text[i] = base + offset; } } free(shifts); } void fibonacci_caesar_decrypt(char *text, int fib1, int fib2) { int len = strlen(text); int *shifts = (int*)malloc(len * sizeof(int)); generate_fibonacci_shifts(shifts, len, fib1, fib2); for (int i = 0; i \u0026lt; len; i++) { if (isalpha(text[i])) { char base = isupper(text[i]) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; int offset = text[i] - base; offset = (offset - shifts[i]) % 26; if (offset \u0026lt; 0) offset += 26; text[i] = base + offset; } } free(shifts); } 3. 基于密钥的变异凯撒 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; // 使用密钥生成移位序列 void key_based_caesar_encrypt(char *text, const char *key) { int key_len = strlen(key); int key_index = 0; for (int i = 0; text[i] != \u0026#39;\\0\u0026#39;; i++) { if (isalpha(text[i])) { // 从密钥字符计算移位值 int shift; if (isupper(key[key_index])) { shift = key[key_index] - \u0026#39;A\u0026#39;; } else { shift = key[key_index] - \u0026#39;a\u0026#39;; } char base = isupper(text[i]) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; int offset = text[i] - base; offset = (offset + shift) % 26; text[i] = base + offset; // 移动密钥索引 key_index = (key_index + 1) % key_len; } } } void key_based_caesar_decrypt(char *text, const char *key) { int key_len = strlen(key); int key_index = 0; for (int i = 0; text[i] != \u0026#39;\\0\u0026#39;; i++) { if (isalpha(text[i])) { int shift; if (isupper(key[key_index])) { shift = key[key_index] - \u0026#39;A\u0026#39;; } else { shift = key[key_index] - \u0026#39;a\u0026#39;; } char base = isupper(text[i]) ? \u0026#39;A\u0026#39; : \u0026#39;a\u0026#39;; int offset = text[i] - base; offset = (offset - shift) % 26; if (offset \u0026lt; 0) offset += 26; text[i] = base + offset; key_index = (key_index + 1) % key_len; } } } ","date":"2025-12-20T00:00:00Z","image":"http://localhost:1313/p/12-20-2025-jiami/bj_hu_b1c6f19fb7e80385.jpg","permalink":"http://localhost:1313/p/12-20-2025-jiami/","title":"12-20 凯撒加密"},{"content":"","date":"2025-12-19T00:00:00Z","image":"http://localhost:1313/p/12-19/bj_hu_a3498a2c7c94450c.jpg","permalink":"http://localhost:1313/p/12-19/","title":"12-19 加密"},{"content":"","date":"2025-12-19T00:00:00Z","image":"http://localhost:1313/bj.jpg","permalink":"http://localhost:1313/p/12-19-2025/","title":"12-19 加密"},{"content":"1\npy在线反编译工具\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 print \u0026#39;Welcome to Re World!\u0026#39; print \u0026#39;Your input1 is your flag~ l = len(input1) for i in range(l): num = ((input1[i] + i) % 128 + 128) % 128 code += num for i in range(l - 1): code[i] = code[i] ^ code[i + 1] print code code = [ \u0026#39;%1f\u0026#39;, \u0026#39;%12\u0026#39;, \u0026#39;%1d\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;%01\u0026#39;, \u0026#39;%06\u0026#39;, \u0026#39;%14\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;%1b\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;:\u0026#39;, \u0026#39;%01\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;%\u0026#39;, \u0026#39;%13\u0026#39;] 逆向\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 code = [ \u0026#39;%1f\u0026#39;, \u0026#39;%12\u0026#39;, \u0026#39;%1d\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;%01\u0026#39;, \u0026#39;%06\u0026#39;, \u0026#39;%14\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;%1b\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;:\u0026#39;, \u0026#39;%01\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;%\u0026#39;, \u0026#39;%13\u0026#39;] code1 = [] for i in code: if i.startswith(\u0026#39;%\u0026#39;) and len(i)\u0026gt;1: code1.append(int(i[1:],16)) else: code1.append(ord(i)) for i in range(len(code)-2,0,-1): code1[i] = code1[i] ^ code1[i + 1] print(code1) code2 = \u0026#39;\u0026#39; for i in range(len(code1)): num = (code1[i] - i + 128) % 128 code2 += chr(num) print(code2) ","date":"2025-12-18T00:00:00Z","image":"http://localhost:1313/p/12-18/bj_hu_45fee17463a677e6.jpg","permalink":"http://localhost:1313/p/12-18/","title":"12-18 解题"},{"content":"算法加密？\n![img](file:///C:\\Users\\14671\\Documents\\Tencent Files\\1467149032\\Image\\C2C($_[ZB$_YSGV921@7)A]3WT.png)\n已知_data_start__ 内含字符串，v4的字符串也知道\n解密思路，已知题目有v4[i] != _data_start__[*((char *)v5 + i) - 1] 的判断条件\n需要满足v4字符与输入之后的字符经过变换在data里面的字符相等\n遍历 data_start 中与v4相同的字符，查询到字符后存入\n知晓存入的 j 代表着 j = *((char *)v5 + i) - 1 ,由此做逆向输出\n得十六进制 0x54,0x37,0x55,0x5b,0x2c,0x4d,0x58,0x4f,0x2d,0x36,0x49,0x33\n输出得字符串 T7U[,MXO-6I3 但是结果不对\nz\n不一样的flag\n解压exe 命令行运行，是上下左右移动形式\n查壳 无壳 进ida找main函数进入\n1 2 3 4 5 6 7 走步数的循环 代码中可得程序出口 if ( v7[5 * *(_DWORD *)\u0026amp;v3[25] - 41 + v4] == 35 ) { puts(\u0026#34;\\nok, the order you enter is the flag!\u0026#34;); exit(0); } 而后调试程序，进入汇编查找地址\n查v7的地址0060FEF0，计算算式的条件可得到，23h = 35 ，在0060FEF0附近查找结果为23h的只有0060FEDF位置，所以v7[-17]为flag推出条件\n而当程序等于49即31h，也就是0060FEDF位置往上的1结果时程序退出\n而后理出 v4,v3 逻辑，左右改变v4，上下改变v3，确定是re逆向迷宫题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 根据 for ( i = 0; i \u0026lt;= 1; ++i ) { if ( *(_DWORD *)\u0026amp;v3[4 * i + 25] \u0026gt; 4u ) exit(1); } 说明v3\u0026lt;=4,且‘*11110100001010000101111#’共25个字符 得知为5 * 5迷宫 即: *1111 01000 01010 00010 1111# 按图解出 更多迷宫类型未遇见\n","date":"2025-12-17T00:00:00Z","image":"http://localhost:1313/bj.jpg","permalink":"http://localhost:1313/p/12-17/","title":"12-17 解题"},{"content":"TEA两条基本魔改未写，两种升级版的魔改没写\nTEA算法，一种简单的分组密码算法 加密原理 1. 基本参数 分组大小：64位（8字节） 密钥大小：128位（16字节） 轮数建议：32轮（标准）或更多 每轮操作：使用加法、异或、移位等简单运算 2. 核心结构（Feistel网络） TEA使用Feistel结构，将64位明文分为左右两部分各32位：\n1 2 3 明文 P = (L₀, R₀) 每轮加密：Lᵢ₊₁ = Rᵢ Rᵢ₊₁ = Lᵢ + F(Rᵢ, Kᵢ) 3. 核心函数 F 1 F(M, K[]) = ((M \u0026lt;\u0026lt; 4) + K[0]) ⊕ (M + Delta) ⊕ ((M \u0026gt;\u0026gt; 5) + K[1]) 其中：\nDelta 是黄金比例常数：0x9E3779B9 K[] 是每轮的子密钥（从主密钥派生） 4.加密示例 第一轮前半部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 sum = 0 + 0x9E3779B9 = 0x9E3779B9 v0 += ((v1 \u0026lt;\u0026lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + k[1]) 计算各项： v1 \u0026lt;\u0026lt; 4 = 0x89ABCDEF \u0026lt;\u0026lt; 4 = 0x9ABCDEF0 (v1 \u0026lt;\u0026lt; 4) + k[0] = 0x9ABCDEF0 + 0xA56BABCD = 0x14289C9D（只保留低32位） v1 + sum = 0x89ABCDEF + 0x9E3779B9 = 0x27E347A8 v1 \u0026gt;\u0026gt; 5 = 0x89ABCDEF \u0026gt;\u0026gt; 5 = 0x0455E6F7 (v1 \u0026gt;\u0026gt; 5) + k[1] = 0x0455E6F7 + 0x00000000 = 0x0455E6F7 异或操作： 0x14289C9D ^ 0x27E347A8 = 0x35CBDB35 0x35CBDB35 ^ 0x0455E6F7 = 0x319E3DC2 v0 = 0x01234567 + 0x319E3DC2 = 0x32C18229 第一轮后半部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 v1 += ((v0 \u0026lt;\u0026lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + k[3]) 计算各项（使用更新后的v0=0x32C18229）： v0 \u0026lt;\u0026lt; 4 = 0x32C18229 \u0026lt;\u0026lt; 4 = 0x2C182290 (v0 \u0026lt;\u0026lt; 4) + k[2] = 0x2C182290 + 0xFFFFFFFF = 0x2C18228F v0 + sum = 0x32C18229 + 0x9E3779B9 = 0xD0F8FBE2 v0 \u0026gt;\u0026gt; 5 = 0x32C18229 \u0026gt;\u0026gt; 5 = 0x01960C11 (v0 \u0026gt;\u0026gt; 5) + k[3] = 0x01960C11 + 0xABCD9876 = 0xAD63A487 异或操作： 0x2C18228F ^ 0xD0F8FBE2 = 0xFCE0D96D 0xFCE0D96D ^ 0xAD63A487 = 0x51837DEA v1 = 0x89ABCDEF + 0x51837DEA = 0xDB2F4BD9 第一轮结束后：\n1 2 3 v0 = 0x32C18229 v1 = 0xDB2F4BD9 sum = 0x9E3779B9 每轮sum增加delta，重复上述计算过程。\n经过32轮加密后（实际计算需要编程完成，这里展示最终结果）：\n1 2 v0 = 0x1268B5F9 v1 = 0x3E5A6F4C 1 密文 = 0x1268B5F9 3E5A6F4C 5.c语言实现加密 1 2 3 4 5 6 7 8 9 10 11 void Encrypt(unsigned int* data, unsigned int* key) { unsigned int v0 = data[0], v1 = data[1]; unsigned int sum = 0, delta = 0x9E3779B9; for (int i = 0; i \u0026lt; 32; i++) { sum += delta; v0 += ((v1 \u0026lt;\u0026lt; 4) + key[0]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + key[1]); v1 += ((v0 \u0026lt;\u0026lt; 4) + key[2]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + key[3]); } data[0] = v0; data[1] = v1; } 6.c语言实现解密 1 2 3 4 5 6 7 8 9 10 11 12 void Decrypt(unsigned int* data, unsigned int* key) { unsigned int v0 = data[0], v1 = data[1]; unsigned int delta = 0x9E3779B9, sum = delta * 32; for (int i = 0; i \u0026lt; 32; i++) { v1 -= ((v0 \u0026lt;\u0026lt; 4) + key[2]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + key[3]); v0 -= ((v1 \u0026lt;\u0026lt; 4) + key[0]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + key[1]); sum -= delta; } data[0] = v0; data[1] = v1; } 7.py实现解密 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def tea_decrypt(ciphertext, key): delta = 0x9e3779b9 v0, v1 = ciphertext k0, k1, k2, k3 = key sum = (delta * 32) \u0026amp; 0xffffffff for _ in range(32): v1 = (v1 - (((v0 \u0026lt;\u0026lt; 4) + k2) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + k3))) \u0026amp; 0xffffffff v0 = (v0 - (((v1 \u0026lt;\u0026lt; 4) + k0) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + k1))) \u0026amp; 0xffffffff sum = (sum - delta) \u0026amp; 0xffffffff return v0, v1 ciphertext = (0xD1B29C78, 0xF70D98A7) key = (0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210) v0, v1 = tea_decrypt(ciphertext, key) print(hex(v0), hex(v1)) # 转成字节（大端） plaintext = v0.to_bytes(4, \u0026#39;big\u0026#39;) + v1.to_bytes(4, \u0026#39;big\u0026#39;) print(\u0026#34;明文 bytes:\u0026#34;, plaintext) try: print(\u0026#34;明文字符串:\u0026#34;, plaintext.decode()) except: print(\u0026#34;不是 ASCII / UTF-8 文本\u0026#34;) xTEA算法-TEA的升级版本 加密原理 XTEA 跟 TEA 使用了相同的简单运算，但它采用了截然不同的顺序，为了阻止密钥表攻击，四个子密钥（在加密过程中，原 128 位的密钥被拆分为 4 个 32 位的子密钥）采用了一种不太正规的方式进行混合。总的来说 xTEA就是在TEA算法基础上加了一些内容，而加解密过程基本没变。\n与TEA的区别\n1.直观对比表 方面 TEA XTEA 轮函数结构 ((v1\u0026lt;\u0026lt;4)+key[0]) ^ (v1+sum) ^ ((v1\u0026gt;\u0026gt;5)+key[1]) (((v1\u0026lt;\u0026lt;4)^(v1\u0026gt;\u0026gt;5))+v1) ^ (sum+key[索引]) 密钥调度 固定模式：奇偶轮使用不同密钥对 动态模式：依赖sum值选择密钥 轮数 通常32轮（64次操作） 通常64轮（128次操作） DELTA作用 每轮增加sum 每轮增加sum，同时参与密钥索引计算 安全性 较弱，存在相关密钥攻击 较强，修复了TEA的弱点 特点：\n轮函数先计算((v1 \u0026lt;\u0026lt; 4) ^ (v1 \u0026gt;\u0026gt; 5)) + v1，再与轮密钥异或 密钥选择依赖sum：key[(sum \u0026gt;\u0026gt; 11) \u0026amp; 3]或key[sum \u0026amp; 3] 推荐64轮（128次Feistel操作） 2.c语言加密解密实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0],v1=v[1],delta=0x9E3779B9,sum=delta*num_rounds; for(i=0;i\u0026lt;num_rounds;i++){ v0+=(((v1\u0026lt;\u0026lt;4)^(v1\u0026gt;\u0026gt;5))+v1)^(sum+key[sum\u0026amp;3]); sum += delta; v1 += (((v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 5)) + v0) ^ (sum + key[(sum\u0026gt;\u0026gt;11) \u0026amp; 3]); } v[0]=v0;v[1]=v1; } void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0],v1=v[1],delta=0x9E3779B9,sum=delta*num_rounds; for(i=0;i\u0026lt;num_rounds;i++){ v1 -= (((v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 5)) + v0) ^ (sum + key[(sum\u0026gt;\u0026gt;11) \u0026amp; 3]); sum -= delta; v0-=(((v1\u0026lt;\u0026lt;4)^(v1\u0026gt;\u0026gt;5))+v1)^(sum+key[sum\u0026amp;3]); } v[0]=v0;v[1]=v1; } xxTEA算法-TEA系列改进版 加密原理 1. 传入参数 1 void xxtea_encrypt(uint32_t *v, int n, uint32_t const key[4]); v：要加密的数据（数组） n：数组长度（有多少个32位数字） key：密钥（4个32位数字，共128位） 2. 核心运算（加密特征） 1 2 // 核心混合公式（记住这个特征） MX = ((z\u0026gt;\u0026gt;5 ^ y\u0026lt;\u0026lt;2) + (y\u0026gt;\u0026gt;3 ^ z\u0026lt;\u0026lt;4)) ^ ((sum^y) + (key[编号] ^ z)); 3.c语言加密实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void xxtea_encrypt(unsigned int* v, int n, unsigned int const key[4]) { unsigned int y, z, sum = 0; unsigned int e, DELTA = 0x9e3779b9; int p, rounds = 6 + 52 / n; z = v[n - 1]; do { sum += DELTA; e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p = 0; p \u0026lt; n - 1; p++) { y = v[p + 1]; z = v[p] += ((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z)); } y = v[0]; z = v[n - 1] += ((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z)); } while (--rounds); } 4.c语言解密实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #define DELTA 0x9e3779b9 #define MX (((z\u0026gt;\u0026gt;5^y\u0026lt;\u0026lt;2)+(y\u0026gt;\u0026gt;3^z\u0026lt;\u0026lt;4))^((sum^y)+(key[(p\u0026amp;3)^e]^z))) void dtea(uint32_t *v,int n,uint32_t const key[4])//n为v数组长度 { rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do { e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p=n-1; p\u0026gt;0; p--) { z = v[p-1]; y = v[p] -= MX; } z = v[n-1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); } 魔改算法 三、常见 TEA 魔改手法（逆向重点） 1. 轮数魔改 1 for (int i = 0; i \u0026lt; 16; i++) // 不再是 32 逆向策略\n观察 sum 累加次数 看 delta 被加了多少次 用调试器统计循环次数 题目代码：\n1 2 3 4 5 6 7 8 9 10 11 12 void encrypt(uint32_t v[2], uint32_t k[4]) { uint32_t v0 = v[0], v1 = v[1]; uint32_t sum = 0; uint32_t delta = 0x9E3779B9; for (int i = 0; i \u0026lt; 12; i++) { sum += delta; v0 += ((v1 \u0026lt;\u0026lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + k[1]); v1 += ((v0 \u0026lt;\u0026lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + k[3]); } v[0] = v0; v[1] = v1; } 解密：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void decrypt1(unsigned int v[2], unsigned int k[4]) { unsigned int v0 = v[0], v1 = v[1]; unsigned int delta = 0x9E3779B9; unsigned int sum = delta * 12; for (int i = 0; i \u0026lt; 12; i++) { v1 -= ((v0 \u0026lt;\u0026lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + k[3]); v0 -= ((v1 \u0026lt;\u0026lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + k[1]); sum -= delta; } v[0] = v0; v[1] = v1; } 多轮加密，逆向 unsigned int sum = delta * 12 只变化轮数即可\n2. delta 魔改 1 delta = 0x11451419; 或者\n1 sum += delta ^ 0x12345678; 逆向策略\n搜索常数 计算 sum 的变化规律 回推等效 delta 加密\n1 2 3 4 5 6 7 8 9 10 11 12 void encrypt(uint32_t *v, uint32_t *k) { uint32_t v0 = v[0], v1 = v[1]; uint32_t sum = 0; uint32_t delta = 0x11451419; for (int i = 0; i \u0026lt; 32; i++) { sum += delta; v0 += ((v1 \u0026lt;\u0026lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + k[1]); v1 += ((v0 \u0026lt;\u0026lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + k[3]); } v[0] = v0; v[1] = v1; } 解密\n1 2 3 4 5 6 7 8 9 10 11 12 13 void decrypt2(unsigned int* v, unsigned int* k) { unsigned int v0 = v[0], v1 = v[1]; unsigned int delta = 0x11451419; unsigned int sum = delta * 32; for (int i = 0; i \u0026lt; 32; i++) { v1 -= ((v0 \u0026lt;\u0026lt; 4) + k[2]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 5) + k[3]); v0 -= ((v1 \u0026lt;\u0026lt; 4) + k[0]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 5) + k[1]); sum -= delta; } v[0] = v0; v[1] = v1; } 很类似 3. 位移参数魔改（最常见） 1 (v1 \u0026lt;\u0026lt; 3) ^ (v1 \u0026gt;\u0026gt; 7) 代替：\n1 (v1 \u0026lt;\u0026lt; 4) ^ (v1 \u0026gt;\u0026gt; 5) 逆向策略\n关注移位指令（shl / shr） 不要死记 TEA 的 4 和 5 加密\n1 2 3 4 5 6 7 8 9 10 11 12 void encrypt(uint32_t v[2], uint32_t k[4]) { uint32_t v0 = v[0], v1 = v[1]; uint32_t sum = 0; uint32_t delta = 0x9E3779B9; for (int i = 0; i \u0026lt; 16; i++) { sum += delta; v0 += ((v1 \u0026lt;\u0026lt; 3) + k[1]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 7) + k[2]); v1 += ((v0 \u0026lt;\u0026lt; 6) + k[3]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 1) + k[0]); } v[0] = v0; v[1] = v1; } 解密\n1 2 3 4 5 6 7 8 9 10 11 12 13 void decrypt3(unsigned int v[2], unsigned int k[4]) { unsigned int v0 = v[0], v1 = v[1]; unsigned int delta = 0x9E3779B9; unsigned int sum = delta * 16; for (int i = 0; i \u0026lt; 16; i++) { v1 -= ((v0 \u0026lt;\u0026lt; 6) + k[3]) ^ (v0 + sum) ^ ((v0 \u0026gt;\u0026gt; 1) + k[0]); v0 -= ((v1 \u0026lt;\u0026lt; 3) + k[1]) ^ (v1 + sum) ^ ((v1 \u0026gt;\u0026gt; 7) + k[2]); sum -= delta; } v[0] = v0; v[1] = v1; } 位移参数魔改\n4. 加减顺序魔改 1 2 v0 ^= ((v1 \u0026lt;\u0026lt; 4) + k[0]); v0 += (v1 + sum); 而不是一行完成。\n逆向策略\n合并表达式 数学上恢复原式 加密：\n1 2 3 4 5 6 7 8 9 10 11 12 void encrypt(uint32_t *v, uint32_t *k) { uint32_t v0 = v[0], v1 = v[1]; uint32_t sum = 0; uint32_t delta = 0x9E3779B9; for (int i = 0; i \u0026lt; 32; i++) { sum += delta; v0 ^= ((v1 \u0026lt;\u0026lt; 4) + k[0]) ^ (v1 + sum); v1 += ((v0 \u0026gt;\u0026gt; 5) + k[1]) ^ (v0 + sum); } v[0] = v0; v[1] = v1; } 解密：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void decrypt4(unsigned int* v, unsigned int* k) { unsigned int v0 = v[0], v1 = v[1]; unsigned int delta = 0x9E3779B9; unsigned int sum = delta * 32; for (int i = 0; i \u0026lt; 32; i++) { v1 -= ((v0 \u0026gt;\u0026gt; 5) + k[1]) ^ (v0 + sum); v0 ^= ((v1 \u0026lt;\u0026lt; 4) + k[0]) ^ (v1 + sum); sum -= delta; } v[0] = v0; v[1] = v1; } 本质依然是f函数的对称\n5. key 使用顺序魔改 1 k[(sum \u0026gt;\u0026gt; 11) \u0026amp; 3] 逆向策略\n看 key 数组索引计算 不要假设 k0~k3 固定位置 加密：\n1 2 3 4 5 6 7 8 9 10 11 12 void encrypt(uint32_t *v, uint32_t *k) { uint32_t v0 = v[0], v1 = v[1]; uint32_t sum = 0; uint32_t delta = 0x9E3779B9; for (int i = 0; i \u0026lt; 32; i++) { sum += delta; v0 += ((v1 \u0026lt;\u0026lt; 4) + k[sum \u0026amp; 3]) ^ (v1 + sum); v1 += ((v0 \u0026gt;\u0026gt; 5) + k[(sum \u0026gt;\u0026gt; 11) \u0026amp; 3]) ^ (v0 + sum); } v[0] = v0; v[1] = v1; } 解密：\n1 2 3 4 5 6 7 8 9 10 11 12 void decrypt5(unsigned int* v, unsigned int* k) { unsigned int v0 = v[0], v1 = v[1]; unsigned int delta = 0x9E3779B9; unsigned int sum = 32 * delta; for (int i = 0; i \u0026lt; 32; i++) { v1 -= ((v0 \u0026gt;\u0026gt; 5) + k[(sum \u0026gt;\u0026gt; 11) \u0026amp; 3]) ^ (v0 + sum); v0 -= ((v1 \u0026lt;\u0026lt; 4) + k[sum \u0026amp; 3]) ^ (v1 + sum); sum -= delta; } v[0] = v0; v[1] = v1; } key的数目不影响加密解密结果\n6. XOR / ADD 混用 1 v0 += expr; 变成：\n1 v0 ^= expr; 逆向策略\n注意是否仍然可逆 XOR ≠ ADD，但仍可反推 加密：\n1 2 3 4 5 6 7 8 9 10 11 12 void decrypt6(unsigned int* v, unsigned int* k) { unsigned int v0 = v[0], v1 = v[1]; unsigned int sum = 0; unsigned int delta = 0xA56BABCD; for (int i = 0; i \u0026lt; 20; i++) { sum += delta; v0 += (v1 ^ (v1 \u0026lt;\u0026lt; 5) ^ (v1 \u0026gt;\u0026gt; 3)) + k[(sum \u0026gt;\u0026gt; 13) \u0026amp; 3]; v1 += (v0 ^ (v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 7)) + k[sum \u0026amp; 3]; } v[0] = v0; v[1] = v1; } 解密：\n1 2 3 4 5 6 7 8 9 10 11 void decrypt6(unsigned int* v, unsigned int* k) { unsigned int v0 = v[0], v1 = v[1]; unsigned int delta = 0xA56BABCD; unsigned int sum = 20 * delta; for (int i = 0; i \u0026lt; 20; i++) { v1 -= (v0 ^ (v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 7)) + k[sum \u0026amp; 3]; v0 -= (v1 ^ (v1 \u0026lt;\u0026lt; 5) ^ (v1 \u0026gt;\u0026gt; 3)) + k[(sum \u0026gt;\u0026gt; 13) \u0026amp; 3]; sum -= delta; } v[0] = v0; v[1] = v1; } 知识补充 Feistel网络 一种对称加密算法的基本结构，它通过将明文分组并多轮迭代处理，实现加密和解密的功能。\nFeistel网络的核心特点是加密和解密流程完全相同，仅密钥使用顺序相反。\nF函数是Feistel网络的核心，用于对右半部分进行复杂变换。一个好的F函数需满足非线性、扩散性、雪崩效应等特性。以DES为例，其F函数包括扩展、异或、S盒替换和P盒置换等步骤。\n分组大小：64位（被分成两个32位的左半部分L和右半部分R）。 密钥大小：128位。 轮数：推荐64轮（但可调整，必须是偶数轮，因为每两轮构成一个完整的Feistel回合）。 Feistel结构的特点是，每一轮只加密一半的数据块，并与另一半进行交换。这使得加解密过程非常相似，只是子密钥的使用顺序不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #define DELTA 0x9e3779b9 #define MX (((z\u0026gt;\u0026gt;5^y\u0026lt;\u0026lt;2) + (y\u0026gt;\u0026gt;3^z\u0026lt;\u0026lt;4)) ^ ((sum^y) + (key[(p\u0026amp;3)^e] ^ z))) // XXTEA 加密 void btea_encrypt(uint32_t *v, int n, uint32_t const key[4]) { uint32_t y, z, sum; unsigned p, rounds, e; if (n \u0026lt; 1) return; rounds = 6 + 52/n; sum = 0; z = v[n-1]; do { sum += DELTA; e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p = 0; p \u0026lt; n-1; p++) { y = v[p+1]; v[p] += MX; z = v[p]; } y = v[0]; v[n-1] += MX; z = v[n-1]; } while (--rounds); } // XXTEA 解密 void btea_decrypt(uint32_t *v, int n, uint32_t const key[4]) { uint32_t y, z, sum; unsigned p, rounds, e; if (n \u0026lt; 1) return; rounds = 6 + 52/n; sum = rounds * DELTA; y = v[0]; do { e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p = n-1; p \u0026gt; 0; p--) { z = v[p-1]; v[p] -= MX; y = v[p]; } z = v[n-1]; v[0] -= MX; y = v[0]; sum -= DELTA; } while (--rounds); } // 示例：加密字符串 void example_string_encryption() { char plaintext[] = \u0026#34;Hello, XXTEA! This is a test message.\u0026#34;; uint32_t key[4] = {0x12345678, 0x9ABCDEF0, 0x11223344, 0x55667788}; // 计算需要多少32位字 int len = strlen(plaintext); int n = (len + 3) / 4; // 向上取整 uint32_t *data = (uint32_t*)malloc(n * 4); // 复制数据并填充 memset(data, 0, n * 4); memcpy(data, plaintext, len); printf(\u0026#34;Original text: %s\\n\u0026#34;, plaintext); printf(\u0026#34;Text length: %d bytes\\n\u0026#34;, len); printf(\u0026#34;Block size: %d words (%d bytes)\\n\u0026#34;, n, n * 4); // 加密 btea_encrypt(data, n, key); printf(\u0026#34;\\nEncrypted data (hex):\\n\u0026#34;); for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%08X \u0026#34;, data[i]); if ((i + 1) % 4 == 0) printf(\u0026#34;\\n\u0026#34;); } // 解密 btea_decrypt(data, n, key); printf(\u0026#34;\\nDecrypted text: %s\\n\u0026#34;, (char*)data); free(data); } int main() { example_string_encryption(); return 0; } ","date":"2025-12-14T00:00:00Z","image":"http://localhost:1313/p/12-14/bj_hu_38000477179d8f54.jpg","permalink":"http://localhost:1313/p/12-14/","title":"12-14 TEA"},{"content":"","date":"2025-12-13T00:00:00Z","image":"http://localhost:1313/p/12-13/bj_hu_f5b78579869f8b48.jpg","permalink":"http://localhost:1313/p/12-13/","title":"12-13 TEA"},{"content":"base64编码 - 一种编码方式\n编码原理 将每一个字符转换成二进制数字，然后按六位一组分开，用新的六位二进制值解释成新的整数，然后取对应字符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 编码Man： 原始数据（ASCII 编码）： M -\u0026gt; 01001101 a -\u0026gt; 01100001 n -\u0026gt; 01101110 合并成 24 位： 01001101 01100001 01101110 拆分为 6 位的块： 010011 010110 000101 101110 将每 6 位二进制块映射为 Base64 字符： 010011 -\u0026gt; 19 -\u0026gt; T 010110 -\u0026gt; 22 -\u0026gt; W 000101 -\u0026gt; 5 -\u0026gt; F 101110 -\u0026gt; 46 -\u0026gt; u 编码结果： \u0026#34;Man\u0026#34; -\u0026gt; \u0026#34;TWFu\u0026#34; 如果输入的数据，转换成二进制数据后不是3的倍数，Base64 会在末尾补上 = 作为填充符。 解码即逆向思考，将编码转化为二进制数据，6位合并成8位，然后去掉= base64编码c语言实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 char* base64encry(char* input) { int len = 0, str_len = 0; char* encry; char table64[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; len = strlen(input); if (len % 3 == 0) str_len = (len / 3) * 4; else str_len = ((len / 3) + 1) * 4; encry = (char*)malloc(sizeof(char) * str_len + 1); for (int i = 0, j = 0; i \u0026lt; len; i += 3, j += 4) { encry[j] = table64[input[i] \u0026gt;\u0026gt; 2]; encry[j + 1] = table64[((input[i] \u0026amp; 0x3) \u0026lt;\u0026lt; 4) | ((input[i + 1]) \u0026gt;\u0026gt; 4)]; encry[j + 2] = table64[((input[i + 1] \u0026amp; 0xf) \u0026lt;\u0026lt; 2) | (input[i + 2] \u0026gt;\u0026gt; 6)]; encry[j + 3] = table64[input[i + 2] \u0026amp; 0x3f]; } switch (len % 3) { case 1: encry[str_len - 1] = \u0026#39;=\u0026#39;; encry[str_len - 2] = \u0026#39;=\u0026#39;; break; case 2: encry[str_len - 1] = \u0026#39;=\u0026#39;; break; } encry[str_len] = \u0026#39;\\0\u0026#39;; return encry; } base64原码解码c语言实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 char* base64decry(char* input) { int table[] = { 0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,62,0,0,0,63, 52,53,54,55,56,57,58,59,60,61,0,0, 0,0,0,0,0,0,1,2,3,4,5,6, 7,8,9,10,11,12,13,14,15,16,17,18, 19,20,21,22,23,24,25,0,0,0,0,0, 0,26,27,28,29,30,31,32,33,34,35,36, 37,38,39,40,41,42,43,44,45,46,47,48, 49,50,51, }; int len = 0, str_len = 0; char* decry; len = strlen(input); if (strstr(input, \u0026#34;==\u0026#34;)) str_len = (len / 4) * 3 - 2; else if (strstr(input, \u0026#34;=\u0026#34;)) str_len = (len / 4) * 3 - 1; else str_len = (len / 4) * 3; decry = (char*)malloc(sizeof(char) * str_len + 1); for (int i = 0, j = 0; i \u0026lt; len; i += 4, j += 3) { decry[j] = (table[input[i]] \u0026lt;\u0026lt; 2) | (table[input[i + 1]] \u0026gt;\u0026gt; 4); decry[j + 1] = ((table[input[i + 1]]) \u0026amp; 0xf) \u0026lt;\u0026lt; 4 | (table[input[i + 2]] \u0026gt;\u0026gt; 2); decry[j + 2] = ((table[input[i + 2]]) \u0026amp; 0x3) \u0026lt;\u0026lt; 6 | (table[input[i + 3]]); } decry[str_len] = \u0026#39;\\0\u0026#39;; return decry; } 映射表的生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #define _CRT_SECURE_NO_WARNINGS 1 //生成映射表 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define TABLE_SIZE 128 // 生成解密映射表的函数 void generate_decoding_table(const char* encoding_table, int* decoding_table) { // 初始化解密映射表，将所有元素置为 0 memset(decoding_table, 0, TABLE_SIZE * sizeof(int)); // 遍历编码表中的每个字符 for (int i = 0; i \u0026lt; 64; i++) { // 获取当前字符的 ASCII 码值 int ascii_value = (int)encoding_table[i]; // 将该字符在编码表中的索引值存入解密映射表对应位置 decoding_table[ascii_value] = i; } } // 打印解密映射表的函数 void print_decoding_table(int* decoding_table) { printf(\u0026#34;{\\n\u0026#34;); for (int i = 0; i \u0026lt; TABLE_SIZE - 5; i++) { if (i % 12 == 0 \u0026amp;\u0026amp; i != 0) { printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;%d,\u0026#34;, decoding_table[i]); } printf(\u0026#34;\\n};\\n\u0026#34;); } int main() { // 标准的 Base64 编码字符表 const char standard_encoding_table[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; int decoding_table[TABLE_SIZE]; // 生成解密映射表 generate_decoding_table(standard_encoding_table, decoding_table); // 打印解密映射表 print_decoding_table(decoding_table); return 0; } 建立索引 decoding_table[ascii_value] = i;\n建立解码映射：\ni 是字符在编码表中的位置（0~63） ascii_value 是字符的 ASCII 码（如 \u0026lsquo;A\u0026rsquo;=65） decoding_table[ascii_value] = i 表示： 当遇到 ASCII 码为 ascii_value 的字符时，它对应的 Base64 索引值是 i 示例： 若编码表第一个字符是 \u0026lsquo;A\u0026rsquo;（ASCII 65），i=0，则执行： decoding_table[65] = 0 这样解码时，遇到字符 \u0026lsquo;A\u0026rsquo;，查 decoding_table[65] 就直接得到索引 0。\n魔改原理 base64的魔改主要有两个方式\n修改索引的魔改，俗称换表 对下标进行额外的的偏移\n魔改加密时：原始数据 → 标准Base64编码 → 将编码结果按 b 表替换（a[j] 换成 b[j]）。 这段解密代码：将 c 每个字符在魔改表 b 中找到位置 j → 换成标准表 a 中同一位置的字符。 结果 c 变成了标准Base64字符串，之后可用标准Base64解码得到原始数据。 本质：换表只是字符替换密码，不改变Base64编码结构，只改变了字符外观。解密就是查反向映射还原为标准Base64，再正常解码。\n换表的c语言解密 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 static void main() { char a[64] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; char b[64] = \u0026#34;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/\u0026#34;; char c[] = \u0026#34;Wj1gWE9xPSGUQ0KCPCGET09WR1qSzZ\u0026#34;; for (int i = 0; i \u0026lt; strlen(c); i++) { for (int j = 0; j \u0026lt; 64; j++) { if (c[i] == b[j]) { c[i] = a[j]; break; } } } for (int i = 0; i \u0026lt; strlen(c); i++) { printf(\u0026#34;%c\u0026#34;, c[i]); } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;%s\u0026#34;, c); } 循环寻找解密字符串在魔改表中的对应，然后映射到原表的码，最后用原表解密 换表的py解密 1 2 3 4 5 6 7 8 9 10 11 12 import base64 # 导入base64模块用于解密 #这里是先把密文映射替换相当于原表还是标准表 s1 = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#39; s2 = \u0026#39;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/\u0026#39; en_text = \u0026#39;Wj1gWE9xPSGUQ0KCPCGET09WR1qSzZ==\u0026#39; # 密文 map = str.maketrans(s2, s1) # 用str类中的maketrans建立映射，注意第一个参数是需要映射的字符串，第二个参数是映射的目标 map_text = en_text.translate(map) # 映射实现替换密文，替换前是base64换表加密，替换后则是base64标准表加密 print(map_text) # 可以先看看标准表加密的原base64密文 print(base64.b64decode(map_text)) # 直接使用提供的base64解密函数解密 密文处如果不是4的倍数需要填充=\n第二种代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import base64 a = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; b = \u0026#34;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/\u0026#34; c = \u0026#34;Wj1gWE9xPSGUQ0KCPCGET09WR1qSzZ\u0026#34; mapping = dict(zip(b, a)) standard_base64 = \u0026#39;\u0026#39;.join(mapping[ch] for ch in c) # 补足填充符 padding = 4 - len(standard_base64) % 4 if padding != 4: standard_base64 += \u0026#39;=\u0026#39; * padding decoded = base64.b64decode(standard_base64.encode()).decode() decodedd = base64.b64decode(standard_base64) print(decoded) print(decodedd) 改索引/移位密钥的处理 加密过程\n原始数据 → 标准Base64编码 → 得到标准Base64字符串。 对每个字符：查标准Base64表得到索引值 → 加上密钥 key[i % 4] → 用魔改表（或原表）根据新索引取字符输出。 1 2 原始数据 → 标准Base64编码 → 得到标准字符 → 查标准表得索引 → 索引+密钥 → 查自定义表 → 输出密文 (内置b64encode) (如\u0026#34;QQ==\u0026#34;) (如索引0) (如+5→5) (取第5个字符) (如\u0026#34;f\u0026#34;) 解密过程\n对密文字符：查魔改表得到索引值 → 减去密钥 key[i % 4]（负数则+64）→ 得到标准Base64索引值。 将索引值按Base64规则重组为字节数据。 1 2 密文 → 查自定义表得索引 → 索引-密钥 → 得标准索引 → 查标准表得字符 → 拼接 → 标准Base64解码 → 原始数据 (如\u0026#34;f\u0026#34;) (如得到5) (5-5→0) (索引0) (字符\u0026#34;Q\u0026#34;) (\u0026#34;QQ==\u0026#34;) (内置b64decode) (如\u0026#34;@\u0026#34;) 本质：在Base64编码的索引层做了加法掩蔽，相当于在6位值上做了循环移位混淆。这比单纯换表多了一层算术变换，但仍是可逆的简单混淆。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 table = \u0026#34;CDABGHEFKLIJOPMNSTQRWXUVabYZefcdijghmnklqropuvstyzwx23016745+/89\u0026#34; # base64当前表 cipher = \u0026#34;TqK1YUSaQryEMHaLMnWhYU+Fe0WPenqhRXahfkV6WE2fa3iRW197Za62eEaD\u0026#34; # 密文 cipher = cipher.rstrip(\u0026#39;=\u0026#39;) #去除密文多余的\u0026#39;=\u0026#39; _index = [] key = [1, 2, 3, 4] #正常设置为[0,0,0,0]就可以 for i in range(len(cipher)): tmp = table.index(cipher[i]) - key[i % 4] # 减去加密时加上的key if tmp \u0026gt;= 0: _index.append(tmp) else: # 因为减去key会导致索引变成负数，+64保证在正常索引范围 _index.append(tmp + 64) #print(_index) for i in range(0, len(_index), 4): a = _index[i] b = _index[i + 1] c = _index[i + 2] if i + 2 \u0026lt; len(_index) else 0 # 添加范围检查，为未处理部分设为0 d = _index[i + 3] if i + 3 \u0026lt; len(_index) else 0 sum = a \u0026lt;\u0026lt; 18 | b \u0026lt;\u0026lt; 12 | c \u0026lt;\u0026lt; 6 | d for j in range(3): if i * 6 + j * 8 \u0026lt; len(cipher) * 8: # 检查是否超出原始编码长度 print(chr((sum \u0026gt;\u0026gt; ((2 - j) * 8)) \u0026amp; 0xff), end=\u0026#34;\u0026#34;) 后续可利用py带的base64库快速解码 std_table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; b64_str = \u0026#39;\u0026#39;.join(std_table[i] for i in _index) print(base64.b64decode(b64_str)) 注意事项 1.设定的key在ida中可能不会显示出来，直接就导入在算法里面成为固定的整数\n2.变索引有很多类型\n+key ^ key *k imul and 3Fh 都可以进行索引的更改，此处只例举了加索引的例子，其他的需要有遇到例题再添加\n3.key也会有不同的形式\nStep 3：判断 key 的形式 常量？ 数组？ i % n？ 跟位置相关？ 都是需要在解题过程中注意\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 例题 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; char* base64encry(char* input) { int len = 0, str_len = 0; char* encry; char table64[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; len = strlen(input); if (len % 3 == 0) str_len = (len / 3) * 4; else str_len = ((len / 3) + 1) * 4; encry = (char*)malloc(sizeof(char) * str_len + 1); for (int i = 0, j = 0; i \u0026lt; len; i += 3, j += 4) { encry[j] = table64[input[i] \u0026gt;\u0026gt; 2]; encry[j + 1] = table64[((input[i] \u0026amp; 0x3) \u0026lt;\u0026lt; 4) | ((input[i + 1]) \u0026gt;\u0026gt; 4)]; encry[j + 2] = table64[((input[i + 1] \u0026amp; 0xf) \u0026lt;\u0026lt; 2) | (input[i + 2] \u0026gt;\u0026gt; 6)]; encry[j + 3] = table64[input[i + 2] \u0026amp; 0x3f]; } switch (len % 3) { case 1: encry[str_len - 1] = \u0026#39;=\u0026#39;; encry[str_len - 2] = \u0026#39;=\u0026#39;; break; case 2: encry[str_len - 1] = \u0026#39;=\u0026#39;; break; } encry[str_len] = \u0026#39;\\0\u0026#39;; return encry; } char* base64(char* input) { int len = 0, str_len = 0; char* encry; char table64[] = \u0026#34;CDABGHEFKLIJOPMNSTQRWXUVabYZefcdijghmnklqropuvstyzwx23016745+/89\u0026#34;; int key[] = { 1, 2, 3, 4 }; len = strlen(input); if (len % 3 == 0) str_len = (len / 3) * 4; else str_len = ((len / 3) + 1) * 4; encry = (char*)malloc(sizeof(char) * str_len + 1); for (int i = 0, j = 0; i \u0026lt; len; i += 3, j += 4) { unsigned char k1 = input[i] \u0026gt;\u0026gt; 2; unsigned char k2 = ((input[i] \u0026amp; 0x3) \u0026lt;\u0026lt; 4) | (input[i + 1] \u0026gt;\u0026gt; 4); unsigned char k3 = ((input[i + 1] \u0026amp; 0xf) \u0026lt;\u0026lt; 2) | (input[i + 2] \u0026gt;\u0026gt; 6); unsigned char k4 = input[i + 2] \u0026amp; 0x3f; encry[j] = table64[(k1 + key[0]) \u0026amp; 0x3F]; encry[j + 1] = table64[(k2 + key[1]) \u0026amp; 0x3F]; encry[j + 2] = table64[(k3 + key[2]) \u0026amp; 0x3F]; encry[j + 3] = table64[(k4 + key[3]) \u0026amp; 0x3F]; } switch (len % 3) { case 1: encry[str_len - 1] = \u0026#39;=\u0026#39;; encry[str_len - 2] = \u0026#39;=\u0026#39;; break; case 2: encry[str_len - 1] = \u0026#39;=\u0026#39;; break; } encry[str_len] = \u0026#39;\\0\u0026#39;; return encry; } int main() { char v1[] = \u0026#34;X0iYf6OJNaebeVZ0VlmMdluYNUWqQ1lD\u0026#34;; char v2[100] = {0}; printf(\u0026#34;请输入flag：\u0026#34;); scanf(\u0026#34;%s\u0026#34;,v2); char* v3,*v4,*v5; v3 = base64encry(v2); v5 = base64(v3); if (*v1 == *v5) printf(\u0026#34;success\u0026#34;); else printf(\u0026#34;wrong\u0026#34;); return 0; } 编译成exe，然后在ida中看 这是解密脚本 import base64 t2 = \u0026#39;CDABGHEFKLIJOPMNSTQRWXUVabYZefcdijghmnklqropuvstyzwx23016745+/89\u0026#39; t3 = \u0026#39;X0iYf6OJNaebeVZ0VlmMdluYNUWqQ1lD\u0026#39; key = [1,2,3,4] _index = [] for i in range(len(t3)): tmp = t2.index(t3[i]) - key[i % 4] if tmp \u0026gt;= 0: _index.append(tmp) else: _index.append(tmp + 64) std_table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; b64_str = \u0026#39;\u0026#39;.join(std_table[i] for i in _index) print(base64.b64decode(b64_str)) base64模块的语法使用 1. 编码\nbase64.b64encode(s) 参数：s 必须是 bytes 返回：bytes（Base64 编码结果） base64.b64encode(s).decode() 把 bytes 结果转为字符串 2. 解码\nbase64.b64decode(s) 参数：s 可以是 bytes 或 str（只含 Base64 字符） 返回：bytes（解码后的原始数据） base64.b64decode(s).decode('utf-8') 把解码结果转为 UTF-8 字符串 3. 处理换行/URL安全\nbase64.standard_b64encode(s) / standard_b64decode(s) 标准 Base64 base64.urlsafe_b64encode(s) / urlsafe_b64decode(s) URL 安全（+→-，/→_） 4. 带填充控制\nbase64.b64decode(s, validate=True) validate=False 时忽略非 Base64 字符 示例：\npython\n1 2 3 4 5 6 7 8 9 10 import base64 # 编码 enc = base64.b64encode(b\u0026#34;hello\u0026#34;).decode() # \u0026#39;aGVsbG8=\u0026#39; # 解码 dec = base64.b64decode(\u0026#34;aGVsbG8=\u0026#34;).decode() # \u0026#39;hello\u0026#39; # URL安全 url_enc = base64.urlsafe_b64encode(b\u0026#34;data\u0026#34;).decode() # \u0026#39;ZGF0YQ==\u0026#39; 关键点：\n输入输出默认都是 bytes，字符串需用 .encode() 和 .decode() 转换 解码自动处理填充符 = 模块还有 b32encode、b16encode 等其他进制编码 重要概念: 1.映射表 解码实现中table表即原码的映射表，用来表示至少为123位（ z 的ASCII码是 122 ）数组的解码，用索引字符的ASCII值作为小标，直接取出字符对应的6位数值，是一种用空间换时间的方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 举例： 原base64编码表为 table64= \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; 而字符`B`的 ASCII 是 66，那么 table[66] 就等于 1，因为`B`在 Base64 编码表中排第 1（从`A`为 0 开始） 如果不使用映射表的话 就必须手动判断输入字符的范围并计算对应值在填充: int val = 0; if(ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) val = ch - \u0026#39;A\u0026#39;; else if(ch \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) val = ch - \u0026#39;a\u0026#39; + 26; else if(ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) val = ch - \u0026#39;0\u0026#39; + 52; else if(ch == \u0026#39;+\u0026#39;) val = 62; else if(ch == \u0026#39;/\u0026#39;) val = 63; else if(ch == \u0026#39;=\u0026#39;) val = 0; // 填充符 不可见字符的处理 Base64规范中只有64个字符和=，其他都应忽略。处理方式：遍历输入字符串，跳过非Base64字符（即不在A-Za-z0-9+/=中的字符），将有效字符复制到新缓冲区再进行解码。否则直接解码会因table索引越界或取到错误值导致乱码或崩溃。\nmemset 1 memset(起始地址, 要设置的值, 要设置的字节数) 常见用途：\n数组/内存块清零：memset(arr, 0, sizeof(arr)) 初始化结构体：memset(\u0026amp;obj, 0, sizeof(obj))（注意会清空所有成员，包括指针） 填充特定值：如 memset(buffer, 0xFF, size) 全填为 255 字符串结尾安全处理：在敏感数据使用后填充 0 防残留 ","date":"2025-12-12T00:00:00Z","image":"http://localhost:1313/p/12-12/bj_hu_5b308d272a9059d2.jpg","permalink":"http://localhost:1313/p/12-12/","title":"12-12 base64"},{"content":"IDA:\n字符串定位\nview -\u0026gt; open subviews -\u0026gt; strings\n交叉引用窗口，找出什么代码使用了这个字符串\nX\ntab,F5 反汇编，\n编译过程中给函数命的名会变为数字，反汇编窗口中可以进行重新命名,右键rename\n左边框 ctrl + f 直接搜索函数名\n如果有不可见字符，ida一般会用一个名字来代替返回的字符串\n提取数据 lazyida\nR键可以切换\n基础加密：凯撒加密，异或加密\nbase64编码（使用64个可打印字符编码所有的数据）逆向，根据特征常量确定标准算法\n特征常量，不变的字符串，\nbase64编码变表逆向\n魔改表，利用base64编码原理，\n1 2 data = \u0026#39;\u0026#39; a = T5[T4.data(ch)] 在原编码表中找魔改码的位置，然后打印\nida 动态调试\n不依赖于外部输入，每次输入后程序内部调取加密的字符串\n执行程序，在12行处中断然后看str是什么\n伪代码，寄存器，内存，栈\n断点F2，步入F7，步过F8\n利用动态调试观察某一些加密函数的返回值来判断加密类型\n1\n调试中单步步过，如果程序未继续执行，也就是进入阻塞状态，输入函数卡住\n内存跳转 G\n创建字符串 A\nida代码修复，数组识别\n1.返回值\n","date":"2025-12-07T00:00:00Z","image":"http://localhost:1313/p/12-07/gui_hu_896bd7a8c52d7c18.jpg","permalink":"http://localhost:1313/p/12-07/","title":"12-07 IDA"},{"content":"函数的ABI规范\n- 参数通过 rdi, rsi, rdx... 传递 - 返回值在 rax - rbx, rbp, r12–r15 是 callee-saved，其余是 caller-saved\n寄存器的分类\n参数/返回 rdi, rsi, rdx, rcx, r8, r9, rax 传参 + 返回值 callee-saved rbx, rbp, r12–r15 可安全用于保存中间值 临时（caller-saved） r10, r11 自由使用，调用函数后可能被破坏 使用地址中的参数，注意要求导入的数据长度\n多个参数的传递：\n参数序号 寄存器（64位） 32位形式 用途说明 第1个 rdi edi 常用于目标地址（如 dest） 第2个 rsi esi 常用于源地址（如 src） 第3个 rdx edx 数据、长度等 第4个 rcx ecx 计数、标志等 第5个 r8 r8d — 第6个 r9 r9d — 超过6个则需要使用栈传递（注意保持16字节对齐）\n浮点数用XMM寄存器\n函数中用栈使用数组时，需要对其清零\n1 2 3 4 5 6 7 mov rcx, 0 clear_loop: mov word ptr [rsp + rcx*2], 0 inc rcx cmp rcx, 256 jl clear_loop 循环清零计数器，处理完rsp设定字节 ","date":"2025-12-06T00:00:00Z","image":"http://localhost:1313/p/12-06/bj_hu_1fde86f2971c1e86.jpg","permalink":"http://localhost:1313/p/12-06/","title":"12-06 汇编编写"},{"content":"控制流逻辑\n在完成条件多路跳转时，必须使用 je + jmp done 隔离\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 .intel_syntax noprefix .text .global _start _start: mov eax,[rdi] cmp eax,0x7f454c46 je Add cmp eax,0x00005A4D je Sub jmp cheng Add: mov eax,[rdi+4] add eax,[rdi+8] add eax,[rdi+12] jmp done Sub: mov eax,[rdi+4] sub eax,[rdi+8] sub eax,[rdi+12] jmp done cheng: mov eax,[rdi+4] imul eax,[rdi+8] imul eax,[rdi+12] jmp done done: 以上代码中，如果没有jmp done指令，各个指令之间会穿透，即按顺序执行到底，导致代码运行错误\n2\n数据宽度问题，rax和eax的位数使用，使用不满足题意的高位字节，导致引入垃圾数据，破坏原本的数（负数破坏成正数）\n3\n拓展有符号数\ncdqe拓展\n1 sign-extend EAX to RAX 4\n逆向中跳转表的识别\n在反汇编中看到以下模式，很可能是跳转表：\n1 2 3 4 cmp eax, 7 ja default mov rax, qword ptr [table + rax*8] jmp rax 或\n1 2 lea rax, [table] jmp [rax + rcx*8] 5\n跳转表，示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 .intel_syntax noprefix .text .global _start ; 跳转表（必须对齐，通常放 .text 或 .rodata） jtab: .quad do_add .quad do_sub .quad do_mul .quad do_div _start: mov rax, [rdi] ; x = [rdi] cmp rax, 3 ja default ; if (x \u0026gt; 3) goto default ; 跳转表分发 jmp [jtab + rax*8] do_add: mov rax, [rdi+8] add rax, [rdi+16] jmp done do_sub: mov rax, [rdi+8] sub rax, [rdi+16] jmp done do_mul: mov rax, [rdi+8] imul rax, [rdi+16] jmp done do_div: mov rax, [rdi+8] cqo ; sign-extend rax to rdx:rax idiv qword ptr [rdi+16] ; signed divide jmp done default: xor rax, rax ; y = 0 done: ; rax = result 汇编的伪指令，在内存中定义一个或多个字节的常量\n1 2 3 4 .byte → 1 字节 .word → 2 字节（16 位） .long 或 .int → 4 字节（32 位） .quad → 8 字节（64 位） ==必须做边界检查==\n1 2 cmp rax, MAX_INDEX ja default ; 否则可能跳到任意地址（严重安全漏洞！） 跳转表最好连续，因为其属于在内存中被读取出的地址，最好是放在只读数据段\n提供跳转表的前提下，注意跳转表的溢出条件，可能溢出条件会写在跳转表的末尾\n","date":"2025-12-05T00:00:00Z","image":"http://localhost:1313/p/12-05/bj_hu_629806334e34bf7a.jpg","permalink":"http://localhost:1313/p/12-05/","title":"12-05 汇编编写"},{"content":"汇编语言中的数据\nBinary 二进制\n二进制构建的逻辑门简单易懂，便于组合\n每个十进制位可以表示3.2个二进制位，8进制表示三个，16进制表示四个\n通常用十六进制来表示数便于人类阅读\nASCII UTF-8\n上面表示十六进制的第一个进制位数，左边表示第二个进制位数\n大写字母通常是 0x40 + 一些数字，小写字母是 0x60 + , 数字是 0x30 + UTF-8 非常重要，来源于ASCII，可以表示多国语言，表情符号\n","date":"2025-12-04T00:00:00Z","image":"http://localhost:1313/p/12-04/bj_hu_eab232f632287f74.jpg","permalink":"http://localhost:1313/p/12-04/","title":"12-04 汇编编写"},{"content":"内中断 中断信息，来源于内部或者外部的 使得cpu立即处理的信息 ，本章着重讨论内部产生的中断信息\n1 2 3 4 1；除法错误 如执行div产生的除法溢出 2；单步执行 3；into指令 4；int指令 8086通过中断类型码的数据来表示终端信息的来源。\n中断类型码为一个字节型数据，表示256种中断信息的来源\n1 2 3 4 5 6 中断类型码 1；除法错误 0 2；单步执行 1 3；into指令 4 4；int指令 int n,指令中的n为字节型立即数，提供给cpu的中断类型码 中断处理程序：用来处理中断信息的程序\n中断向量表，中断处理程序入口地址的列表，在内存中保存，储存着256个中断源所对应的中断处理程序的入口，cpu知晓中断类型码之后，将中观类型吗作为中断向量表的表象好，定位相应的表项，就能够获得中断处理程序的入口地址\n8086中规定，0000:0000 到 0000:03FF 的1024个单元中存放着中断向量表\n向量表中，一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，入口地址包括段地址和偏移地址\n中断执行过程\n1 2 3 4 5 6 1.从中断信息中取得中断类型码 2.标志寄存器的值入栈 3.设置标志寄存器的第八位TF，第九位IF的值为0 4.CS的内容入栈 5.IP入栈 6.从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS 由于cpu随时可能检测到中断信息，就是cpu随时可能执行中断程序，所以中断处理程序必须一直存储在内存某段空间之中，而中断处理程序的入口地址，即中断向量，必须储存在对应的中断向量表表项中\n1 2 3 4 5 6 7 8 9 1；保存用到的寄存器 2；处理中断 3；恢复用到的寄存器 4；用iret指令返回 iret pop ip pop cs popf 计算代码长度\n利用 - 用 offset do0end - offset do0\n设置中断向量\n中断向量表中的0号表项中，使do0成为0号中断的中断处理程序\n0:0字单元存放偏移地址，0:2字单元存放段地址\n1 2 3 4 mov ax,0 mov es,ax mov word ptr es:[0*4],200h mov word ptr es:[0*4 + 2],0 单步中断\ncpu执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程，中断类型码为1\n1 2 3 4 1；取得中断类型码1 2；标志寄存器入栈，TF，IF设置为0 3；CS,IP入栈 4；(ip) = (1*4),(cs) = (1*4+2) 在debug中以t指令的方式展现，cpu执行完t指令后，将TF置为1，然后cpu执行单步中断，再显示所有寄存器中的内容，并且等待输入命令\n中断过程中TF置0，是为了防止cpu在执行中断过程程序中再去执行中断过程\n不相应中断的特殊情况：（一个例子）\n1 2 3 执行完向ss传递数据的指令之后，如果发生中断，是不执行的。 因为ss与sp一同构成栈空间，而中断指令执行的过程中会向栈中压入数据 如果ss和sp不一起执行，会形成错误的栈空间，导致内存错误 int 指令 内中断中由int指令引发的中断\n格式 int n\n取码 ，入栈，调整TF和IF的值 ，然后IP和CS赋值，再转去执行n号中断的中断处理程序\n在程序中用int调用任何一个中断的中断处理程序\n一般情况下，系统将一些具有一定功能的子程序以中断处理程序的方式提供给应用程序调用，编程时就可以通过int来调用这些子程序。可以将中断处理程序简称为中断例程\nBIOS 和 DOS 所提供的中断例程 系统板的ROM存放着一套成勋，成为BIOS（基本输入输出系统）\n1 2 3 4 1;硬件系统的检测和初始化程序 2;外部中断和内部中断的中断例程 3;用于对硬件设备进行I/O操作的中断例程 4;其他和硬件系统相关的中断例程 bios是连接硬件与操作系统的最底层软件，必不可少的系统软件\nbios中断的应用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 int 10h 设置光标位置功能 mov ah,2\t置光标 mov bh,0\t第0页 mov dh,5\tdh中放行号 mov dl,12\tdl中放列号 int 10h 显示字符功能 mov ah,0\t在光标位置显示字符 mov al,\u0026#39;a\u0026#39;\t字符 mov bl,7\t颜色属性 mov bh,0\t第0页 mov cx,3\t字符重复个数 int 10h 代码样例 assume cs:code code segment mov ah,2 mov bh,0 mov dh,5 mov dl,12 int 10h mov ah,9 mov al,\u0026#39;a\u0026#39; mov bl,11001010b mov bh,0 mov cx,3 int 10h mov ax,4c00h int 21h code ends end dos中断例程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 assume cs:code data segment db \u0026#39;Welcome to masm\u0026#39;, \u0026#39;$\u0026#39; data ends code segment start: mov ah,2\t置光标 mov bh,0\t第0页 mov dh,5\tdh中放行号 mov dl,12\tdl中放列号 int 10h mov ax,data mov ds,ax mov dx,0\tds:dx指向字符串的首地址data:0 mov ah,9\t表示调用第21h号中9号子程序，功能为在从光标位置显示字符串 int 21h mov ax,4c00h int 21h code ends end start $本身不显示，起到边界的作用 正常的int 21h返回是4ch号功能 即： mov ah,4ch mov al,0 int 21h ","date":"2025-12-03T00:00:00Z","image":"http://localhost:1313/p/12-03/bj_hu_b8939723aaa31462.jpg","permalink":"http://localhost:1313/p/12-03/","title":"12-03 内中断"},{"content":"标志寄存器（flag寄存器） ==flag寄存器每一都有专门的含义，用于记录特定的信息==\nflag 寄存器 结构\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 OF DF IF TF SF ZF AF PF CF ZF 标志\n零标志位，记录执行指令后的结果是否为0\n结果为0 -\u0026gt; ZF = 1 结果不为0 -\u0026gt; ZF = 0\n为1为0的背后逻辑：标记计算结果是否为0，标记为真，即ZF = 1 说明成立，标记为假，等于0，说明不成立\nPF 标志\n奇数偶数标志位，记录执行后结果中的 1 的个数是否为偶数\n1 2 3 4 5 6 7 8 9 10 mov al,1 add al,10 ax = 0000 1011 num(1) = 3 PF = 0 if ax = 0000 0011 num(1) = 2 PF = 1 SF 标志\n符号标志位。记录执行指令后结果是否为负数\n结果为负 SF = 1 ， 结果为正 SF = 0 计算机中的数分为有符号数和无符号数两种，两种数表示的范围不一样，同一段二进制码不同的表达会表示不同的数\n1 2 00000001B 无符号数1.有符号数+1 10000001B 无符号数129，有符号数-127 CF 标志\n进位标志位。用来记录借位或进位。\n1 2 3 4 5 6 7 8 9 10 mov al,98H add al,al 两个8为数据相加大于8为可容纳值时，会产生从最高有效位想更高维的进位，之前只是说这会导致数据丢失 其实在运算的时候会将他记录在一个特殊寄存器的某一位中，8086中是用CF来记录 执行后 (al) = 30H , CF = 1 add al,al 执行后 (al) = 60H , CF = 0 mov al,97h 减法的借位值也会记录下来 sub al,98h 执行后 (al) = FFH , CF = 1 sub al,al 执行后 (al) = 0 , CF = 0 OF 标志\n溢出标志位。记录了有符号数运算的结果是否发生了溢出。发生溢出：OF = 1 ,未发生溢出 ： OF = 0\ncpu在执行计算指令的时候，就包含了两种含义：无符号数运算和有符号数运算。\n而OF和CF的存储实际上是相互独立的，对于同一个计算结果从两个不同的角度来储存，区别只在于调用从哪那个方向理解\nadc 指令 adc是带进位加法指令，利用CF上记录的进位值\nadc 操作对象1 操作对象2\n操作对象1 = 操作对象1 + 操作对象2 + CF\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 adc ax,bx (ax) = (ax) + (bx) + CF 例子： mov ax,2 mov bx,1 sub bx,ax adc ax,1 (ax) = 4 (ax) + 1 + CF = 2 + 1 + 1 = 4 mov ax,1 add aax,ax adc ax,3 (ax) = 5 (ax) + 3 + CF = 2 + 3 + 0 =5 mov al,98H add al,al adc al,3 (al) = 34H (al) + 3 + CF = 30H + 3 + 1 = 34H 指令意义：\n可以对高位进行相加\n如果数据的位数大于16，并且相加还有进位的情况，那么单纯的用add就无法进行计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 计算 1ef000h + 201000h mov ax,001eh mov bx,0f0000h add bx,1000h adc ax,0020h 计算 1ef0001000h + 2010001ef0h mov ax,001eh mov bx,0f000h mov cx,1000h add cx,1ef0h adc bx,1000h adc ax,0020h sbb 指令 带借位减法指令，利用CF记录的借位值\nsbb 操作对象1 操作对象2\n操作对象1 = 操作对象1 - 操作对象2 - CF\nsbb ax,bx (ax) = (ax) - (bx) - CF\n1 2 3 4 5 6 计算003e1000h - 00202000h mov bx,1000h mov ax,003eh sub bx,2000h sbb ax,0020h cmp 指令 比较指令，功能相当于减法，只是不保存结果\ncmp指令格式：cmp 操作对象1 操作对象2\n计算 操作对象1 - 操作对象2 执行cmp指令后，会影响flag寄存器的变化，通过这些变化可以得出比较的结果\n1 2 3 4 5 6 7 8 cmp ax,bx ax = bx 结果为0 zf = 1 ax != bx 结果不为0 zf = 0 ax \u0026lt; bx 产生借位 cf = 1 ax \u0026gt;= bx 不借位 cf = 0 zf可能 ax \u0026gt; bx 不借位不为0 cf = 0 \u0026amp;\u0026amp; zf =0 ax \u0026lt;= bx 可能借位可能为0 cf = 1 或 zf = 1 负数的记录，SF = 1 并不能说明cmp ax,bx中 ax 比 bx 小\n因为数在运算过程中可能会导致溢出，并不能用寄存器来单纯的说明计算结果\n1 2 3 mov ah,08ah mov bh,070h cmp ah,bh 结果sf = 0 (ah) - (bh) = 1AH,在逻辑上运算的结果是(-118) - 112 = -230 ，sf记录实际结果的正负，所以sf = 0\n但不能因此说明在逻辑上的正确结果，而逻辑结果的正负才是cmp指令应该得到的真正结果\n逻辑结果和实际结果产生差别的原因是因为计算之间产生的溢出\n所以想得到逻辑结果需要同时考察SF和OF\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cmp ah,bh 1; sf=1,of=0 of=0 说明没有溢出，逻辑正负=实际正负 sf=1 实际为0，逻辑为负，所以(ah) \u0026lt; (bh) 2; sf=1,of=1 of=1 说明有溢出，逻辑正负!=实际正负 sf=1 实际为负 实际结果为负，而又有溢出，说明是由于溢出导致了实际结果为负，逻辑上的真正结果为正 (ah) \u0026gt; (bh) 3; sf=0;of=1 of=1 说明有溢出，逻辑正负!=实际正负 sf=0 实际为正 实际结果为正，又有溢出，说明溢出导致为正，实际结果为负 (ah) \u0026lt; (bh) 4; sf=0,of=0 of=0 无溢出 sf=0 为正 (ah) \u0026gt;= (bh) 条件转移指令 转移：修改IP\ncmp同时进行两种比较。根据cmp的结果进行的转移的指令也分为两种\n指令 含义 检测相关标志位 je 等于则转移 zf=1 jne 不等于则转移 zf=0 jb 低于则转移 cf=1 jnb 不低于则转移 cf=0 ja 高于则转移 cf=0 \u0026amp;\u0026amp; zf=0 jna 不高于则转移 cf = 1 | zf =1 e = equal b = below a = above n = not\nje的相等且转移的含义来源于与cmp指令的配合使用，实际上检测的是CF是否等于1，如果不与cmp配合使用就有可能不表示相等\nDF标志和串传送指令 方向标志位，串处理指令，控制每次操作后si，di的增减\ndf = 0 每次操作后si，di递增\ndf = 1 每次操作后si，di递减\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 movsb ((es) * 16 + (di)) = ((ds) * 16 + (si)) if df = 0 (si) = (si) + 1 (di) = (di) + 1 if df = 1 (si) = (si) - 1 (di) = (di) - 1 将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df的值，将si或di递减 当然也可以传送一个字 movsw 将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df的值，将si和di递增2或递减2 rep 根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或者递减指向后一个或者前一个单元，则rep movsb就可以循环实现(cx)个字符的传送 也可以使用rep movsw 由于df控制着执行指令后si和di的转移方向 所以需要由指令对其进行控制，来控制si和di的转移方向 cld：将标志器df位置0 std：将标志器df位置1 pushf 和 popf pushf 将标志寄存器的值压栈\npopf 从栈中弹出数据送入标志寄存器\ndebug 中flag寄存器的表示 标志 为1 为0 of OV NV sf NG PL zf ZR NZ pf PE PO cf CY NC df DN UP ","date":"2025-12-02T00:00:00Z","image":"http://localhost:1313/p/12-02/bj_hu_254ebcb69a1eb68c.jpg","permalink":"http://localhost:1313/p/12-02/","title":"12-02 标志寄存器"},{"content":"子程序 模块化设计程序处理数据\n需要明确子程序的参数传递和结果返回值的存储\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 子程序设计样例： ;说明: 计算N的3次方 ;参数(bx) = N ;结果：(dx:ax) = N ^ 3 cube: mov ax,bx mul bx mul bx ret 程序设计样例： assume cs:code data segment dw 1,2,3,4,5,6,7,8 dd 0,0,0,0,0,0,0,0 data ends code segment start: mov ax,data mov ds,ax mov si,0 mov di,16 mov cx,8 s: mov bx,[si] call cube mov [di],ax mov [di].2,dx add si,2 add di,4 loop s mov ax,4c00h int 21h cube: mov ax,bx mul bx mul bx ret code ends end start 而如果数据较多的情况，寄存器无法存储庞大的数据\n就可以将字符串的首地址传给子程序，利用循环来解决\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 assume cs:code data segment db conversation\u0026#39; data ends code segment start: mov ax,data mov ds,ax mov si,0 mov cx,12 call capital mov ax,4c00h int 21h capital: and byte ptr [si],11011111b inc si loop capital ret code ends end start 如果主程序使用了循环，子程序中也需要使用循环的时候，对于rcx计数器来说就有多个程序在调用，导致互相的数据调用出现问题，此时可以使用栈来解决数据调用的问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 code segment start: mov ax,data mov ds,ax mov bx,0 mov cx,4 s: mov si,bx call capital add bx,5 loop s mov ax,4c00h int 21h capital: push cx push si change: mov cl,[si] mov ch,0 jcxz ok and byte ptr [si],11011111b inc si jmp short change ok: pop si pop cx ret code ends end start 调整子程序和主程序之间cx的出入栈顺序和调用顺序，使得两个程序之间互不干扰\n","date":"2025-12-01T00:00:00Z","image":"http://localhost:1313/p/12-01/bj_hu_d3401887d10d0a7e.jpg","permalink":"http://localhost:1313/p/12-01/","title":"12-01 子程序"},{"content":"第十章 call和ret ret指令用栈中的数据，修改ip的内容，实现近转移\ncpu执行ret指令时，进行下面的操作\n(ip) = ( (ss)*16 + (sp) )\n(sp) = (sp) + 2\npop ip\nretf指令用栈中的数据，修改cs和ip的内容，实现远转移\n执行retf指令\n1.(ip) = ((ss)*16 + (sp))\n2.(sp) = (sp) + 2\n3.(cs) = ((ss)*16 + (sp))\n4.(sp) = (sp) + 2\npop ip\npop cs\ncall经常与ret配合使用\n1.将当前ip或者cs和ip压入栈\n2.转移（jmp）\ncall指令不能实现短转移，call的原理与jmp相同\ncall 标号:将当前的ip压栈之后转到标号处执行指令\n执行时：\n1.(sp) = (sp) - 2\n((ss)*16 + (sp)) = (ip)\n2.(ip) = (ip) + 16位位移\ncall far ptr 标号\ncs = 标号所在段地址，ip = 标号所在偏移地址\ncall16位寄存器\n(sp) = (sp) -2\n((ss)*16 + (sp)) = ( ip )\n(ip) = (16位寄存器)\ncall word ptr 内存单元地址\npush ip\njmp word ptr\n1 2 3 4 5 6 mov sp,10h mov ax,0123h mov ds:[0],ax call word ptr ds:[0] (ip) = 0123h,(sp) = 0eh call dword ptr 内存单元地址\npush cs\npush ip\njmp dword ptr 内存单元地址\n1 2 3 4 5 6 7 8 mov sp,10h mov ax,0123h mov ds:[0],ax mov word ptr ds:[2],0 call dword ptr ds:[0] (cs) = 0 ,(ip) = 0123h , (sp) = 0CH H16 = cs L16 = ip call 和 ret 的配合使用\ncall 将ip传输到栈中，执行完子程序之后，\n再利用ret接受栈中的ip，然后再返回call的下一个指令位置\nMUL mul命令,汇编语言中的乘法命令\n相乘的两个数，要么都是8位，要么都是16位\n乘数：指令中给出的 reg/mem 被乘数：固定为 AL 或 AX（根据乘数位数决定）\n乘数位数 被乘数 结果存放 示例 8位 AL AX MUL BL : AX = AL × BL 16位 AX DX:AX MUL BX : DX:AX = AX × BX 32位 EAX EDX:EAX MUL ECX : EDX:EAX = EAX × ECX 8位乘数结果存放在AX中\n16位乘数结果存放在DX,AX中，DX存高位，AX存低位\n32位存EDX,EAX\nMUL只处理无符号位乘法，有符号位需要用IMUL来计算\nmul reg\nmul 内存单元 内存单元可以用不同的寻址方式给出\n1 2 3 4 5 6 7 mul byte ptr ds:[0] (ax) - (al) * ((ds)*16 + 0) mul word ptr [bx+Si+8] (ax) = (al)* ((ds)*16 + (bx) + (si) + 8) (dx) = (al)* ((ds)*16 + (bx) + (si) + 8) ","date":"2025-11-30T00:00:00Z","image":"http://localhost:1313/p/11-30/bj_hu_c2c2b1be4f2f92e.jpg","permalink":"http://localhost:1313/p/11-30/","title":"11-30 call和ret"},{"content":"第九章 转移指令 操作符offset，用来取得标号的偏移地址\n1 2 3 4 5 6 7 s:mov ax,bx mov si,offset s mov di,offset s0 mov ax,cs:[si] mov cs:[di],axs0 s0:nop nop 用offset 可以复制标号地址然后使用\n无条件转移\njmp 可以只修改IP，也可以同时修改cs和ip\njmp转移的目的地址，转移的举例（段间，段内，）\njmp short 标号 转到标号处执行指令，实现段内短转移，对ip的修改范围是-128~127，向后移动127或者向前转移128歌字节\n1 2 3 4 5 start:mov ax,0 jmp short s add ax,1 s:inc ax codesg ends 在cpu机器码中，对于jmp short s这段代码没有给机器码的详细描述\ncpu不需要具体的谜底地址就可以实现对ip的修改\n补码进行的计算，计算出地址的偏移再位移\njmp short 标号 为 (ip) = (ip)+ 8位位移\n8位位移=标号出的地址 -jmp后的第一个字节的地址\nshort指明此处的唯一为8位位移\n由编译程序在编译时计算出\n范围为-128~127\njmp near ptr 标号功能为 (ip) = (ip)+ 16位位移\n进行段内近转移\n无条件跳转 jmp far ptr 标号\n实现段间转移，又称为远转移\nCS表示标号所在的段地址\nIP表示标号坐在段中的偏移地址\nfar ptr指明了指令用标号的段地址和便宜地址来修改CS和IP\n1 2 3 4 5 6 start:mov ax,0 mov bx,0 jmp far ptr s db 256 dup (0) s:add ax,1 inc ax jmp 16位寄存器\nip = 16位寄存器\njmp word ptr 内存单元地址（段内转移）\n从内存单元地址处开始存放一个字，转移的目的偏移地址\n1 2 3 mov ax,0123H mov ds:[0],ax jmp word ptr ds:[0] jmp dword ptr 内存单元地址（段内转移）\n内存单元地址处存放着两个字，高地址处的字是转移的目的段地址\n低地址处是转移的目的偏移地址\ncs = 内存单元地址+2\nip = 内存单元地址\n1 2 3 4 5 6 7 8 mov ax,0123h mov ds:[0],ax mov word ptr ds:[2],0 jmp dword ptr ds:[0] cs = 0 ip = 0123h cs:ip = 0000:0123 有条件跳转 jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移\n在对应的机器码中包含转移的位移，而不是目的地址\njcxz 标号\n如果（cx）=0，则转移到标号处执行\n(ip) = (ip) + 8位位移\ncx != 0 时什么也不做\n==约等于 if((cx)==0) jmp short 标号==\nloop\nif( (cx) != 0 ) jmp short 标号\n","date":"2025-11-29T00:00:00Z","image":"http://localhost:1313/p/11-29/bj_hu_f752dcb93cc03e36.jpg","permalink":"http://localhost:1313/p/11-29/","title":"11-29 转移指令"},{"content":" 1 2 3 4 5 6 7 8 XOR XOR reg1,reg2 逻辑：reg2 = reg2 XOR reg1 标志位更新 S：与最高位相同 Z：全0置1，否则置0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Test 进行逻辑与运算，但不改变操作数 运算结果在设置相关标记位后会被丢弃 作用是利用标志位进行验位跳转 SF = 将结果的最高位赋给SF标志位，例如结果最高位是1，SF就是1 看TEMP是不是0，如果TEMP是0，ZF位置1；如果TEMP不是0，ZF位置0 PF = 将TEMP的低8位，从第0位开始，逐位取同或。也就是第0位与第1位的同或结果，去和第2位同或，结果再去和第3位同或…直到和第7位同或。PF位是奇偶校验位，如果结果低8位中1的个数是偶数，PF=1；否则PF=0 test eax，100b；b后缀意为二进制 jnz ******；如果eax右数第三个位为1，jnz将会跳转 jnz跳转的条件是ZF=0, ZF=0意味着ZF(零标志)没被置位，即逻辑与结果为1 Test的一个非常普遍的用法是用来测试一方寄存器是否为空： test ecx, ecx jz somewhere 如果ecx为零，设置ZF零标志为1，jz跳转。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 movzx (用0填充拓展的高位部分) unsigned char a = 0xff; 00A33E85 C6 45 FB FF mov byte ptr [a],0FFh int b; b = a + 1; 00A33E9B 0F B6 45 FB movzx eax,byte ptr [a] 00A33E9F 83 C0 01 add eax,1 00A33EA2 89 45 EC mov dword ptr [b],eax char a 类型与int b 类型在寄存器中进行计算 对a进行无符号拓展 拓宽字节数 同样的先使用movzx进行无符号扩展 不过与b不同的点在于，将al寄存其中的值赋给了a,也就是0x0100的后两位 00 所以最后a 的值为0 movsx（将sf（对应符号位）填充到拓展的高位部分） char a = 0xff; 00983E85 C6 45 FB FF mov byte ptr [a],0FFh printf(\u0026#34;%d\\n\u0026#34;, a); 00983E89 0F BE 45 FB movsx eax,byte ptr [a] int b; b = a + 1; 00983E9B 0F BE 45 FB movsx eax,byte ptr [a] 00983E9F 83 C0 01 add eax,1 00983EA2 89 45 EC mov dword ptr [b],eax 此处char型变量a中值最初是0xff，此时的符号位为1 使用movsx指令进行有符号扩展后将值存入eax中，eax中保存的值为0xffff eax加1之后，发生溢出，此时eax中保存的值为0x0000 所以最终b中的值为0 1 2 3 4 5 lea 计算有效地址并加载到寄存器中 lea ax,[bx+si] 会计算[bx+si]的和然后加载到ax中，不访问内存内容 leaq 表示的是加载有效地址；而（%rsi，%rdi，4）表示的是将%rsi寄存器中的值，加上4倍的%rdi的值，得到X(A)+4n*i 1 2 3 4 5 6 7 8 9 10 11 12 shl mov bl, 8FH ; BL = 10001111b shi bl, 1 ; CF = 1, BL = 00011110b CF中寄存最后一次移出的数字 最低位用0填充 shr mov al, 0D0H ; aL = 11010000b shr al, 1\t; aL = 01101000b, CF = 0 cf中寄存最后一次移出数字，最高位填充0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 cmp 比较两个无符号数 ZF CF cmp a.b a == b ZF = 1 a \u0026lt; b CF = 1 a \u0026gt; b a \u0026gt;= b CF == ZF == 0 CF == 0 ZF == 1 比较的是两个有符号数，则符号标志位、零标志位和溢出标志位表示的两个操作数之间的关系 a \u0026lt; b SF != OF a \u0026gt; b SF == OF a == b ZF = 1 如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。 如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 跳转指令 基于无符号数比较的跳转 助记符\t说明 JB\t小于跳转 JNB\t不小于跳转 JNBE\t不小于或等于跳转 JA\t大于跳转 JNA\t不大于跳转 JNAE\t不大于或等于跳转 基于相等性的跳转 助记符\t说明 JE\t相等跳转 JNE\t不相等跳转 JCXZ\tCX = 0 跳转 JECXZ\tECX = 0 跳转 JRCXZ\tRCX = 0 跳转（64模式） 基于有符号数比较的跳转 助记符\t说明 JG\t大于跳转 JL\t小于跳转 JNLE\t不小于或等于跳转 JNGE\t不大于活等于跳转 JGE\t大于或等于跳转 JLE\t小于或等于跳转 JNL\t不小于跳转 JNG\t不大于跳转 基于进位和零标志位的跳转 助记符\t说明 JC\t进位跳转（进位标志位置1） JNC\t无进位跳转（进位标志位清零） JZ\t为零跳转（零标志位置1） JNZ\t非零跳转（零标志位清零） 1 2 3 4 5 6 7 检测条件\t无符号数跳转\t有符号数跳转\t同义指令\t检查的标志位 A == B\tJE\tJE\tJZ\tZF = 1 A != B\tJNE\tJNE\tJNZ\tZF = 0 A \u0026lt; B\tJB\tJL\tJNAE, JNGE\tCF = 1 (无符号)SF != OF (有符号) A \u0026gt;= B\tJAE\tJGE\tJNB, JNL\tCF = 0 (无符号)SF == OF (有符号) A \u0026gt; B\tJA\tJG\tJNBE, JNLE\tCF=0 且 ZF=0 (无符号)ZF=0 且 SF==OF (有符号) A \u0026lt;= B\tJBE\tJLE\tJNA, JNG\tCF=1 或 ZF=1 (无符号)ZF=1 或 SF!=OF (有符号) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 逻辑指令 AND DST,SRC OR dst，src XOR dst，src NOT orc 指令支持的寻址方式：除立即数寻址方式以外的其余寻址方式 指令支持的寻址方式：两个操作数不能同时为存储器寻址。即为除源操作数为立即数的情况外，原操作数和目的操作数必须有一个寄存器寻址方式。 令执行后CF 和OF 置零，AF无定义。 SF=1 指令执行后的结果为负数(符号位为1) SF=0 指令执行后的结果为正数(符号位为0) ZF=1 指令执行后的结果为零 ZF=0 指令执行后的结果不为零 PF=1 结果操作数中1的个数为偶数时置1 PF=0 结果操作数中1的个数为奇数时置0 1 2 3 4 5 6 7 CWD: AX符号位拓展到DX CDQ: EAX符号位拓展到EDX CQO: RAX符号位拓展到RDX CBW: AL符号位拓展到DX CWDE: AX符号位拓展到EAX CDQE: EAX符号位拓展到RAX ","date":"2025-11-28T00:00:00Z","image":"http://localhost:1313/p/11-28/bj_hu_19503a3f19982928.jpg","permalink":"http://localhost:1313/p/11-28/","title":"11-28 指令"},{"content":"实验七-寻址方式在结构化数据访问中的应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 assume cs:codesg data segment db \u0026#39;1975\u0026#39;,\u0026#39;1976\u0026#39;,\u0026#39;1977\u0026#39;,\u0026#39;1978\u0026#39;,\u0026#39;1979\u0026#39;,\u0026#39;1980\u0026#39;,\u0026#39;1981\u0026#39;,\u0026#39;1982\u0026#39;,\u0026#39;1983\u0026#39; db \u0026#39;1984\u0026#39;,\u0026#39;1985\u0026#39;,\u0026#39;1986\u0026#39;,\u0026#39;1987\u0026#39;,\u0026#39;1988\u0026#39;,\u0026#39;1989\u0026#39;,\u0026#39;1990\u0026#39;,\u0026#39;1991\u0026#39;,\u0026#39;1992\u0026#39; db \u0026#39;1993\u0026#39;,\u0026#39;1994\u0026#39;,\u0026#39;1995\u0026#39; ; dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ; dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,11430,15257,17800 ; data ends table segment db 21 dup (\u0026#39;year summ ne ?? \u0026#39;) table ends codesg segment start: mov ax,data mov ds,ax mov si,0 mov bx,00d0h mov cx,21 yearc: mov ax,[si] mov [bx],ax add si,4 add bx,0010h loop yearc mov si,2 mov bx,00d2h mov cx,21 yearc1: mov ax,[si] mov [bx],ax add si,4 add bx,0010h loop yearc1 mov si,0054h mov bx,00d5h mov cx,21 income: mov ax,[si] mov [bx],ax add si,4 add bx,0010h loop income mov si,0056h mov bx,00d7h mov cx,21 income1: mov ax,[si] mov [bx],ax add si,4 add bx,0010h loop income1 mov si,00a8h mov bx,00dah mov cx,21 people: mov ax,[si] mov [bx],ax add si,2 add bx,0010h loop people mov si,0054h mov di,00ddh mov bp,00a8h mov bx,ds:[bp] mov cx,21 average: mov ax,[si] mov dx,[si+2] div bx mov [di],ax add si,4 add bp,2 mov bx,ds:[bp] add di,0010h loop average mov ax,4c00h int 21h codesg ends end start 用了5个循环分别解决数据替换问题\n问题：嵌套循环的使用，各种寻址方式结合，地址和数据之间传输的区别\n1 2 3 4 5 6 7 8 9 mov ax,data mov ds,ax mov ax,table mov es,ax mov bx,0 mov si,0 mov di,0 mov cx,21 计算人均收入并存放\n1 2 3 4 5 mov ax,54h[bx] mov dx,56h[bx] div word ptr ds:0a8h[si] mov es:0dh[di],ax ","date":"2025-11-27T00:00:00Z","image":"http://localhost:1313/p/11-27/bj_hu_82958b3d877f35e7.jpg","permalink":"http://localhost:1313/p/11-27/","title":"11-27 实验七-寻址方式在结构化数据访问中的应用"},{"content":"第八章 数据处理的两个基本问题 引言\n定义描述性符号 reg 和 sreg\nreg描述寄存器，sreg描述段寄存器\n8.1 bx,si,di,bp 只有两个，且字母不能有重叠\n8.2 机器指令处理的数据所在位置 绝大部分机器指令都是进行数据处理的指令，处理大致可分为三类\n读取，写入，运算\n在机器指令这一层来讲，并不关心数据的值是多少，而关系指令执行前一刻，它将要处理的数据所在的位置\n指令缓冲器，特殊的寄存器，用来保存要执行的一条指令\n8.3 汇编语言中数据位置的表达 汇编语言种如何表达数据的位置 汇编语言种有三个概念来表达数据的位置 1.立即数 （idata） 2.寄存器 3.段地址（SA）和偏移地址（EA） 显性强制给出段地址\n8.4 寻址方式 当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式\n直接寻址 间接寻址 寄存器相对寻址 8.4 基址变址寻址 相对基址变址寻址 8.5 指令要处理的数据有多长 8086CPu的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是在字操作还是字节操作 通过寄存器指明 在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为word或byte 在没有寄存器参与的内存单元访问指令中，用word ptr 或 byte ptr显性的指明索要访问的内存单元的长度是很必要的 否则，cpu无法得知所要访问的你单元是字单元还是字节单元 其他方法 有些指令默认了访问的是字单元或字节单元\n进行字操作\n8.6 寻址方式的综合应用 从要修改的内容，我们可以逐步的确定修改的方法\n（1）我们要访问的数据是dec公司的记录，所以首先要确定dec公司记录的位置：R=seg:60\n确定了公司记录的位置后，我们下面就进一步确定要访问的内容在记录中的位置\n确定排名字段在记录中的位置：0ch\n修改R+0ch处的数据\n确定收入字段在记录中的位置:0EH\n修改R+0EH处的数据\n确定产品字段在记录中的位置：10h。要修改的产品字段是一个字符串（或一个数组），需要访问字符串中的每一个字符。所以我们要进一步确定每一个字符在字符串中的位置\n确定第一个字符在产品字段中的位置：P=0\n修改R+10H+P处的数：P=P+1\n修改R+10H+P处的数据：P=P+1\n修改R+10H+P处的数据\nc语言描述\n按c语言来写汇编语言\n一般来说，我们用[ bx+idata+si ]的方式来访几条狗提中的数据\n用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组相中的每个元素\n8.7 div指令 div是除法指令（division），使用div做出发的时候\n除数：8位或16位，在寄存器中或内存单元中\n被除数：（默认）放在ax或dx和ax中\n除数 被除数\n8位 16位（AX）\n16位 32位（DX+AX）\n结果：运算 8位 16位\n​ 商 AL AX\n​ 余数 AH DX\n以上结果的16位和8位是看除数决定\ndiv指令格式\ndiv reg div 内存单元 高位放于余数，低位放商\n利用除法指令进行计算 186A1H 1存放在dx中，86A1存放在ax中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 assume cs:codesg codesg segment start: mov dx,1 mov ax,86a1h mov bx,100 div bx mov ax,4c00h int 21h codesg ends end start 编程实现2 8.8 伪指令 dd 前面我们用db和dw定义字节型数据和字型数据 dd是用来定义dword（double word）双字型数据的 问题8.1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 assume cs:codesg,ds:datasg datasg segment dd 100001 dw 100 dw 0 datasg ends codesg segment start: mov ax,datasg mov ds,ax mov ax,ds:[0] mov dx,ds:[2] mov bx,ds:[4] div bx mov ds:[6],ax mov ax,4c00h int 21h codesg ends end start 8.9 dup dup是一个操作符，在汇编语言中同db，dw，dd等一样，也是由编译器识别处理的符号 它是和db，dw，dd等数据定义伪指令配合使用的，用来进行数据的重复 ","date":"2025-11-26T00:00:00Z","image":"http://localhost:1313/p/11-26/bj_hu_8ca7c8daa6a40c6.jpg","permalink":"http://localhost:1313/p/11-26/","title":"11-26 数据处理的两个基本问题"},{"content":"7.7 SI和DI SI和DI是8086CPU中和bx功能相近的寄存器，但是SI和DI不能够分成两个8位寄存器来使用 问题7.2 1 2 3 4 5 6 7 8 s: mov bx,0 mov di,[bx] mov [bx+16],di inc di inc bx mov cx,16 loop s 不能使用内存-内存的方式\n问题7.2分析\n用ds:si指向要赋值的原始字符串，用ds:di来指向复制的目的空间，然后后用一个循环来完成复制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 codesg segment start:mov ax,datasg mov ds,ax mov si,0 mov di,16 mov cx,8 s: mov ax,[si] mov [di],ax add si,2 add di,2 loop s mov ax,4c00h int 21h 利用[bx (si或di) + idata]的方式来简化程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 codesg segment start:mov ax,datasg mov ds,ax mov si,0 mov cx,8 s: mov ax,0[si] mov 16[si],ax add si,2 loop s mov ax,4c00h int 21h codesg ends 更更灵活的方式\n【bx+si】\n【bx+di】\n7.8 [bx+si]和[bx+di] 问题7.4 1 2 3 4 ax = 00BE cx = 0600 ax = 0006 bx = 1000h 课本最后一句: add cx,[bx+di]\ncx = 0606\n7.9 [bx+si+idata] 和 [bx+di+idata] [bx+si+idata] 表示一个内存单元\n偏移地址为：(bx)+(si)+idata\n问题7.5 查看内存\n1 2 3 ax = 0006 cx = 6a00 ax = 226a 7.10 不同的寻址方式的灵活应用 问题7.6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 assume cs:codesg,ds:datasg datasg segment db \u0026#39;1. file \u0026#39; db \u0026#39;2. edit \u0026#39; db \u0026#39;3. search \u0026#39; db \u0026#39;4. view \u0026#39; db \u0026#39;5. options \u0026#39; db \u0026#39;6. help \u0026#39; datasg ends codesg segment start: mov ax,datasg mov ds,ax mov bx,0 mov cx,6 s:mov al,[bx+3] ;注意，单位是字节，所以是al and al,11011111b mov [bx+3],al add bx,16 ;oop s mov ax,4c00h int 21h codesg ends end start 问题7.7 用bx来做变量，定位每行的起始是地址，用si定位要修改的列，用[bx+si]的方式来对目标的单元进行寻址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 assume cs:codesg,ds:datasg datasg segment db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; datasg ends codesg segment start: mov ax,datasg mov ds,ax mov bx,0 ;用bx来定位行 mov cx,4 s0: ;用si来定位列 mov si,0 mov cx,3 s:mov al,[bx+si] and al,11011111b mov [bx+si],al inc si loop s add bx,16 loop s0 mov ax,4c00h int 21h codesg ends end start 问题7.8 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 assume cs:codesg,ds:datasg datasg segment db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; datasg ends codesg segment start: mov ax,datasg mov ds,ax mov bx,0 ;用bx来定位行 mov cx,4 s0: ;用si来定位列 mov dx,cx ;用dx寄存器来临时存放外层cs的值 mov si,0 mov cx,3 s:mov al,[bx+si] and al,11011111b mov [bx+si],al inc si loop s add bx,16 mov cx,dx ;在进行外层循环时调出cx loop s0 mov ax,4c00h int 21h codesg ends end start 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 assume cs:codesg,ds:datasg datasg segment db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; dw 0 ;定义一个字用来保存cx datasg ends codesg segment start: mov ax,datasg mov ds,ax mov bx,0 ;用bx来定位行 mov cx,4 s0: ;用si来定位列 mov ds:[40h],cx ;用dx寄存器来临时存放外层cs的值 mov si,0 mov cx,3 s:mov al,[bx+si] and al,11011111b mov [bx+si],al inc si loop s add bx,16 mov cx,dx ;在进行外层循环时调出cx loop s0 mov ax,4c00h int 21h codesg ends end start 可以用堆栈来进行特殊的操作\n一般来说，在需要暂存数据的时候，我们应该使用栈，栈空间在内存中，采用相关的指令，如:push ，pop等，可对其进行特殊的操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 assume cs:codesg,ds:datasg,ss:stacksg datasg segment db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; dw 0 ;定义一个字用来保存cx datasg ends stacksg segment dw 0,0,0,0,0,0,0 stacksg ends codesg segment start: mov ax,stacksg mov ss,ax mov sp,16 mov ax,datasg mov ds,ax mov bx,0 mov cx,4 s0: push cx ;将外层循环的cx值压栈 mov si,0 mov cx,3 ;cx设置为内层循环的次数 s: mov al,[bx+si] and al,11011111b mov [bx+si],al inc si loop s add bx,16 pop cx ;从栈顶弹出原cx的值，恢复cx loop s0 ;外层循环的loop指令将cx中的计数值减1 mov ax,4c00h int 21h codesg ends end start 问题7.9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 assume cs:codesg,ds:datasg,ss:stacksg stacksg segment dw 0,0,0,0,0,0,0 stacksg ends datasg segment db \u0026#39;1. display \u0026#39; db \u0026#39;2. brows \u0026#39; db \u0026#39;3. replace \u0026#39; db \u0026#39;4. modify \u0026#39; datasg ends codesg segment start: codesg ends end start 用r定位第一行，循环修改r行的3+c再用r定位到下一行，再次循环修改r行的3+c （c大于等于0小于等于3）\n我们用bx来作变量，定位每行的起始地址，用si定位要修改的列，用[bx+3+si]的方式来对目标单元进行寻址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 start: mov ax,stacksg mov ss,ax mov sp,16 mov ax,datasg mov ds,ax mov bx,0 ;定义行 mov cx,4 s0:push cx mov si,0 mov cx,4 s:mov al,[bx+3+si] ;定位到每个要索引的字母 and al,11011111b ;实现变为大写字母 mov [bx+3+si],al inc si ;使它指向下一个字母 loop s add bx,16 pop cx loop s0 mov ax,4c00h int 21h ","date":"2025-11-25T00:00:00Z","image":"http://localhost:1313/p/11-25/bj_hu_5fe548a766353ffc.jpg","permalink":"http://localhost:1313/p/11-25/","title":"11-25 更灵活的定位内存地址的方法下"},{"content":"第七章 更灵活的定位内存地址的方法 引言：主要讲解一些更灵活的定位内存地址的方法和相关的编程方法\nand和or指令 有0取0\nand指令的一点功能 可以将某一位变为0，其他位保持不变\n从右往左，第一个是第0位\n图中and打错，应该为or\n有1取1，两个0取0\nor指令的一点功能 7.2 关于ASCII码 世界上有很多编码方案，有种方案叫做ASCII编码，是在计算机系统中通常被采用的\n简单的说，编码方案，就是一套规则，它约定了用什么样的信息来表示现实对象\n一个文本编辑过程中，就包含这按照ASCII编码规则进行的编码和阶码\n7.3 以字符型时给出的数据 我们可以在汇编程序中，用 \u0026lsquo;\u0026hellip;..\u0026rsquo; 的方法指明数据是以字符的形式给出的，编辑器将其转化为ASCII码 要改变一个字母的大小写，实际上就是改变它所对应的ascii码 7.4 大小写转换的问题 通过对比，我们可以看出来，小写字母的ASCII码值比大写字母的ASCII码值打20H 这样我们可以想到，将小写字母的ASCII码减去20H就能得到大写字母，大写加上20H就能够得到小写 注意：\n对于字符串“BaSic”，应该只对其中的小写字母所对应的ASCII码进行减20H操作，将其转化为大写，而对大写字母不改变\n而对其中的小写字母不进行改变，这里面就存在这一个前提，程序必须要能够判断一个字母是大写还是小写\n判断将用到一些我们目前还未学习到的指令，现在面临的问题是用自己已经学习的指令来解决这个问题，则我们不能对字母的大小写进行任何的判断\n但是现实的题目要求流程必须要能够区别对待大小写字母\n可以看出，就ASCII码的二进制形式来看，除了第五位（位数从0开始计算）外，大写字母和小写字母的其他各位都一样\n大写字母的ASCII码的第五位为0，小写字母的第五位为1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 assume cs:codesg,ds:datasg datasg segment db \u0026#39;BaSic\u0026#39; db \u0026#39;iNfOrMaTiOn\u0026#39; datasg ends codesg segment start:mov ax,datasg mov ds,ax ;设置ds指向datasg段 mov bx,0 ;设置(bx)=0,ds:bx指向\u0026#34;BaSiC\u0026#34;的第一个字母 mov cx,5 ;设置循环次数5，因为\u0026#34;BaSiC\u0026#34; s:mov al,[bx] ,将ASCII码从ds:bx所指向的单元中取出 and al,11011111b ;将al中的ASCII码的第五位置为0，变为大写字母 mov [bx],al ;将转变后的ASCII码写回原单元 inc bx ;(bx)加1，ds:bx指向下一个字母 loop s mov bx,5 ;设置(bx)=5 ds:bx指向\u0026#34;iNfOrMaTiOn\u0026#34;的第一个字母 mov cx,11 ;设置循环次数11，因为\u0026#34;iNfOrMaTiOn\u0026#34;的有11个字母 s0:mov al,[bx] or al,00100000b ;将al中的ASCII码的第五位置变为0，变为小写字母 mov [bx],al inc bx loop s0 mov ax,4c00h int 21h codesg ends end start 7.5 [bx+idata] 在前面，我们可以用[bx]的方式来指明一个内存单元，我们还可以用一种个高位灵活的方式来指明内存单元：\n[bx+idata]表示一个内存单元，他的偏移地址为(bx)+idata （bx中的数值加上idata）\n比如: [10H] 拆成[bx = 8H+2H]\n问题7.1\n1 2 3 4 5 6 mov ax,2000h mov ds,ax mov bx,1000h mov ax,[bx] mov cx,[bx+1] add cx,[bx+2] 7.6 用[bx+idata]的方式进行数组的处理 有了[bx+idata]这种表示内存单元的方式，我们就可以用更高级的结构来看待所要处理的数据\n更简化的操作\n用高级语言来描述\n[bx+idata]的方式为高级语言实现数组提供了便利机制\n","date":"2025-11-24T00:00:00Z","image":"http://localhost:1313/p/11-24/bj_hu_e0634c197571ec8d.jpg","permalink":"http://localhost:1313/p/11-24/","title":"11-24 更灵活的定位内存地址的方法上"},{"content":"第六章 包含多个段的程序 6.1 在代码段中使用数据 1 2 3 4 5 6 7 8 9 10 11 12 13 assume cs:codesg codesg segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h mov bx,0 mov ax,0 mov cx,8 s:add ax,cs:[bx] add bx,2 loop s mov ax,4c00h int 21h codesg ends end \u0026ldquo;dw\u0026quot;是定义字型数据 dw = define word\ndb 定义字节型数据\n字型数据所占的内存空间大小为2个字节\n程序中的指令要对这8个数据进行累加 由于数据在代码段中，程序在运行的时候cs中存放代码段的段地址，所以我们可以从cs中得到它们的段地址 如何让这个程序在编译后可以存系统中直接运行呢 可以在源程序中指明界序的入口所在 给程序指定一个入口，告诉cpu程序从入口开始，可以避免cpu误读指令导致程序错误执行错误代码\n注意程序6.2新加入的内容，我们在程序的第一条指令的前面加上了一个标号start，而这个标号在伪指令end的后面出现 end的作用：end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方 6.2 在代码段中使用栈 大致思路：\n程序运行时，定义的数据存放在cs：0~cs：15单元中，共8个字单元，一次将这8个字单元中的数据入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放\n首先我们需要有一段可以当作栈的内存空间，如前所述，这段空间应该由系统来分配 我们可以在程序中通过定义数据来取得一段空间，然后将这段空间当作栈空间来用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 assume codesg codesg segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h de 0,0,0,0,0,0,0,0 ;用dw定义8个字型数据， ;在程序加载后，将取得8个字的内存空间，存放这8个数据， ;在后面的程序中将这段空间当作栈来使用 start:mov ax,cs mov ss,ax mov sp,32 ;设置栈顶指向cs:32 mov bx,0 mov cx,8 s:push cs:[bx] add bx,2 loop s\t;0~16单元中的8个字型数据依次入栈 mov bx,0 mov cx,8 s0:pop cs:[8] add bx,2 loop s0\t;依次出栈 mov ax,4c00h int 21h codesg ends end start 6.3 将数据，代码，栈放入不同的段 在前面的内容中，我们在程序中用到了数据和栈，我们将数据，栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处实战，何处是代码\n问题：\n把它们放到一个段中使程序显得混乱 前面程序中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题 但如果数据，栈和代码需要的空间超过64kb，就不饿能放在一个段中（一个段的容量不能大于64kb，是我们在学习中所用的8086模式的限制，并不是所有的处理器都这样）\n所以我们应该考虑用多个段来存放数据\n我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 assume cs:code,ds:data,ss:stack data segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h data ends stack segment dw 0,0,0,0,0,0,0,0 stack ends code segment start:mov ax,stack mov ss,ax mov sp,16 ;设置栈顶ss:sp指向stack:16 mov ax,data mov ds,ax ;ds指向data段 mov bx,0 ;ds:bx指向data段中的第一个单元 mov cx,8 s:push [bx] add bx,2 loop s ;以上将data段中的0~16单元中的8个自行数据依次入栈 mov bx,0 mov cx,8 s0:pop [bx] add bx,2 loop s0 mov ax,4c00h int 21h code ends end start 一，我们在源程序中为这个三个段起了具有含义的名称，用来存放数据的段我们将其命名为data，用来存放代码的段我们将其命名为code，用来做栈空间的命名为stack 二，我们源程序中用伪指令 ,\u0026ldquo;assume cs:code,ds:data,ss:stack\u0026quot;将cs，ds，ss分别与code，data，stack段相连 这样做了之后，cpu是否就会将cs指向code，ds指向data，ss指向stack，从而按照我们的意图来处理这些段呢 并不会。 三，若要cpu按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是cpu要执行的内容 我们在源程序的最后用\u0026quot;end start\u0026quot;说明了程序的入口，这个入口将被写入可执行文件的描述信息，可执行文件中的程序被加载入内存后，cpu的cs:ip被设置指向这个入口，从而开始执行程序中的第一条指令\n标号\u0026quot;start\u0026quot;在\u0026quot;code\u0026quot;段中，这样cpu就将code段中的内容当作指令来执行了\n实验五 一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 assume cs:code,ds:data,ss:stack data segment dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h data ends stack segment dw 0,0,0,0,0,0,0,0 stack ends code segment start: mov ax,stack mov ss,ax mov sp,16 mov ax,data mov ds,ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax,4c00h int 21h code ends end start 二 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 assume cs:code,ds:data,ss:stack data segment dw 0123h,0456h data ends stack segment dw 0,0 stack ends code segment start: mov ax,stack mov ss,ax mov sp,16 mov ax,data mov ds,ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax,4c00h int 21h code ends end start 三 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 assume cs:code,ds:data,ss:stack code segment start: mov ax,stack mov ss,ax mov sp,16 mov ax,data mov ds,ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax,4c00h int 21h code ends data segment dw 0123h,0456h data ends stack segment dw 0,0 stack ends end start 四 如果将前面三个代码中结尾的 end start 的 start 去掉，那么哪个代码可以正常运行？\n第三个可以正常运行\n第三个的代码段放在最开始，cpu可以正确的识别并执行\n五 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 assume cs:code a segment db 1,2,3,4,5,6,7,8 a ends b segment db 1,2,3,4,5,6,7,8 b ends c segment db 0,0,0,0,0,0,0,0 c ends code segment start: mov bx,0 mov cx,8 s1: mov ax,a mov ds,ax mov al,[bx] mov ah,0 mov dx,c mov ds,dx mov [bx],al inc bx loop s1 mov bx,0 mov cx,8 s2: mov ax,b mov ds,ax mov al,[bx] mov ah,0 mov dx,c mov ds,dx add [bx],al inc bx loop s2 mov ax,4c00h int 21h code ends end start 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 assume cs:code a segment dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh a ends b segment dw 0,0,0,0,0,0,0 b ends code segment start: mov ax,a mov ds,ax mov ax,cs mov ss,ax mov sp,200 mov ax,b mov es,ax mov bx,0 mov cx,8 s: push [bx] add bx,2 loop s mov bx,0 mov cx,8 s1: pop es:[bx] add bx,2 loop s1 mov ax,4c00h int 21h code ends end start ","date":"2025-11-23T00:00:00Z","image":"http://localhost:1313/p/11-23/bj_hu_3afb7c10068a0be.jpg","permalink":"http://localhost:1313/p/11-23/","title":"11-23 包含多个段的程序"},{"content":"第五章 [BX]和loop指令 5.1 【bx】和内存单元的描述 debug中写命令，与编辑器中写命令不同。\ndebug中写[0]，指的是偏移地址，但是编辑器中写[0]被认为是0，01这样的数据\n我们要完整的描述一个内存单元，需要两种信息：\n内存单元的地址 内存单元的长度（类型） 我们用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，单元的长度（类型）可以由具体指令中的其他操作对象（比如寄存器）指出，如前边的AX,AL\n在汇编源程序中直接使用mov ax,[0] 编译器会把[0]当成0直接传输过去\n可用通用寄存器来间接传递偏移地址单元的数据\nloop是描述循环的指令\n描述性符号”（）“：用括号来表示一个寄存或一个内存单元中的内容 约定符号idata表示常量 在debug中写过类似的指令：mov ax,[0]，表示将ds：0处的数据送入ax中，指令中，在[\u0026hellip;]里用一个常量0表示内存单元的偏移地址，以后我们用idata表示常量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 assume cs:codesg codesg segment fishcc:mov ax,2000h mov ds,ax mov bx,1000h mov ax,[bx] inc bx inc bx mov [bx],ax inc bx inc bx mov [bx],ax inc bx mov [bx],al inc bx mov [bx],al mov ax,4c00h int 21h codesg ends end fishcc inc：加加运算符，bx中内容加1 指令分析：\n[bx]：用寄存器来表示段地址当中的偏移地址\n注意\n（）里的元素可以有三种类型：1.寄存器名，2.段寄存器名，3.内存单元的物理地址（一个20位数据）\n比如：(ax),(ds),(al),(cx),(20000H),((ds)*16+(bx)) 都是正确用法\n(2000:0),((ds):1000h)不是正确的用法\n5.2 loop指令 指令的格式：loop 标号，CPU执行loop指令的时候，要进行两步操作：\n（cx）=（cx）-1； cx与loop紧密相连 判断cx中的值，不为零则转至标号处执行程序，如果为0则向下执行 从上面的描述中，可以看到，cx中的值影响着loop指令的执行结果\n通常，我们用loop指令来实现循环功能，cx中存放循环次数\n编程计算 按照算法 计算大量数据程序的数量非常多，用loop来简化\n与goto类似，设置一个标号，loop跳转到标号，然后执行循环\n每一次循环cx中的数值减1，直到cx数值减为0结束循环执行下一条语句\n程序分析\n（1）标号\n在汇编语言中，标号代表一个的地址，此程序中有一个标号s，它实际上标识了一个地址，这个地址处有一条指令：add ax,ax\n（2）loop s\ndebug编辑默认十六进制\nmasm默认是十进制的\n注意：\n切记，不能以字母开头，需要在前面加上0\n复习指令处理 5.4 debug和汇编编译器masm对指令的不同处理 两种不同的情况处理\n1 2 3 4 5 6 7 debug mov ax,2000 mov ds,ax mov al,[0] mov bl,[l] mov cl,[2] mov dl,[3] 1 2 3 4 5 6 7 8 9 10 11 12 汇编程序 需要通过[bx]来实现 如果想要直接通过[2]来实现 需要加上段地址 debug mov ax,2000 mov ds,ax mov al,ds:[0] mov bl,ds:[l] mov cl,ds:[2] mov dl,ds:[3] 5.5 loop和[bx]的联合应用 问题：\n类型的匹配和结果的不超界\n目前的方法：用一个16位的寄存器来作为中介\n我们将内存单元的中的8位数据复制到一个16位寄存器ax中，再将ax中的数据加到dx上，从而使两个运算对象的类型匹配并且结果不会超界\n不使用循环，代码重复啰嗦\n1 2 3 mov al,ds:[0] mov ah,0 mov dx,ax 循环体内容：\n最终程序的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 assume cs:code code segment mov ax,0ffffh mov ds,ax mov bx,0 mov dx,0 mov cx,12 s: mov al,[bx] mov ah,0 add dx,ax inc bx loop s mov ax,4c00h int 21h code ends end 5.5 loop和【bx】的联合应用 在实际编程中，经常会遇到，用同一种方法处理地址连续的内存单元中的数据的问题\n我们需要用循环来解决这类问题，同时我们必须能够在每次循环的时候按照同一种方法来改变要访问的内存单元的地址\n这时我们不用能常量来给出内存单元的地址，而应用变量\n”mov al,[bx]“中的bx就可以看作一个代表内存单元地址的变量，我们可以不写新的指令，仅通过改变bx中的数值，改变指令访问的内存单元\n5.6 段前缀 指令”mov ax,[bx]“中，内存单元的偏移地址由bx给出，而段地址默认在ds中\n我们可以在访问内存单元的指令中显示地给出内存单元的段地址所在的段寄存器\n如果前面什么都没写的话默认是放在ds中的\n5.7 一段安全的空间 代码违规，动用了其他程序或操作系统的内存占用空间\n总结一下\n（1）我们需要直接向一段内存中写入内吨\n（2）这段内存空间不应该存放系统或其他程序的数据或代码，否则写入操作很可能引发错误\n（3）dos方式下，一般情况，0：200~0：2FF空间中没有系统或其他程序的数据或代码；\n（4）以后，我们需要直接向一段内存中写入内容时，就是用0：200~0：2FF这段空间\n5.8 段前缀的使用 我们考虑一个问题 将内存ffff:0ffff:b段单元中的数据拷贝到0：2000：20b单元中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 assume cs:code code srgment mov bx,0; (bx)=0,偏于i从0开始 mov cx,12; （cx）=12，循环12次 s: mov ax,0ffffh mov ds,ax； （ds）0ffffh mov dl,[bx]； （dl）= （（ds）*16+bx），将ffff：bx中的数据送入dl mov ax,0020h mov ds,ax； （ds）=0020h mov [bx],dl； （（ds）*16+（bx）） = （dl），将dl的数据送入0020Lbx inc bx\t；（bx）=（bx）+1 loop s mov ax,4c99h int 21h code ends end 改进的程序中，使用es存放目标空间0020：00020：b的段地址，用ds存放源空间ffff：0ffff：b的段地址\n在访问内存单元的指令”mov es:[bx],al“中，显式的用段前缀”es：“给出单元的段地址，这样就不必再循环中重复设置ds\n","date":"2025-11-22T00:00:00Z","image":"http://localhost:1313/p/11-22/bj_hu_8737095785923e3d.jpg","permalink":"http://localhost:1313/p/11-22/","title":"11-22 BX和loop"},{"content":"4.2 源程序 标号 有个标号只带了一个地址 codesg：放在segment的前面，作为一个段的名称，这个段的名称最终将被编译，连接程序处理为一个段的段地址 程序返回 我们的程序最先以汇编指令的形式存在源程序中，经过编译，连接后转变为机器码，存储在可执行文件中，那么，如何得到运行呢 dos中的程序运行\n一个程序结束后，将cpu的控制权交还给使它得以运行的程序，我们成这个过程为：程序返回 段结束，程序结束，程序返回 语法错误和逻辑错误 关于编译和链接 编译连和接的作用是什么呢\n链接作用有以下几个\n当源程序很大时，可以将他分为多个源程序文件夹编译，每个源程序编译成为目标文件后，再用链接程序将他们链接到一起，生成一个可执行文件 程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件链接到一起，生成一个可执行文件、 一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，链接程序将这些内容处理为最终可执行信息 所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用链接程序对目标文件进行处理，生成可执行文件\n对于连接的过程，可执行文件是我们要得到的最终结果\n4.8 可执行文件中的程序装入内存并运行的原理 在dos中，可执行文件中的程序P1若要运行，必须有一个正在u运行的程序P2，将P1从可执行文件中加载入内存，将CPU的控制权交给他，P1才能得以运行\n当P1运行完毕后，应该将CPU的控制权交还给使它运行的p1\n问题4.1\n操作系统的外壳 操作系统给是由多个功能模块组成的庞大，复杂的软件系统。任何通用的操作系统，都需要提供一个称为shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统工作\ndos中有应该程序command.com ，这个程序在dos中称为命令解释器，也就是dos系统的shell\n4.8 可执行文件中的程序装入内存并运行的愿意 4.9 程序执行过程的跟踪 psp，用来和程序通信\n注意：有一部称为重定位的工作我们在上面没有讲解，因为这个问题和操作系统的关系较大，不做讨论\n总结：\nds：1000：0 程序 1010：0\n如果不使用p命令执行int 21，会导致ip指向乱跳，非正常结束\n使用q命令退出debug，将返回到command中，因为debug是由command加载运行的\n我们在dos中用“debug 1.exe”运行debug对1.exe进行跟踪时，程序加载的顺序时：command加载debug，debug加载1.exe\n返回的顺序是：从1.exe中的程序返回到debug，从debug返回到command\n","date":"2025-11-21T00:00:00Z","image":"http://localhost:1313/p/11-21/bj_hu_3a4f66ad24456ffb.jpg","permalink":"http://localhost:1313/p/11-21/","title":"11-21 源程序"},{"content":"第四章 第一个程序 4.1 一个源程序从写出到执行的过程 一个汇编语言程序从写出到最终执行的简要过程：\n编写 \u0026ndash;\u0026gt; 编译和连接 \u0026ndash;\u0026gt; 执行\n文本编译器，记事本，notepad++\n使用汇编语言编译恒旭（MASE.EXE）对源程序文件中的源程序进行编译，产生目标文件，obj\n在用连接程序（LINK.EXE）对目标文件进行连接，生成可在操作系统中直接运行的可执行文件\n可执行文件中包含两部分内容：\n程序，（从原程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据） 相关的描述信息（比如：程序有多大，要占用多少内存空间） 操作系统中执行可执行文件中的程序\n操作系统依照可执行文件中的秒速信息，将可执行文件中的机器码和数据加载入内存，，并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令），然后由cpu执行程序 4.2 源程序 汇编指令：\n有对应的机器码的指令，可以被编译为机器码的指令，最终可以被cpu执行、\n伪指令：\n没有对应机器码的指令，最终不被cpu所执行\n由编译起来执行的指令，编译器根据伪指令来进行相关的编译工作\n定义一个段 XXX segment 定义一个段\nXXX ends\nsegment和ends是一对成对使用的伪指令，只是在写可被编译器编译的汇编程序时，必须要用的到一对伪指令\n功能是用来定义一个段，segment表示段的开始，ends表示一个段的结束\n一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或者当作栈空间来使用\n一个由意义的汇编程序中至少要有一个段，这个段用来存放代码\nend是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对原程序的编译\n如果程序写完了，也要在结尾处加上伪指令end，否则，编译器在编译程序时，无法知道程序在何处结束\n切记：不要搞混了end和ends\n寄存器与段的关联假设 assume：含义为”假设“\n它假设某一段寄存器和程序中的某一个用segment\u0026hellip;ends定义的段相关联\n通过assume说明这种关联，在需要的情况下，编译程序可将段寄存器和某一个具体的段相联系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 assume cs:codesg codesg segment start:\tmov ax,0123h mov bx,0456h add ax,bx add ax,ax mov ax,4c00h int 21h codesg ends end assume 假设一个代码段，名字为codesg codesg semgent 原程序中的”程序“ 汇编源程序：\n​\t伪指令（编译器处理）\n​\t汇编指令（编译为机器码）\n程序：源程序中最终由计算机执行，处理的指令或者数据\n注意\n我们可以将源程序文件中的所有内容成为源程序，将源程序中最终有由计算机执行处理的指令或数据，成为程序\n沉痼最新啊一汇编指令的形式存在源程序中，经编译，连接后转变为机器码，存储在可执行文件中\n","date":"2025-11-20T00:00:00Z","image":"http://localhost:1313/p/11-20/bj_hu_fbf71ee20d6721ee.jpg","permalink":"http://localhost:1313/p/11-20/","title":"11-20 第一个程序"},{"content":"3.6 栈 栈是一种具有特殊访问方式的存储空间，特殊性在于：最后进入这个空间的数据，最先出去\n栈有两个基本的操作：入栈和出栈 入栈：将一个新的元素放到栈顶 出栈：从栈顶取出一个元素 栈顶的元素总是最先入栈，需要出栈时，有最先被从栈中取出 对程序而言，需要有一个标记一直指示着最顶上的数据，每次这个数据被pop，然后标记+2从低地址到高地址，底部是不需要标记的\n3.7 CPU提供的栈机制 8086cpu提供入栈和出栈的指令（最基本）\n​\tPUSH （入栈）\n​\tPOP （出栈）\npush ax：将寄存器ax中的数据送入栈中\npop ax：从栈顶取出数据送入ax\n8086cpu的入栈和出栈操作都是以字为单位进行的 （两个字节）\n指令执行 两个疑问： 1.cpu如何知道一段内存空间被当作栈使用 2.执行push和pop的时候，如何知道哪个单元是栈顶单元 push ax SP = SP -2; 将ax中的内容送入SS：SP指向的内存单元处，SS：SP此时指向新栈顶 问题： 如果我们将1000H~000FH这段空间当作栈，初始状态栈式空的，此时，SS= 1000H，SP=？\n栈空，ss：sp指向最高地址单元的下一个单元\n如果栈的大小已经到了FFFF最大的时候，那么这时的+2将会导致溢出，不过由于栈为空，所以sp = 0\npop的执行过程 pop ax 将SS：SP指向的内存单元处的数据送入ax中 SP = SP+2，SS：SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶 注意：\n栈中已经存放的数据不会被删除，只能被覆盖\n3.8 栈顶超界的问题 ss和sp只记录了栈顶的位置，依靠SS和SP可以保证在入栈和出栈时找到栈顶，可是如何能够保证在入栈，出栈时，栈顶不会超出栈空间？\n栈溢出\n栈越界\n栈顶超界是危险的，我们将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据，代码，这些数据，代码可能是我们自己的程序中的，也可能是别的程序中的。\n3.9 push,pop指令 push和pop指令是可以在寄存器和内存之间传送数据的\n栈与内存\n栈空间是内存空间的一部分，它只是一段可以以一种特殊方式进行访问的内存空间\npush和pop也可以用于\n内存单元，段寄存器，寄存器，的入栈与出栈\n问题3.7 1 2 3 4 ss 1000 push ax,[0] push bx,[2] push ds,[4] 问题3.8 1 2 3 4 5 6 7 8 9 10 11 12 13 mov ax,1000h mov ss,ax mov sp,0010 mov ax,001A mov bx,001B push ax push bx mov ax,0 mov bx,0 pop bx pop ax 用栈来暂存以后需要恢复的寄存器中的内容是，出栈的顺序要和入栈的顺序相反，因为最后入栈的寄存器的内容在栈顶，所以在恢复时，要最先出栈\npush和pop即是一种内存传送指令，可以在寄存器和内存之间传输数据，与mov指令不同的是，push和pop指令访问的内存单元的地址是由SS:SP指出的，而且push和pop还会在执行指令的过程中，更改SS:IP的内容\n3.10 栈段 问题3.11 分析\n一个cpu能容纳最大的是64kb的栈\n总结 我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元，这完全是我们自己的安排\n我们可以用一个段存放数据，将它定义为“数据段”\n我们可以用一个段存放代码，将它定义为“代码段”\n用段来存放栈，即为栈段\n对于代码段\n段地址放在cs中，第一台哦指令的偏移地址放在ip中，这样cpu就将执行我们定义的代码段中的指令\n对于栈段\n将它的地址放在ss中，将栈顶单元的偏移地址放在SP中，这样cpu在需要进行栈操作的时候，比如执行push，pop指令等，就将我们定义的站栈当作栈空间来用\n代码段分析\n这段代码既是代码段，又是栈段，又是数据段\n一段内存，可以即是代码的存储空间，也可以是数据的存储空间，还可以是栈空间，也可以什么都不是\n关键在于cpu寄存器的设置\n","date":"2025-11-19T00:00:00Z","image":"http://localhost:1313/p/11-19/bj_hu_45f96aa88b4e9bcb.jpg","permalink":"http://localhost:1313/p/11-19/","title":"11-19 寄存器下"},{"content":"第三章：寄存器的内存访问 3.1 内存中字的存储 在0地址开始地址，低位存放低地址，高位存放高地址\n0地址单元中存放的字节型数据 20\n0地址字单元中存放的字型数据是多少 4e20 20000\n2地址字单元中存放的字节型数据是多少 12\n2地址单元中存放的字型数据是多少 0012\n1地址字单元中存放的自行数据是多少 124EH\n3.2 DS和【address】 cpu要读取一个内存单元的时候，必须先给出这个内存单元的地址 在8086pc中，内存地址由段地址和偏移地址组成 8086cpu中有一个ds寄存器，通常用来存放要访问的 数据的段地址 mov al,[0]\nmov指令可以完成的两种传送功能\n（1）：将数据直接送入从寄存器\n（2）：将一个寄存器中的内容送入另一个寄存器中\n除此之外，mov 指令还可以将一个内存单元中的内容送入一个寄存器\n【】中的内容为偏移地址，mov al,ds:[0]\nds 存放段地址，【】存放偏移，上述三条指令，合起来就是将10000H单元中的数据读到al中\n不能直接将数据送入ds中，ds是一个段寄存器，需要通过通用寄存器来导入ds\n1 2 3 4 mov bl,al mov ax,1000h mov ds,ax mov bl,[0] ---\u0026gt; mov [0],bl 3.3 字的传送 8086cpu是16位结构，由16根数据线，所以，可以一次性传送16位的数据，也就是一次性传送一个字\nmov的数据，如【0】和ax或者和al，必须一一对应，ax是16位，那么从偏移地址传送的数据默认就是16位的\n1 2 3 4 5 6 7 8 9 10 11 12 ax：23H bx：22H cx：11H bx：33H cx：33H ax:1123H bx:6622H cx:2211H bx:8833H cx:8833H 注意计算的时候，写入寄存器的位数区别，是否当作字节或者字来看，是否需要写入高位或者不写入高位 1 2 3 4 5 6 7 8 9 10 11 12 ax：2C34 10000H：2C34 bx：2c34 bx：2c12 10002H:2c12 10000H：34 10001H：2c bx:2c34 bx:1b12 10003H:12 10004H:1b 3.4 mov，add，sub指令 1 2 3 4 5 mov ax,1000 mov bx,ax mov ax,[0] mov [0],ax mov ds,ax 1 2 3 4 5 mov 段寄存器，寄存器 mov 寄存器，段寄存器 都可以 段寄存器不能参与计算\n3.5 数据段 如何访问数据段中的数据：\n将一段内存当作数据段，是我们在编程时的一种安排，我们可以在具体操作的时候，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元\n数据段的累加\n写几条指令，累加数据段中的前3个自行的数据\n3.1-3.5小结 （1）：字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中\n（2）：用mov指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在ds寄存器中\n（3）：【address】表示一个偏移地址为address的内存单元\nmov ax,1000:[0] 会报错\n（4）：在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器，第地质单元和低8位寄存器相对应\n（5）：mov，add，sub时具有两个操作对象的指令。jmp是具有一个操作对象的指令\n（6）：可以根据自己的推测，在debug中实验指令的新格式\nc语言练习\n题目：学生成绩管理系统\n要求： 定义学生结构体（学号、姓名、3门成绩） 动态创建学生数组（数量键盘输入） 计算每个学生平均分和总分 按总分排序（用指针操作） 将结果保存到文件 数据结构： 1 2 3 4 5 6 7 typedef struct { int id; char name[20]; float scores[3]; float total; float average; } Student; 需要实现的函数： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 1. 输入学生信息 void input_students(Student *stu, int n); // 2. 计算总分和平均分 void calculate_scores(Student *stu, int n); // 3. 按总分排序（用指针交换） void sort_students(Student *stu, int n); // 4. 打印学生信息 void print_students(Student *stu, int n); // 5. 保存到文件 void save_to_file(Student *stu, int n, const char *filename); 示例输入： text\n1 2 3 4 3 1001 Alice 85 90 78 1002 Bob 92 88 95 1003 Cindy 76 85 80 示例输出： text\n1 2 3 4 学号 姓名 语文 数学 英语 总分 平均分 1003 Cindy 76 85 80 241 80.33 1001 Alice 85 90 78 253 84.33 1002 Bob 92 88 95 275 91.67 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 代码： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct Student { int id; char name[20]; float scores[3]; float total; float average; } Student; void input_student(Student* stu, int n) { for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d %s %f %f %f\u0026#34;, \u0026amp;stu[i].id, stu[i].name, \u0026amp;stu[i].scores[0], \u0026amp;stu[i].scores[1], \u0026amp;stu[i].scores[2]); } } void calculate_total_average(Student* stu, int n) { for (int i = 0; i \u0026lt; n; i++) { stu[i].total = 0; for (int j = 0; j \u0026lt; 3; j++) { stu[i].total += stu[i].scores[j]; } stu[i].average = stu[i].total / 3; } } void sort_student(Student* stu, int n) { for (int i = 0; i \u0026lt; n - 1; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (stu[i].total \u0026lt; stu[j].total) { Student temp = stu[i]; stu[i] = stu[j]; stu[j] = temp; } } } } void printf_student(Student* stu, int n) { printf(\u0026#34;学号\\t姓名\\t语文\\t数学\\t英语\\t总分\\t平均分\\n\u0026#34;); for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d\\t%s\\t%.1f\\t%.1f\\t%.1f\\t%.1f\\t%.2f\\n\u0026#34;, stu[i].id, stu[i].name, stu[i].scores[0], stu[i].scores[1], stu[i].scores[2], stu[i].total, stu[i].average); } } void save_file(Student* stu, int n) { char* filename = \u0026#34;d:\\\\11\\\\name.bin\u0026#34;; FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filename, \u0026#34;wb\u0026#34;); if (err != 0 || fp == NULL) { return; } fwrite(stu, sizeof(Student), n, fp); fclose(fp); } int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); Student* stu = (Student*)malloc(n * sizeof(Student)); input_student(stu, n); calculate_total_average(stu, n); sort_student(stu, n); printf_student(stu, n); save_file(stu, n); free(stu); return 0; } 注意事项：\n数组初始化，未初始化的数组可能会导致访问到垃圾值\n指针对其内容的直接更改\n","date":"2025-11-18T00:00:00Z","image":"http://localhost:1313/p/11-18/bj_hu_11faea0ac069328d.jpg","permalink":"http://localhost:1313/p/11-18/","title":"11-18 寄存器上"},{"content":"第二章 寄存器（cpu工作原理） CPU，寄存器 一个典型的CPU由运算器，控制器，寄存器等器件组成，器件靠内部总线相连\n区别：\n内部总线实现CPU内部各个器件之间的联系\n外部总线实现CPU和主板上其他器件的联系\n2.1 通用寄存器 8086CPU由14个寄存器，名称为AX,BZ,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW\n8086CPU所有的寄存器都是16位的，可以存放两个字节\nAX,BX,CX,DX 通常用来存放一般性数据被称之为通用寄存器\nAX作例子\n![2.1 jicunqi8weio](C:/blog/my-blog/content/post/11-2025/11.16.2025/2.1 jicunqi8weio.png)\n2.2 字在寄存器中的存储 字 word = 2B 8086 8位升级到16位， 把一次性读取16位的内存单元称之为字\n2.3 几条汇编指令 示例：\n8226H+8226H 进位溢出 1044C 答案是044C\n这里的1被放到了进制位中去（请听下回分解）\n0000H 其中，AH代表了ax的高位，AL代表了ax的低位\nadd ah，bl 就是对ax的高位和bx的低位进行运算\n答案不等于0158H，AH和AL是两个分开的存储，溢出了不会互相进入，会抛到另一个地方\n如果是ax则为0158H\n监测点2.1 另附 add al,6\tax=\n​\tadd al.al\tax=\n​\tmov ax,cx\tax=\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 AX = F4A3H AX = 31A3H AX = 3123H AX = 6246H BX = 826CH CX = 6246H AX = 826CH AX = 04D8H AX = 0482H AX = 6C82H AX = D882H AX = D888H AX = D810H AX = 6246H （2）只能使用目前削过的汇编指令，最多能够使用四条指令，编程计算2的4次方\nadd ax,0008H\nadd ax,0008H\n1 2 3 4 add ax,2 add ax,ax add ax,ax add ax,ax 2.4 物理地址 cpu访问内存单元是要给出内存单元的地址，所有的内存单元构成的存储空间是一个一位的线性空间。\n我们将这个唯一的地址成为物理地址。\n线性空间里的每一个存储单元都有唯一的地址，这个唯一的地址称为物理地址\n2.5 16位结构的cpu 1.运算器一次最多可以处理16位的数据 2.寄存器的最大宽度为16位 3.寄存器和运算器之间的通路是16位的 2.6 8086cpu给出物理地址的方法 8086有20位地址总线，可传送20位地址，寻址能力为1M （外部） 8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64k 8086cpu采取一种在内部用两个16位地址合成的方法来形成一个20位的物理地址\n![2.68086cpuluojijiegou ](2.68086cpuluojijiegou .png)\n其他部件：计算器之类的\n地址加法器工作原理 物理地址=段地址*16+偏移地址\n2.7 短地址*16+偏移地址=物理地址的本质含义 偏移地址比喻1\n偏移地址比喻2\n2.8 段的概念 在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用 段地址*16 定位段的起始地址（基础地址），用偏移地址定位段中的内存单元\n注意：\n短地址*16必然时 16的倍数，所以一个段的起始地址也一定是16的倍数 偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度最大为64k 内存单元地址小结 cpu访问内存单元是，必须向内存提供内存单元的物理地址 8086cpu在内部用短地址和偏移地址移位相加的方式形成最终的物理地址 思考：\n1.\n同一个物理地址，可以由多个段地址加偏移地址来得到\n2.\n小结\n检测点2.2 （1）：寻址范围：0001H - 10000H\n（2）：最小为：10001H 最大为：20000H\n给定地址需要乘以16，也就是左移一位\n寻址范围应该是 0010H\u0026ndash;1000FH\n最小 1001H 最大 2000H\n2.9 段寄存器 已知cpu的物理地址需要短地址加偏移地址来合成\n段地址需要有地方来存储，就是段寄存器\ncs：代码地址\nds：数据地址\nss：堆上的地址\nes：什么都有的地址\n2.10 cs和ip 8086pc读取和执行指令相关部件 B8 代表 mov ax\n0123H 从上到下，低位到高位，低位优先存储\nip+3，ip+2，索引到下一条指令\ncpu工作过程简要描述 想要绕过杀毒软件，就可以将木马植入FFFF0H单元中，指向病毒程序，屏蔽杀毒软件\n![2.10 ](2.10 .png)\n2.11 修改cs，ip的指令 ![2.11 xiugaicsipzhiling](2.11 xiugaicsipzhiling.png)\n如何修改AX中的值 不能通过mov来改变cs·ip的值\n![2.11 zhuanyizhiling](2.11 zhuanyizhiling.png)\n仅修改ip ![2.11 jinxiugai ip](2.11 jinxiugai ip.png)\ncpu运行的流程 ![2.11 couyunxingliucheng](2.11 couyunxingliucheng.png)\n2.12 代码段 执行代码段的指令 2.9-2.12 小结 1.段地址在8086CPU的寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU由4个段寄存器，其中CS用来存放指令的短地址。\n2.CS存放指令的段地址，ip存放指令的偏移地址。\n8086中，任意时刻，CPU将CS：IP指向的内容当作指令执行\n3.8086CPU的工作过程：\n从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器 IP指向下一条指令（IP有一个递加器，根据指令的长度加加，跳转到下一条指令） 执行指令 4.8086CPU提供转移指令修改CS·IP的内容\n检测点2.3 ![jiancedian 2.3](jiancedian 2.3.png)\n3次，\n第一次读取 mov ax,bx，执行完成后，ip+3，到sub指令首地址开始读取\nsub ax,ax，完成后ip+3\njmp ax 完成后 执行jmp指令到0000H的位置 ip=ax\n根据cs：ip的工作过程推理，考虑到读取街道ip自动递增，ip修改的次数是四次，而只考虑ip修改指令的执行，那么ip只被修改了三次\n1 2 3 4 读取 mov ax, bx 后，IP自动增加。 读取 sub ax, ax 后，IP自动增加。 读取 jmp ax 后，IP自动增加。 执行 jmp ax 时，IP被AX的值（0）覆盖。 实验一 ","date":"2025-11-17T00:00:00Z","image":"http://localhost:1313/p/11-17/bj_hu_9b606b99c944dff1.jpg","permalink":"http://localhost:1313/p/11-17/","title":"11-17 寄存器"},{"content":"1.1 机器语言 引言\n课程的目的主要是研究如何让硬件更有效率的工作\n1.2 汇编语言的产生 寄存器：cpu中可以储存数据的期间，一个cpu可以有多个寄存器\n寄存器的代号表示有不同作用的寄存器\n1.3 汇编语言的组成 汇编指令 （可以直接翻译成机器码） 伪指令 （伪指令，用编译器执行） 其他符号 （由编译器识别） 核心是汇编指令，它决定了汇编语言的特性\n1.4 存储器 cpu是计算机的核心部件，它控制整个计算机的运作并进行运算，想cpu工作，必须提供指令和数据\n指令和数据在存储器中存放，也就是内存\n内存是其中一种存储器\npc机中内存作用仅次于cpu，离开了内存，cpu无法工作\n磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被cpu使用\n1.5 指令和数据 指令和数据是应用上的概念，在内存或磁盘上，指令和数据都是二进制信息\n1.6 存储单元 存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号\n比如128个存储单元，编号0~127\n1.7 cpu对存储器的读写 用什么做，怎么做，做什么\n电子计算机处理，传输的信息都是电信号，，电信号要用导线传送\n在计算机中专门链接cpu和其他芯片的导线，通常称之为总线\n物理上：一根根导线集合 逻辑上划分： 地址总线 数据总线 控制总线 8086cpu，最基础的cpu\n1.8 地址总线 cpu是通过地址总线来指定存储单元的\n地址总线上能传送多少个不同的信息，cpu就可以对多少个存储单元进行寻址\n多少位的cpu，就是描述cpu寻址的能力，\n64位的速度需要：64位的cpu，64位的操作系统，64位的软件\n![1.8 shili](1.8 shili.png)\n最多可以寻找2的n次方个内存单元\n一个地址总线，可以索引到一个内存单元，就是一个字节，包含8个位\n1.9 数据总线 cpu与内存或其他期间之间的数据传送时通过数据总线来进行的\n数据总线的宽度决定了cpu和外界的数据传输速度\n8088cpu，一次传8位数据，传送89 D8，传两遍\n8086cpu传输，16位，比8088cpu快一倍\n1.10 控制总线 cpu对外部器件的控制是通过控制总线来进行。这里控制总线是一个总称，控制总线是一些不同控制线的集合\n有多少根控制总线，就意味着cpu提供了对外部器件的多少钟控制\n所以，控制总线的宽度绝对cpu对外部器件的控制的能力\n控制总线发送控制信息\n内存读写的命令是由几根总控制线综合发出的：其中由一根名为读信号输出控制线负责由cpu向外传送读信号，cpu向该控制线上输出低电平表示将要读取数据；\n有一根名为写信号输出控制线负责由cpu向外传送写信号\n小结： 1.11 内存地址空间（概述） 内存地址空间\n一个cpu的地址线宽度为10，那么可以寻址到1024个内存单元，这1024个可寻到的内存单元就构成这个cpu的内存地址空间\n1.12 主板 每一台pc机种，都有一个主板，主板上由核心器件和一些主要器件\n器件通过总线相连\n1.13 接口卡 计算机系统中，所有可用程序控制其工作的设备，都必须受到cpu的控制\ncpu对外部设备不能直接控制，如显示器，音响，打印机等。直接控制这些设备进行工作的是插在拓展插槽上的接口卡\n接口卡通过总线与cpu相连，cpu可以通过总线向接口卡发送指令，以此来间接控制设备\n1.14 各类存储器的芯片 从读写属性上看分为两类：\n随机存储器（RAM）和只读存储器（ROM）\n内存就是一个大的随机存储器，断了电之后数据将会遗失\n(主随机存储器一般是由装载主板上的RAM和插在拓展插槽上的RAM组成)\n只读存储器，永远只能读，数据只要不把他刷掉，一直都存在那里\n装有BIOS的ROM BIOS: Basic Input/Output System 基本输入输出系统\nBIOS是由主板个各类接i卡（显卡，网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最近本的输入输出。子在主板你和某些接口卡上插有存储相应的BIOS的ROM\n从功能和连接上分类：\n随机存储器RAM 装有BIOS的ROM 接口卡上的RAM 某些接口卡上的RAM需要对大批量输入输出数据进行存储，比如显示卡上的RAM，一般叫显存\nPC机种各类存储器的逻辑链接情况\n各类储存器的逻辑链接\n1.15 内存地址空 上述那些存储器在物理上是独立的器件\n以下两点相同\n都和cpu的总线相连 cpu对他们进行读或写的时候都通过控制线发出内存读写命令 不同的计算机内存的分配地址是不同的\n内存地址空间：\n最终运行程序的是cpu，我们用汇编编程的时候，必须从cpu角度考虑问题 对cpu来将，系统中所有的存储器中的存储单元都处于一个统一的逻辑储存器中，它的容量受cpu寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间\n地址总线宽度，决定了定位的地址单元的数量，地址单元的数量，决定了cpu能够访问到的地址，也是各类设备能够储存的地址空间 补充 电平，电信号的电压值，两个不同的电压范围用来表示二进制\n管脚，也叫引脚，cpu与外部电路进行连接的接口\n存储单元，存储器最小寻址单位，每个单元占一个字节，\n1Byte = 1 bit -\u0026gt; 1KB = 8*1024 bit = 1024B\n","date":"2025-11-16T00:00:00Z","image":"http://localhost:1313/p/11-16/bj_hu_bf82909c341e984d.jpg","permalink":"http://localhost:1313/p/11-16/","title":"11-16 机器语言"},{"content":"2.\n某酒店有若干楼层，每层有若干房间。\n请你编写一个程序，使用 三维指针 char ***hotel 存储所有房间的住客姓名。\n要求：\n从键盘输入楼层数 f 和每层的房间数 r。 动态分配三维指针内存，使得每个房间都能存放一个住客姓名字符串。 用户依次输入每个房间的住客姓名（如空房请输入 \u0026quot;Empty\u0026quot;）。 程序输出整个酒店的入住情况（按楼层打印）。 最后释放所有分配的内存 输入\n1 2 3 4 5 6 7 2 3 Alice Bob Empty Cindy David Eve 输出\n1 2 3 4 5 6 7 8 9 酒店入住情况： 第 1 层： 房间 1: Alice 房间 2: Bob 房间 3: Empty 第 2 层： 房间 1: Cindy 房间 2: David 房间 3: Eve 代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int f, r; printf(\u0026#34;input hotel`s floor and room:\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;f, \u0026amp;r); char*** hotel = (char***)malloc(f * sizeof(char**)); for (int i = 0; i \u0026lt; f; i++) { hotel[i] = (char**)malloc(r * sizeof(char*)); for (int j = 0; j \u0026lt; r; j++) { hotel[i][j] = (char*)malloc(20 * sizeof(char)); } } for (int i = 0; i \u0026lt; f; i++) { for (int j = 0; j \u0026lt; r; j++) { printf(\u0026#34;input human`s name:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, hotel[i][j]); } } printf(\u0026#34;酒店入住情况:\\n\u0026#34;); for (int i = 0; i \u0026lt; f; i++) { printf(\u0026#34;第%d层:\\n\u0026#34;, i + 1); for (int j = 0; j \u0026lt; r; j++) { printf(\u0026#34;房间%d:%s\\n\u0026#34;, j + 1, hotel[i][j]); } } for (int i = 0; i \u0026lt; f; i++) { for (int j = 0; j \u0026lt; r; j++) { free(hotel[i][j]); } free(hotel[i]); } free(hotel); return 0; } 逆s盒替换 逆s盒：\n初始化s盒\n1 2 3 4 5 6 7 8 9 10 uint8_t i,j; uint8_t s_box_ary[16][16] = {0}; for(i=0;i\u0026lt;0x10;i++) { for(j=0;j\u0026lt;0x10;j++) { s_box_ary[i][j] = ((i\u0026lt;\u0026lt;4)\u0026amp;0xF0) + (j\u0026amp;(0xF)); } } 使得每行每列按顺序打印\n欧几里得算法拓展\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 printf(\u0026#34;\\r\\n\u0026#34;); for(i=0;i\u0026lt;0x10;i++) { for(j=0;j\u0026lt;0x10;j++) { if(s_box_ary[i][j] != 0) { s_box_ary[i][j] = extEuclidPolynomial(s_box_ary[i][j],0x11B); } } } printf(\u0026#34;\\r\\n\\r\\n 0 1 2 3 4 5 6 7 8 9 A B C D E F\u0026#34;); for(i=0;i\u0026lt;0x10;i++) { printf(\u0026#34;\\r\\n%2x\u0026#34;,i); for(j=0;j\u0026lt;0x10;j++) { printf(\u0026#34; %2x\u0026#34;,s_box_ary[i][j]); } } 这样可以得到一个再GF（2^8）的域里的的逆，0映射到自身\n之后还可以对每一个字节进行变换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 for(i=0;i\u0026lt;0x10;i++) { for(j=0;j\u0026lt;0x10;j++) { s_box_ary[i][j]=byteTransformation(s_box_ary[i][j], 0x63); } } printf(\u0026#34;\\r\\n\\r\\n 0 1 2 3 4 5 6 7 8 9 A B C D E F\u0026#34;); for(i=0;i\u0026lt;0x10;i++) { printf(\u0026#34;\\r\\n%2x\u0026#34;,i); for(j=0;j\u0026lt;0x10;j++) { printf(\u0026#34; %2x\u0026#34;,s_box_ary[i][j]); } } } re逆s盒代码题目：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; void Create_Inv_SBOX(unsigned char SBOX_AFTER[256]) { unsigned char SBOX[256] = { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16 }; for (int i = 0; i \u0026lt; 256; i++) { SBOX_AFTER[SBOX[i]] = i ; } } int Inv_SubBytes() { char* path = \u0026#34;d:\\\\11\\\\1.bin\u0026#34;; char* path1 = \u0026#34;d:\\\\11\\\\1.jpg\u0026#34;; FILE* fp = NULL; FILE* fp1 = NULL; errno_t err = fopen_s(\u0026amp;fp, path, \u0026#34;rb\u0026#34;); if (err != 0 || fp == NULL) { return -1; } fseek(fp, 0, SEEK_END); int SIZE = ftell(fp); fseek(fp, 0, SEEK_SET); printf(\u0026#34;%d\\n\u0026#34;, SIZE); unsigned char* buf = (unsigned char*)malloc(SIZE); fread(buf, 1, SIZE, fp); fclose(fp); unsigned char SBOX_AFTER[256] = { 0 }; Create_Inv_SBOX(SBOX_AFTER); err = fopen_s(\u0026amp;fp1, path1, \u0026#34;wb\u0026#34;); if (err != 0 || fp == NULL) { return -1; } unsigned char* p = buf; for (int i = 0; i \u0026lt; SIZE; i++) { p[i] = SBOX_AFTER[p[i]]; } fwrite(p, 1, SIZE, fp1); fclose(fp); return 0; } static int main() { Inv_SubBytes(); return 0; } ","date":"2025-11-15T00:00:00Z","image":"http://localhost:1313/p/11-15/bj_hu_27bf33d33c509316.jpg","permalink":"http://localhost:1313/p/11-15/","title":"11-15 作业"},{"content":"5.从标准输入读入 R×C 矩阵，将其：\n以整齐的表格形式写入文本文件 matrix.txt； 以二进制格式写入 matrix.bin，格式为（均 32 位小端有符号整数）：R、C 头两个数，然后是按行主序存放的 R*C 个元素。 示例输入\n1 2 3 2 3 11 26 32 24 85 96 matrix.txt 内容（文本）：\n1 2 11 26 32 24 85 96 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int WriteFile(int **arr,int R,int C) { char *path = \u0026#34;d:\\\\11\\\\matrix.txt\u0026#34;; FILE* file = NULL; errno_t err = fopen_s(\u0026amp;file,path,\u0026#34;w\u0026#34;); if (err != 0 \u0026amp;\u0026amp; file == NULL) { return -1; } for (int i = 0; i \u0026lt; R; i++) { for (int j = 0; j \u0026lt; C; j++) { fprintf(file,\u0026#34;%d \u0026#34;,arr[i][j]); } fprintf(file,\u0026#34;\\r\\n\u0026#34;); } fclose(file); } int WriteFileBin(int** arr, int R, int C) { char* path = \u0026#34;d:\\\\11\\\\matrix.bin\u0026#34;; FILE* file = NULL; errno_t err = fopen_s(\u0026amp;file, path, \u0026#34;wb\u0026#34;); if (err != 0 \u0026amp;\u0026amp; file == NULL) { return -1; } for (int i = 0; i \u0026lt; R; i++) { for (int j = 0; j \u0026lt; C; j++) { fwrite(\u0026amp;arr[i][j], sizeof(int),1,file); } } fclose(file); err = fopen_s(\u0026amp;file, path, \u0026#34;rb\u0026#34;); if (err != 0 || file == NULL) { return -1; } int buf[128*128] = {0}; fread(buf, sizeof(int), R * C, file); for (int i = 0; i \u0026lt; R*C; i++) { printf(\u0026#34;buf:%d\\n\u0026#34;, buf[i]); } fclose(file); } int main() { int a, b; printf(\u0026#34;input R\u0026amp;C:\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); int** arr = (int**)malloc(a * sizeof(int*)); for (int i = 0; i \u0026lt; a; i++) { arr[i] = (int*)malloc(b * sizeof(int)); } for (int i = 0; i \u0026lt; a; i++) { for (int j = 0; j \u0026lt; b; j++) { printf(\u0026#34;input data:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i][j]); } } WriteFile(arr,a,b); WriteFileBin(arr, a, b); free(arr); return 0; } 1.编写一个程序，定义一个 Student 结构体，包含以下成员：\nchar name[20] —— 学生姓名 int id —— 学号 float score —— 成绩 要求：\n从键盘输入 n 个学生的信息。 按成绩从高到低排序（若成绩相同则按学号升序）。 输出排序后的学生信息。 输入\n1 2 3 4 5 6 5 Alice 1001 85.5 Bob 1003 90.0 Cindy 1002 90.0 David 1004 78.0 Eve 1005 85.5 输出\n1 2 3 4 5 6 排序后的学生信息： Bob 1003 90.00 Cindy 1002 90.00 Alice 1001 85.50 Eve 1005 85.50 David 1004 78.00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct Student { char name[20]; int id; float score; }Student, * pStudent; int main() { int a; printf(\u0026#34;input quantity:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); Student* stu= (Student*)malloc(a * sizeof(Student)); if (stu == NULL) { return -1; } for (int i = 0; i \u0026lt; a; i++) { printf(\u0026#34;input stu message:\u0026#34;); scanf(\u0026#34;%s %d %f\u0026#34;, stu[i].name, \u0026amp;stu[i].id, \u0026amp;stu[i].score); } for (int i = 0; i \u0026lt; a; i++) { for (int j = i+1; j \u0026lt; a; j++) { if (stu[i].score \u0026lt; stu[j].score) { Student tmp = { 0 }; tmp = stu[j]; stu[j] = stu[i]; stu[i] = tmp; } if (stu[i].score == stu[j].score \u0026amp;\u0026amp; stu[i].id \u0026lt; stu[j].id) { Student tmp = { 0 }; tmp = stu[j]; stu[j] = stu[i]; stu[i] = tmp; } } } for (int i = 0; i \u0026lt; a; i++) { printf(\u0026#34;%s %d %.2f\\n\u0026#34;, stu[i].name, stu[i].id, stu[i].score); } free(stu); return 0; } ","date":"2025-11-14T00:00:00Z","image":"http://localhost:1313/p/11-14/bj_hu_1a685397fb5dca45.jpg","permalink":"http://localhost:1313/p/11-14/","title":"11-14 作业"},{"content":"4.定义一个名为 BinaryString 的结构体，包含一个字符串 str 用于存储二进制数字，和一个整型变量 length 用于存储字符串的长度。编写一个函数，ring` 结构体数组中，最后返回这个数组\n示例输入：\n1 hello 输出：\n1 2 3 4 5 h: 01101000 e: 01100101 l: 01101100 l: 01101100 o: 01101111 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef struct BinaryString { char str; int length; }BinaryString,*pBinaryString; void PrintBinary(unsigned char dec) { unsigned int quotient = 1; unsigned int Remainder = 1; char c[8] = { 0 }; int count = 0; while (dec \u0026gt; 0) { Remainder = dec % 2; quotient = dec / 2; c[count] = Remainder; count++; dec = quotient; } for (int i = 8 - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } printf(\u0026#34;\\n\u0026#34;); } void Change_ASCII_Bin(char a[], int len) { for (int i = 0; i \u0026lt; len; i++) { BinaryString b1 = { 0 }; b1.str = a[i]; printf(\u0026#34;%c:\u0026#34;, b1.str); char n = (int)b1.str; PrintBinary(n); } } int main() { char a[6] = {0}; printf(\u0026#34;input array:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, \u0026amp;a); int len = sizeof(a) / sizeof(a[0]) - 1; Change_ASCII_Bin(a,len); return 0; } 学习十进制转换为二进制\n以及二进制的正序逆序打印\n","date":"2025-11-13T00:00:00Z","image":"http://localhost:1313/p/11-13/bj_hu_2038fdfeff213915.jpg","permalink":"http://localhost:1313/p/11-13/","title":"11-13 作业"},{"content":"将之前除链表，pe读取，配置文件读取的作业写了\n1.将一个2行3列的二维数组转置为3行2列的数组 1 2 3 4 5 6 7 Input 6 integers: 123 43 12 00 01 02 64 234 12 10 11 12 转换后的数组: 123 64 00 01 43 234 10 11 12 12 20 21 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; int main() { int a[2][3] = { 0 }; int b[3][2] = { 0 }; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 3; j++) { printf(\u0026#34;Input 6 integers:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 3; j++) { b[j][i] = a[i][j]; } } for (int i = 0; i \u0026lt; 3; i++) { for (int j = 0; j \u0026lt; 2; j++) { printf(\u0026#34;%d \u0026#34;, b[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 2.编写一个C语言程序，使用指针将数组{10, 20, 30, 40, 50}反转并输出结果。 实现如下：\n1 2 原数组: 10 20 30 40 50 反转后: 50 40 30 20 10 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int a[5] = { 10,20,30,40,50 }; int len = sizeof(a) / sizeof(a[0]) - 1; int* pl = \u0026amp;a[0]; int* pr = \u0026amp;a[len]; while (pl != pr) { int tmp =*pr; *pr = *pl; *pl = tmp; pl++; pr--; } for (int i=0; i \u0026lt; len+1; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } return 0; } ","date":"2025-11-12T00:00:00Z","image":"http://localhost:1313/p/11-12/bj_hu_ed96abcad5bcf6d0.jpg","permalink":"http://localhost:1313/p/11-12/","title":"11-12 作业"},{"content":"第十九课-递归 （1）：递归定义 函数内部，直接或者间接的调用自身\n递归首先需要有至少一个递归出口，即终止条件，不能无限调用自己\n递归式，原问题划分成子问题，子问题解决性质一样，这样子问题解决之后原问题也会被解决\n阶乘 定义fact无符号数\n满足n==0或==1，即一个递归出口\n1 2 3 4 5 6 7 8 int fact(unsigned int n) { if(n==0 || n==1) { return 1; } return n * fact(n-1); } 斐波那契数列 1 2 3 4 5 6 7 8 9 10 unsigned int feibo(unsigned int n) { if(n==1 || n==2) { return 1; } return feibo(n-1)+feibo(n-2); } printf(\u0026#34;feibo(6)=%d\\n\u0026#34;,feibo(6)) 递归的优缺点 作业 两个，一个是递归的出口，二个是递归式，递归式需要满足符合原式的子式，并且能求解问题\n递归优点：简洁明了 缺点：效率较低，容易导致栈溢出\n迭代优点：效率高， 缺点：代码编写难度高\n（2）：递归的应用 问题1\n1 2 3 4 5 6 7 8 9 10 11 int mystrlen(const char* str) { if (str == NULL || *str == \u0026#39;\\0\u0026#39;) { return 0; } return 1 + mystrlen(str + 1); //一句话计算出非空字符串的长度 //(str==NULL || *str==\u0026#39;\\0\u0026#39;)?0:1+mystelen(str+1) } 问题2\n1 2 3 4 5 6 7 8 9 void reverse_print(const char *str) { if(str==NULL || *str==\u0026#39;\\0\u0026#39;) { return; } reverse_print(str+1); printf(\u0026#34;%c\u0026#34;,*str); } 直接定义*指向内存地址是静态区不可更改，需要改成在栈上才可以更改\n比如：\nchar *str=\nchar buf[] =\n问题3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void reverse_str(char *str,int len) { if (str == NULL || *str == \u0026#39;\\0\u0026#39; || len==0) { return 0; } reverse_str(str + 1,len-2); char tmp = *str; *str = *(str + len - 1); *(str + len -1)=tmp; return; } 运用递归 作业 寻找解决问题的子式，也就是寻找一个式子能让递归一直嵌套下去直到嵌套到递归出口\n递归或者循环解决\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int fibonacci(int n) { if(n == 0) { return 0; } else if(n == 1) { return 1; } else { return fibonacci(n-1) + fibonacci(n-2); } } int main() { int n; printf(\u0026#34;请输入一个整数：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;斐波那契数列的第%d项为：%d\\n\u0026#34;, n, fibonacci(n)); return 0; } #include\u0026lt;stdio.h\u0026gt; // 斐波那契数列函数 int fibonacci(int n) { if(n \u0026lt;= 1) { return n; } int a = 0, b = 1; for(int i = 2; i \u0026lt;= n; i++) { int temp = a + b; a = b; b = temp; } return b; } int main() { int n; printf(\u0026#34;请输入一个整数：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;斐波那契数列的第%d项为：%d\\n\u0026#34;, n, fibonacci(n)); return 0; } 第二十课-文件 （1）：文件概念 文件分类 文件系统 文本文件与二进制文件 字符编码\n基于值编码\n作业 文本文件，基于字符编码的方式编写 二进制文件，基于值编码的方式的文件 文件系统：管理，读写，调用一个文件的数据结构 FAT ZFS\n（2）：文件创建、打开与读写 1 2 3 4 5 6 7 8 9 10 fopen(\u0026#34;newfile.txt\u0026#34;,\u0026#34;w,ccs=UTF-8\u0026#34;); 第一个参数是路径，路径分为相对路径和绝对路径 第二个参数是文件的打开方式， r 读 w 写 文本方式打开，存在换行之间的转换 css 用来指定文件打开的编码 默认为ascii编码，可以通过读取文件头的形式来获取文本所用的编码方式 记得关闭文件，否则会一直有程序或者进程占用文件使用\nfopen也是老函数，需要安全的调用，\nfopen_s(\u0026amp;pfile)指针的值\n1 2 _mkdir 创建文件夹的指令 \u0026lt;direct.h\u0026gt; 包含 代码演示 创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; int create_file() { char* path = \u0026#34;d:\\\\1111111111111\\\\mallocfree.txt\u0026#34;; FILE *file = fopen(path, \u0026#34;w\u0026#34;); if (file == NULL) { return -1; } fclose(file); return 0; } int main() { create_file(); return 0; } 打开\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int open_file() { char* path = \u0026#34;d:\\\\111111111111\\\\mallocfree.txt\u0026#34;; FILE* file = NULL; errno_t err = fopen_s(\u0026amp;file, path,\u0026#34;r\u0026#34;); if (err != 0 || file == NULL) { return -1; } fclose(file); return 0; } 创建文件夹\n1 2 3 4 5 6 7 8 int create_dir() { char* dirpath = \u0026#34;d:\\\\1111111111111\\\\mf\\\\\u0026#34;; int res = _mkdir(dirpath); return res; } 文件的读写 buffer 数据 size 字节数 ntime 写入多少长度 fp 文件指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; void binaryio_demo() { char* filepath = \u0026#34;d:\\\\1111111111111\\\\binary_io.txt\u0026#34;; FILE* file = NULL; errno_t err = fopen_s(\u0026amp;file, filepath, \u0026#34;w\u0026#34;); if (err != 0 || file == NULL) { return -1; } fwrite(\u0026#34;hello world\u0026#34;, strlen(\u0026#34;hello world\u0026#34;) + 1, 1, file); int date = 100; fwrite(\u0026amp;date, sizeof(date), 1, file); fclose(file); err = fopen_s(\u0026amp;file, filepath, \u0026#34;r\u0026#34;); if (err != 0 || file == NULL) { return -1; } char buf[128] = { 0 }; fread(buf, strlen(\u0026#34;hello world\u0026#34;) + 1, 1, file); int value = 0; fread(\u0026amp;value, sizeof(value), 1, file); printf(\u0026#34;buf:%s,value:%d\u0026#34;, buf,value); fclose(file); } int main() { binaryio_demo(); return 0; } 文件的读写 格式化输入输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; int format_io() { char* filepath = \u0026#34;d:\\\\1111111111111\\\\format_io.txt\u0026#34;; FILE *fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;w\u0026#34;); if (err != 0||fp == NULL) { return -1; } // int data = 100; 可以传入变量 fprintf(fp,\u0026#34;%s %d\u0026#34;,\u0026#34;hello-world\u0026#34;,100); fclose(fp); err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0||fp == NULL) { return -1; } char buf[128] = { 0 }; int value = 0; fscanf_s(fp, \u0026#34;%s%d\u0026#34;, buf,128, \u0026amp;value); printf(\u0026#34;format io:buf:%s,value:%d\\n\u0026#34;, buf, value); fclose(fp); return 0; } int main() { format_io(); return 0; } 字符输入输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; int char_io() { char* str = \u0026#34;hello world\u0026#34;; char* filepath = \u0026#34;d:\\\\11\\\\char_io.txt\u0026#34;; FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } while (*str != \u0026#39;\\0\u0026#39;) { fputc(*str, fp); str++; } fputc(\u0026#39;\\0\u0026#39;, fp); fclose(fp); err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } while (!feof(fp))//判断是否到达文件末尾 { char ch = fgetc(fp); printf(\u0026#34;%c\u0026#34;, ch); } printf(\u0026#34;\\n\u0026#34;); fclose(fp); return 0; } int main() { char_io(); return 0; } 字符串输入输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; int str_io() { char* data[4] = { \u0026#34;hello world\\n\u0026#34;, \u0026#34;hello beijing\\n\u0026#34;, \u0026#34;hello china\\n\u0026#34;, \u0026#34;hello dlrow\\n\u0026#34; }; char* filepath = \u0026#34;d:\\\\11\\\\str_io.txt\u0026#34;; FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } for (int i = 0; i \u0026lt; 4; i++) { fputs(data[i], fp); } fclose(fp); err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } while (!feof(fp)) { char buf[128] = { 0 }; fgets(buf, 128, fp); printf(\u0026#34;str io:buf:%s\u0026#34;, buf); } fclose(fp); return 0; } int main() { str_io(); return 0; } fopen popen fwrite write 读写缓存：调用io来写入磁盘非常消耗性能，而缓存就是将写入字节累计，到一定程度在写入磁盘\n作业 （3）：文件其他相关操作 读写指针控制 读写指针，有一个指针在文件中移动，\n从文件头开始移动，表示读和写的相应位置\nrewind 移动到文件头\nfseek 第二个参数是相对位置的偏移，第三个参数是某某位置 还有后续三张是个表格黑奴奥尔不过发选举过后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;string.h\u0026gt; int seek_demo() { char* filepath = \u0026#34;d:\\\\11\\\\see_demo.txt\u0026#34;; FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } fwrite(\u0026#34;hello world\u0026#34;, strlen(\u0026#34;hello world\u0026#34;) + 1, 1, fp); fseek(fp, -6, SEEK_CUR); fwrite(\u0026#34;china\u0026#34;, strlen(\u0026#34;china\u0026#34;) + 1, 1, fp); fclose(fp); err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } fseek(fp, 6, SEEK_SET); char buf[123] = { 0 }; fread(buf, strlen(\u0026#34;china\u0026#34;) + 1, 1, fp); printf(\u0026#34;buf:%s\\n\u0026#34;, buf); //fwrite(\u0026#34;welcome world\u0026#34;, strlen(\u0026#34;welcome world\u0026#34;) + 1, 1, fp); fclose(fp); return 0; } int main() { seek_demo(); return 0; } fseek 定位末尾\nflen=ftell(fp) 读写偏移，返回值就是文件大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;string.h\u0026gt; int seek_demo() { char* filepath = \u0026#34;d:\\\\11\\\\see_demo.txt\u0026#34;; FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } fwrite(\u0026#34;hello world\u0026#34;, strlen(\u0026#34;hello world\u0026#34;) + 1, 1, fp); fseek(fp, -6, SEEK_CUR); fwrite(\u0026#34;china\u0026#34;, strlen(\u0026#34;china\u0026#34;) + 1, 1, fp); fclose(fp); err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } fseek(fp, 6, SEEK_SET); char buf[123] = { 0 }; fread(buf, strlen(\u0026#34;china\u0026#34;) + 1, 1, fp); printf(\u0026#34;buf:%s\\n\u0026#34;, buf); //fwrite(\u0026#34;welcome world\u0026#34;, strlen(\u0026#34;welcome world\u0026#34;) + 1, 1, fp); fclose(fp); return 0; } long get_filesize(const char* filepath) { if (filepath == NULL) { return 0; } FILE *fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return 0; } fseek(fp, 0, SEEK_END); long size = ftell(fp); fclose(fp); } int main() { seek_demo(); long size = get_filesize(\u0026#34;d:\\\\11\\\\see_demo.txt\u0026#34;); printf(\u0026#34;size:%d\u0026#34;, size); return 0; } 文件重命名 1 2 3 4 5 6 7 8 9 10 11 12 13 int rename_demo() { char* file1 = \u0026#34;d:\\\\11\\\\see_demo.txt\u0026#34;; char* file2 = \u0026#34;d:\\\\11\\\\seek1_demo.txt\u0026#34;; rename(file1, file2); return 0; } 还可以重命名到其他目录里面去 不可以跨盘符重命名 文件删除 1 2 3 4 5 6 7 8 int remove_demo() { char* filepath = \u0026#34;d:\\\\11\\\\see_demo.txt\u0026#34;; int res = remove(filepath); return res; } 删除不掉可能是因为进程被占用\n作业 remind() (SEEK_CUR) (SEEK_END) (SEEK_SET)\nftell = flen 指针指向末尾在显示偏移量\n两次声明文件，一次原名字一个名字，然后调用rename 。。 删除指定文件之后调用remove\n与指向end的偏移值做对比，相等即是读到结束了\n（4）：结构体IO与优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define FILENAME \u0026#34;d:\\\\11\\\\student_data_base.dat\u0026#34; #define MAXLEN 64 typedef struct _record { char name[MAXLEN]; int age; }record,*precord; int write_record(FILE* fp) { while (1) { record r = { 0 }; printf(\u0026#34;Please input the age:\\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;r.age); if (r.age == 0) { break; } printf(\u0026#34;Please input the name:\\n\u0026#34;); scanf_s(\u0026#34;%s\u0026#34;,r.name, MAXLEN); fwrite(\u0026amp;r, sizeof(r), 1, fp); } return 0; } int read_record(FILE* fp) { while (!feof(fp)) { record r = { 0 }; int count = fread(\u0026amp;r, sizeof(r), 1, fp); if (count == 0) { break; } printf(\u0026#34;age:%d,name:%s\\n\u0026#34;, r.age, r.name); } return 0; } int main() { FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } write_record(fp); fclose(fp); err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } read_record(fp); fclose(fp); return 0; } 如图，存放年龄和名字之后，还有大量的空间被无意义的数据占用\n优化：\n在名字前面存放每一个名字的字节数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define FILENAME \u0026#34;d:\\\\11\\\\student_data_base.dat\u0026#34; #define MAXLEN 64 typedef struct _record { char name[MAXLEN]; int age; }record,*precord; int optwrite_record(FILE* fp) { while (1) { record r = { 0 }; printf(\u0026#34;Please input rhe age:\\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;r.age); if (r.age == 0) { break; } printf(\u0026#34;Please input the name:\\n\u0026#34;); scanf_s(\u0026#34;%s\u0026#34;, r.name, MAXLEN); int len = strlen(r.name); fwrite(\u0026amp;len, sizeof(len), 1, fp); fwrite(r.name, len, 1, fp); fwrite(\u0026amp;r.age, sizeof(r.age), 1, fp); } return 0; } int optread_record(FILE *fp) { while (!feof(fp)) { record r = { 0 }; int len = 0; int count = fread(\u0026amp;len, sizeof(len), 1, fp); if (count == 0) { break; } fread(r.name, len, 1, fp); fread(\u0026amp;r.age, sizeof(r.age), 1, fp); printf(\u0026#34;age:%d,name:%s\\n\u0026#34;, r.age, r.name); } return 0; } int main() { FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } optwrite_record(fp); fclose(fp); err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } optread_record(fp); fclose(fp); return 0; } 查询在数据库里人名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int optquery_record(FILE* fp) { char name[MAXLEN] = { 0 }; printf(\u0026#34;Please input the name :\\n\u0026#34;); scanf_s(\u0026#34;%s\u0026#34;, name, MAXLEN); bool bFind = false; while (!feof(fp)) { record r = { 0 }; int len = 0; int count = fread(\u0026amp;len, sizeof(len), 1, fp); if (count == 0) { break; } fread(r.name, len, 1, fp); fread(\u0026amp;r.age, sizeof(r.age), 1, fp); if(strcmp(r.name,name)==0) { printf(\u0026#34;found it,age:%d,name:%s\\n\u0026#34;, r.age, r.name); bFind = true; break; } } if (!bFind) { printf(\u0026#34;nor found\\n\u0026#34;); } } 此处报错，可能是进行比较时没有清零，未匹配上\n问题：在第一次record时文件指针移动到文件末尾，而后续指针调用实际上无法再进行遍历\n修改后代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #define FILENAME \u0026#34;d:\\\\11\\\\student_data_base.dat\u0026#34; #define MAXLEN 64 typedef struct _record { char name[MAXLEN]; int age; }record,*precord; int optwrite_record(FILE* fp) { while (1) { record r = { 0 }; printf(\u0026#34;Please input rhe age:\\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;r.age); if (r.age == 0) { break; } printf(\u0026#34;Please input the name:\\n\u0026#34;); scanf_s(\u0026#34;%s\u0026#34;, r.name, MAXLEN); int len = strlen(r.name); fwrite(\u0026amp;len, sizeof(len), 1, fp); fwrite(r.name, len, 1, fp); fwrite(\u0026amp;r.age, sizeof(r.age), 1, fp); } return 0; } int optread_record(FILE *fp) { while (!feof(fp)) { record r = { 0 }; int len = 0; int count = fread(\u0026amp;len, sizeof(len), 1, fp); if (count == 0) { break; } fread(r.name, len, 1, fp); fread(\u0026amp;r.age, sizeof(r.age), 1, fp); printf(\u0026#34;age:%d,name:%s\\n\u0026#34;, r.age, r.name); } return 0; } int optquery_record(FILE* fp) { char name[MAXLEN] = { 0 }; printf(\u0026#34;Please input the name :\\n\u0026#34;); scanf_s(\u0026#34;%s\u0026#34;, name, MAXLEN); bool bFind = false; rewind(fp); while (!feof(fp)) { record r = { 0 }; int len = 0; memset(\u0026amp;r, 0, sizeof(r)); int count = fread(\u0026amp;len, sizeof(len), 1, fp); if (count == 0) { break; } fread(r.name, len, 1, fp); fread(\u0026amp;r.age, sizeof(r.age), 1, fp); if(strcmp(r.name,name)==0) { printf(\u0026#34;found it,age:%d,name:%s\\n\u0026#34;, r.age, r.name); bFind = true; break; } } if (!bFind) { printf(\u0026#34;nor found\\n\u0026#34;); } return 0; } int main() { FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } optwrite_record(fp); fclose(fp); err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } optread_record(fp); optquery_record(fp); fclose(fp); return 0; } 删除：\n找到这一条记录，将后面的记录重新覆盖前一条数据\n更新：\n1.更新年龄，更改覆盖\n2.更改名字，名字长度更改，会破坏储存数据。只能够使用临时文件，拷贝之前的文件，然后写入，再拷贝之后的文件，在删除源文件\n作业 ","date":"2025-11-11T00:00:00Z","image":"http://localhost:1313/p/11-11/bj_hu_a555a92545837721.jpg","permalink":"http://localhost:1313/p/11-11/","title":"11-11 递归"},{"content":"第十八课-宏 （1）：宏的定义 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define PI 3.14 float calc_circle_area(float r) { return PI * r * r; } int main() { printf(\u0026#34;s:%.2lf\u0026#34;, calc_circle_area(1.1f)); return 0; } 宏定义不带分号\n宏定义优缺点 c++ 中可以设置常变量\n带参数的宏定义-MAX 理解宏展开：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAX(X,Y) X\u0026gt;Y?X:Y int main() { printf(\u0026#34;max:%d\\n\u0026#34;, MAX(7, 2)); printf(\u0026#34;max:%d\\n\u0026#34;, MAX(1\u0026amp;7, 5-2)); return 0; } 原封不动的打包替换 第二个 1\u0026amp;7\u0026gt;5-2?1\u0026amp;7:5-1 先算减法，然后比较运算，然后与运算，然后三目运算 1\u0026amp;1?1\u0026amp;7:4 1?1:4 修改的话，可以给x y整个变量打上括号，这样替换位置的时候先算括号里的 如果使用 int getmax(int x , int y) { return x\u0026gt;y?x:y; } 不加括号也可以使用 宏定义会直接替换，函数的话会计算之后再传参 带参数的宏与函数优缺点比较 函数有出栈和入栈的调用过程，效率低于宏\n函数还有参数的安全检测，比如参数的类型，如果穿的参数不匹配对应的类型，则无法匹配\n作业 不带参数，优点：效率高，\n缺点：无法调试，无法修改\n带参数，优点：效率高，直接替换，没有进出栈\n缺点：直接替换而无法进行计算，以及不能进行类型检查\n#define calcula_array(arr) (sizeof(arr)/sizeof(arr[0]))\n#define a=a^b,b=a^b,a=a^b\n（2）：宏的应用与注意事项 两个数的交换 宏写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define SWAP(a,b) \\ int tmp; \\ tmp = a; \\ a = b; \\ b = tmp; int main() { int a = 10; int b = 25; printf(\u0026#34;a is not less than b\\n\u0026#34;); printf(\u0026#34;a:%d,b:%d\\n\u0026#34;, a, b); SWAP(a, b); printf(\u0026#34;a:%d,b:%d\\n\u0026#34;, a, b); return 0; } 会有一个问题\n即，如果在if条件下，原宏定义为使用括号，如果条件下未用括号，会导致宏展开的语句也没有括号，使得程序报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 即 if(a\u0026gt;b) SWAP(a,b); else printf() 两种办法解决 第一种是语句加上括号 第二种是在原宏定义加上do while #define SWAP(a,b) \\ do{ \\\tint tmp; \\ tmp = a; \\ a = b; \\ b = tmp; \\ }while(0) 软件生产宏定义 宏应用 偏移语句中未对0进行解引用，不会引起报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct _S { int i; char ch; }S,*PS; #define OFFSETOF(s,m) (size_t)(\u0026amp;(((s *)0)-\u0026gt;m)) int main() { printf(\u0026#34;offset of i:%d, ch:%d\\n\u0026#34;, OFFSETOF(S, i), OFFSETOF(S, ch)); return 0; } 常用 链表中某一个数据的偏移\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define ARRAYSIZE(a) sizeof(a)/sizeof(a[0]) int main() { char ch[] = \u0026#34;hello world\u0026#34;; printf(\u0026#34;items of ch is :%d\\n\u0026#34;, ARRAYSIZE(ch)); return 0; } 计算数组中元素个数\n1 2 3 abs(a-b) -\u0026gt; a-b的绝对值 abs是math文件里的函数 #define MAX(A,B) ((a)+(b)+abs((a)-(b)))/2 不用比较 if 来计算a和b的最大值\n宏的注意事项 字符串中属于字符串的一部分，不会宏展开\n2.宏名的标识符不能用数字开头\n3.双引号必须完整\n4.标识符必须完整\n#和## 定义一个宏来计算一个数的平方 1 #define power(x) ((x)*(x)) 宏的二义性 作业 偏移：相对于结构体所在内存地址的相对字节数 #define (size_t) \u0026amp;(((s *)0)-\u0026gt;m)\n#define calcula_array(arr) sizeof(arr)/sizrof(arr[0]) #define (a+b+abs(a-b)/2) #是字符串化，将宏参数转化为字符串 ##是拼接，用于将两个参数连接起来 （3）：条件编译 条件编译形式1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define WINVER 6.1 int main() { #ifdef WINVER printf(\u0026#34;WINVER is defined\\n\u0026#34;); #else printf(\u0026#34;WINVER is not defined\\n\u0026#34;); #endif return 0; } 条件编译方式3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define DEBUG 1 int main() { int a = 10; int b = 15; int c = a + b; #if DEBUG printf(\u0026#34;c:%d\\n\u0026#34;,c); #endif return 0; } 判断真假 条件编译方式4 条件编译实际工程例子 头文件的预编译 避免同一个头文件被多次编译\n作业 减少头文件的的重复编译\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ai 条件编译的主要用途： 平台适配 c #ifdef _WIN32 // Windows 专用代码 #elif defined(__linux__) // Linux 专用代码 #endif 调试代码开关 c #ifdef DEBUG printf(\u0026#34;调试信息\\n\u0026#34;); #endif 功能模块化 c #if FEATURE_A // 功能A的代码 #endif 头文件保护 c #ifndef HEADER_H #define HEADER_H // 头文件内容 #endif 不同版本构建 c #if VERSION \u0026gt; 2 // 新版本功能 #endif 好处：同一份源码可编译出不同功能的程序，避免运行时判断的开销。 三种形式，分支语句形式，布尔语句形式，是否进行宏定义形式\n","date":"2025-11-10T00:00:00Z","image":"http://localhost:1313/p/11-10/bj_hu_ea35ef0b1f970c1a.jpg","permalink":"http://localhost:1313/p/11-10/","title":"11-10 宏"},{"content":"第十六课-位运算 （1）：位运算概述 复习二进制位 扩展位数的时候，用符号为去填充多出来的位数\n位运算定义 \u0026amp; | ~ ^ \u0026laquo; \u0026raquo; and or not xor shl shr 与 或 取反 异或 左移 右移 运算符 作业 1.一个bit为二进制中的一个为数位，一个byte由八个数位组成，成为一个字节\n2.~最高，单目运算 \u0026laquo; \u0026raquo; 次之 然后是 \u0026amp; ^ |\n3.不可以，整型是用32位补码形式存放。浮点数的存储方式与整数不一样，包含了一位符号位还有指数位，所以不能使用移位运算\n4.一种是逻辑运算符一种是位运算符，单个是针对于数的二进制表达进行位移动，两个是对于两个表达之间的真假判断\n5.都是 \u0026ldquo;x = x \u0026amp; 某数\u0026rdquo; 的含义\n（2）：与运算 \u0026amp; 程序表示 7，的二进制表示为0111，一个数与7进行与运算，得到的数，就是其末尾3位\n16，0xF\n子网掩码 255.255.255.0 -\u0026gt; 0xFFFFFF00\nip:192.168.1.100\n前三个字节是网络号。最后一个字节是主机号\n子网掩码，进行与运算获取网络号\n清除整数a二进制中最右边的1 各种性质 作业 1.与运算中，与1运算的值都为本身，与0预算的值都为0，获取低三位低八位，只需要使 0000 0111 , 0000 0000 1111 1111 满足除需要的位数其余数字为0即可获得\n2.某一位为1，也是，假设判断第四位为1，0000 1000 如果结果为1则为1\n（3）：或运算 | 或运算程序 作业 或运算算法，有1即结果为1,所以只需要确保计算的某位置的数为1即可\n（4）：异或运算 ^ 异或运算，相同为0，不同为1、\n异或的程序表达 异或运算的性质 xor eax eax 自己与自己异或，结果为0\n两个数的交换\n单指针实现双链表 作业 1 2 3 4 5 6 7 8 9 1.异或运算，相同为0，相反取1 设a ，b 两个数 int a,b; a = a xor b b = \u0026#39;a\u0026#39; xor b = a xor b xor b = a xor 0 = a a = \u0026#39;a\u0026#39; xor \u0026#39;b\u0026#39; = a xor b xor a = b xor 0 = b 所以 a = b b = a 2.链表暂定\n（5）：取反运算 必须是1个字节，2个或者4个\n程序表示 不存在复合运算\n作业 先计算 ~0xFFFEFFFF 即 1111 1111 1111 1110 1111 1111 1111 1111 取反 0000 0000 0000 0001 0000 0000 0000 0000\n然后计算 0x12345678 即 0001 0010 0011 0100 0101 0110 0111 1000 与其取或，即把其中一位变成1即可\n结果：0001 0010 0011 0101 0101 0110 0111 1000 = 0x12355678\n（6）：移位运算 \u0026laquo; \u0026raquo; 左移运算符 ：\u0026laquo; 举例\n右移运算符 分为逻辑右移和算数右移\nc语言中右移运算符为算数右移\njava \u0026raquo;\u0026gt;逻辑 \u0026raquo;算数\n作业 1.左移n位，空出来的用0填充 右移n位，空出来的用符号位填充\n2.等于将这个数乘以/除以 2^N次方\n3.(0x12345678 = 0001 0010 0011 0100 0101 0110 0111 1000 \u0026raquo; 24) = 0000 0000 0000 0000 0000 0000 0001 0010 \u0026amp; (0xFF=1111 1111)\n结果为 0001 0010 =0x12\n（7）：位运算综合运用 将第N位置0或者置1 对称加密 实际项目运用 作业 127 -\u0026gt; 0111 1111 左移1位，然后用0填充，再加1 1111 1110 加1 结果是1111 1111, 255 (?)\n-1 -\u0026gt; 1111 1111 右移1位，然后用符号位填充，1111 1111 再加1 结果是 1 0000 0000 -256 (?)\n算数运算符优先，也就是1\u0026laquo;5 0000 0001 0010 0000 结果是，乘以2的5次方，32\n15 \u0026amp; 240 换成二进制 0000 1111 1111 0000 与运算，与1运算为本身 , 0\n0000 1010 ^ 0000 1100 异或运算，相同取0，相反取1 即 0000 0110 ，6\n与1111 1111 0000 0000 0000 0000 0000 0000 进行与运算\n1向左移动100位，除以7的余数， 0000 0111取余 (?)\n1~1024 00 0000 0001 - 10 0000 0000 异或取值范围 相同0，不同1 最大即2047，最小(?) 1025 还包含0\n(?)\n解析：\n字符型，-128~127 第一题左移转为十进制254，超出范围，截断，1111 1110 表示为 -2,-2+1=-1\n第二题，右移一位，保持-1，再加1，结果为0\n思路，循环加移位，先将浮点数转换为整数，因为浮点数与整数的编码方式不同，如果直接转换成2进制会出现问题，所以\n需要转换成整数并且一位一位打印\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #define mask 0x1 int main() { float f = 1.0f; int k = *(int*)(\u0026amp;f), j; for (j = 31; j \u0026gt;= 0; j--) printf(\u0026#34;%d\u0026#34;, (k \u0026gt;\u0026gt; j) \u0026amp; mask); return 0; } 网络：https://www.zhihu.com/question/457946470 结果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ai #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; void print_float_bits(float f) { // 1. 将 f 的二进制表示转为 uint32_t uint32_t u = *((uint32_t*)\u0026amp;f); // 2. 分别提取符号位(1 bit)、指数位(8 bits)、尾数位(23 bits) // 并打印每一位 // 符号位: bit 31 // 指数位: bit 30~23 // 尾数位: bit 22~0 printf(\u0026#34;符号位(1): \u0026#34;); printf(\u0026#34;%d\u0026#34;, (u \u0026gt;\u0026gt; 31) \u0026amp; 1); printf(\u0026#34;\\n指数位(8): \u0026#34;); for (int i = 30; i \u0026gt;= 23; i--) { printf(\u0026#34;%d\u0026#34;, (u \u0026gt;\u0026gt; i) \u0026amp; 1); } printf(\u0026#34;\\n尾数位(23): \u0026#34;); for (int i = 22; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, (u \u0026gt;\u0026gt; i) \u0026amp; 1); } printf(\u0026#34;\\n\u0026#34;); } int main() { print_float_bits(1.0f); return 0; } 结果：\n","date":"2025-11-09T00:00:00Z","image":"http://localhost:1313/p/11-09/bj_hu_126ab62073b40467.jpg","permalink":"http://localhost:1313/p/11-09/","title":"11-09 位运算"},{"content":"（6）：联合体 联合体（UNION）定义 “同一段内存”，改变其中一个变量，别的变量可能会受影响\n代码定义形式 ![union dingyi](union dingyi.png)\n红色是标准的联合体定义方式，而且在应用中非常常见\n示例\n前面四个字节，i和s重叠，为i赋值的时候，其实就是覆盖\n为s赋值的时候，i的值也会被破坏，他们同时存在，但是值是否存在不知道\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef union _foo { char s[20]; int i; }foo; int main() { foo a; a.i = 100; printf(\u0026#34;a.i:%d,a.s:%s\\n\u0026#34;, a.i, a.s); strcpy(a.s, \u0026#34;hello world!\u0026#34;); printf(\u0026#34;a.i:%d,a.s:%s\\n\u0026#34;, a.i, a.s); printf(\u0026#34;\u0026amp;a.i:%p,\u0026amp;a.s%p\\n\u0026#34;, \u0026amp;a.i, \u0026amp;a.s); printf(\u0026#34;sizeof(a)=%d\\n\u0026#34;, sizeof(a)); return 0; } UNION的性质 结构体和联合体的区别 ![jiegoutihei](jiegoutihe lianheti.png)\n可以互相包含 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef union _demo1 { int a; struct { int b; char c; }s; float f; }demo1,*pdemo1; typedef struct _demo2 { union { int a; char b; }c; int d; }demo2,*pdemo2; int main() { demo1 dm1; demo2 dm2; dm1.a = 100; printf(\u0026#34;dm1.s.b:%d\\n\u0026#34;, dm1.s.b); printf(\u0026#34;dm1.f:%.2f\\n\u0026#34;, dm1.f); dm2.c.a = 0x12; dm2.d = 0x64; printf(\u0026#34;dm2.d:%d,dn2.c.a:%d\\n\u0026#34;,dm2.d,dm2.c.a); dm2.c.b = \u0026#39;A\u0026#39;; printf(\u0026#34;dm2.d:%d,dn2.c.a:%d\\n\u0026#34;, dm2.d, dm2.c.a); return 0; } DEMO 用union判断存储顺序 作业： 1 2 3 4 5 6 7 1. typedef union _b { char a; int b; float c; }b,*pb; 2.创建一个联合体，存入int整型和char字符指针，整型占四个字节，指针占一个字节，因为两个变量在同一段内存中，并且指针只指向了了一个小部分，然后看指针的输出值来判断是是低位还是高位\n3.根据联合体中包含的最大的基本类型计算，为最大基本类型的倍数\n4.联合体共享一段内存，修改其中任意一个变量会对其他变量造成影响，一般一次只使用一个变量\n结构体可以使用多个变量，变量之间一般不会互相影响\n（6）：枚举类型（enum） 定义 是一种基本类型\n逗号分隔，第一个值如果不指定，默认是0\n中途可以指定，中途不能和前面设定好的值重复\n例子\n上述定义，都是枚举类型的变量，变量不能超出这个范围\n不能再对所定义的枚举常量进行赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef enum _WINVERSION { WIN2000, WINXP, VISTA, WIN7, WIN8 }WINVERSION; int main() { WINVERSION winos = 3; switch (winos) { case WINXP: printf(\u0026#34;the os is winxp\\n\u0026#34;); break; case WIN7: printf(\u0026#34;the os is win7\\n\u0026#34;); break; case WIN8: printf(\u0026#34;the os is win8\\n\u0026#34;); break; default: printf(\u0026#34;unkonwn windows os\u0026#34;) break; } return 0; } sizeof 枚举类型 1 2 3 4 5 printf(\u0026#34;sizeof(WINVERSION):%d,sizeof(WIN8):%d\u0026#34;, sizeof(WINVERSION), sizeof(WIN8)); 长度都是一样的，枚举类型的底层应该是int，都是四个字节 软工中的使用 作业 1 2 3 4 5 6 7 8 9 10 1.typedef enum _day { monday, tuesday, wedensday, thursday, friday, saturday, sunday }day,*pday; 2.4个字节\n3.枚举类型是非构建类型，是基础类型的一种\n4.只能取所构建的类型中所定义的值。所构建的值一般是从0开始排列往后依次加1\n","date":"2025-11-08T00:00:00Z","image":"http://localhost:1313/p/11-08/bj_hu_76afbcb97f404dc7.jpg","permalink":"http://localhost:1313/p/11-08/","title":"11-08 联合体"},{"content":"（2）：结构体中的指针与数组 三种不同结构体定义示意图 左：\n设定数组64字节的长度，则考生的名字不能超过64个字节，而考生的名字没有达到64字节，就会出现空间的浪费\n中：\n字符指针，单独指派内存\n可以根据所填入字符串大小来分配内存，不会造成内存的浪费，但是存放的地方不连续，如果要做拷贝，需要单独的进行拷贝\n右：\nname数组中有一个元素，但是一个元素的空间，是可以变长的，这样既能满足空间不浪费，还能够连续便于拷贝\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef struct _info1 { int value; char name[64]; }info1,*pinfo1; typedef struct _info2 { int value; char *name; }info2, *pinfo2; typedef struct _info3 { int value; size_t length; char name[1]; }info3, *pinfo3; int main() { info1* pi1 = (info1*)malloc(sizeof(info1)); if (pi1 == NULL) { goto err; } memset(pi1, 0, sizeof(info1)); pi1-\u0026gt;value = 78; strcpy_s(pi1-\u0026gt;name, 64, \u0026#34;lucy\u0026#34;); info2* pi2 = (info2*)malloc(sizeof(info2)); if (pi2 == NULL) { goto err; } pi2-\u0026gt;value = 78; size_t len = strlen(\u0026#34;lucy\u0026#34;) + 1; pi2-\u0026gt;name = (char*)malloc(len); if (pi2 == NULL) { goto err; } memset(pi2-\u0026gt;name, 0, len); strcpy_s(pi2-\u0026gt;name, len, \u0026#34;lucy\u0026#34;); info3* pi3=(info3*)malloc(sizeof(info3) + strlen(\u0026#34;lucy\u0026#34;) + 1 - 1); if (pi3 == NULL) { goto err; } memset(pi3, 0, sizeof(info3) + strlen(\u0026#34;lucy\u0026#34;) + 1 - 1); pi3-\u0026gt;value = 78; pi3-\u0026gt;length = strlen(\u0026#34;lucy\u0026#34;) + 1; strcpy_s(pi3-\u0026gt;name, pi3-\u0026gt;length, \u0026#34;lucy\u0026#34;); printf(\u0026#34;1:score:%d,name:%s\\n\u0026#34;, pi1-\u0026gt;value, pi1-\u0026gt;name); printf(\u0026#34;2:score:%d,name:%s\\n\u0026#34;, pi2-\u0026gt;value, pi2-\u0026gt;name); printf(\u0026#34;3:score:%d,name:%s\\n\u0026#34;, pi3-\u0026gt;value, pi3-\u0026gt;name); err: if (pi1) free(pi1); if (pi2-\u0026gt;name) free(pi2-\u0026gt;name); if (pi2) free(pi2); if (pi3) free(pi3); return 0; } 作业： 1.用malloc函数为指针在堆上分配内存，然后检验指针是否指向NULL，如果不是就使用memset进行初始化\n2.如上述代码。\n语言练习： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 语言练习1： void inputArray(int *arr, int n); // 用于从键盘给数组输入n个整数。 提示：使用指针或下标arr[i]均可。 void printArray(int *arr, int n); // 用于打印数组的所有元素。 int findMax(int *arr, int n); // 用于找出并返回数组中的最大值。 在main函数中： 定义一个长度为5的整型数组。 依次调用 inputArray, printArray, findMax，并打印出最大值。 第一次： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void Inputarray(int* arr, int n) { printf(\u0026#34;输入\u0026#39;n\u0026#39;个数字：\u0026#34;); scanf((char*)\u0026#34;%s\u0026#34;,\u0026amp;arr); return arr[n]; } void Printarray(int* arr, int n) { for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d\u0026#34;, arr[i]); } return 0; } int findMax(int* arr, int n) { int max = arr[0]; for (int i = 0; i \u0026lt; n; i++) { if (max \u0026lt; arr[i]) { max = arr[i]; }\t} return max; } int main() { int arr[5]; Inputarrat(arr, 5); printf(\u0026#34;%d\u0026#34;, Printarray(arr, 5)); int max = findMax(arr, 5); printf(\u0026#34;%d\u0026#34;, max); return 0; } 检测错误： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void Inputarray(int* arr, int n) { for (int i=0; i \u0026lt; n; i++) { printf(\u0026#34;输入%d个数字：\u0026#34;,n); scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); } } void Printarray(int* arr, int n) { for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } } int findMax(int* arr, int n) { int max = arr[0]; for (int i = 1; i \u0026lt; n; i++) { if (max \u0026lt; arr[i]) { max = arr[i]; }\t} return max; } int main() { int arr[5]; Inputarray(arr, 5); Printarray(arr, 5); int max = findMax(arr, 5); printf(\u0026#34;输入数组中最大的数为：%d\u0026#34;, max); return 0; } error1： void函数，直接对参数进行操作不返回值，清楚函数实现的参数是否需要返回值\nscanf的取值参数，应该用循环依次取值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 任务二：指针与字符串（巩固） 目标： 巩固指针操作，理解字符串（字符数组）。 要求： 不使用标准库函数（如strlen, strcpy），自己实现以下两个函数： int my_strlen(const char *str); // 计算字符串的长度（不包含结尾的‘\\0\u0026#39;）。 提示：用一个指针遍历，直到遇到‘\\0’。 void my_strcpy(char *dest, const char *src); // 将源字符串src复制到目标字符串dest。 提示：用循环逐个字符复制，最后别忘了在dest末尾加上‘\\0’。 在main函数中： 定义一个源字符串 char src[] = \u0026#34;Hello, C!\u0026#34;; 定义一个足够大的目标字符串数组 char dest[20]; 调用你的函数进行复制和计算长度，并打印结果。 思考： const char *src 中的 const 有什么用？（它防止你意外修改源字符串，是一个好习惯）。 如果 dest 的空间比 src 小，会发生什么？（这就是C语言需要程序员自己小心的地方，会“缓冲区溢出”，非常危险）。 第一次： #include \u0026lt;stdio.h\u0026gt; int my_strlen(const char* str) { char* p = str[0]; int tmp = 0; if (*p != \u0026#39;\\0\u0026#39;) { tmp++; p++; } else { printf(\u0026#34;字符串的长度：%d\u0026#34;, tmp); } return tmp; } void my_strcpy(char* det, const char* src) { if (my_strlen(det) \u0026lt; my_strlen(src)) { printf(\u0026#34;新数组长度小于原数组，无法拷贝\u0026#34;); } for (int i = 0; i \u0026lt; my_strlen(src); i++) { det[i] = src[i]; } } int main() { char src[] = \u0026#34;hello,C!\u0026#34;; printf(\u0026#34;%d\u0026#34;, my_strlen(src)); char det[20] = { 0 }; my_strcpy(det, src); for (int i = 0; i \u0026lt; my_strlen(src); i++) { printf(\u0026#34;%c\u0026#34;,src[i]); } return 0; } 修正： #include \u0026lt;stdio.h\u0026gt; int my_strlen(const char* str) { const char *p=str; int tmp = 0; while (*p != \u0026#39;\\0\u0026#39;) { tmp++; p++; } return tmp; } void my_strcpy(char* det, const char* src) { int len1 = my_strlen(src); if (30\u0026lt; my_strlen(src)) { printf(\u0026#34;新数组长度小于原数组，无法拷贝\u0026#34;); } for (int i = 0; i \u0026lt; len1; i++) { det[i] = src[i]; } det[len1] = \u0026#39;\\0\u0026#39;; } int main() { char src[] = \u0026#34;hello,C!\u0026#34;; printf(\u0026#34;字符串长度：%d\\n\u0026#34;, my_strlen(src)); char det[30] = { 0 }; my_strcpy(det, src); for (int i = 0; i \u0026lt; my_strlen(src); i++) { printf(\u0026#34;%c\u0026#34;,src[i]); } return 0; } error2: char* p = str[0] 类型错误，应该是 const char* p = str\n逻辑错误：需要用循环遍历整个字符串，不是只检查第一个字符\n用while循环持续检查直到遇到\u0026rsquo;\\0'\nmy_strlen(det)计算的是det当前字符串内容的长度，不是数组总容量\n在函数传参中的数组会退化为指针，在比较数组容量时要么额外传递容量参数，要么使用设定的常量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 任务3： 任务三：综合应用——数组修改器（挑战） 目标： 综合运用所有概念，解决一个稍微复杂的问题。 要求： 编写一个函数，其原型为： int removeElement(int *nums, int numsSize, int val); 功能： 在数组 nums 中，原地移除所有值等于 val 的元素。元素的顺序可以改变。函数返回移除后数组的新长度。 原地移除 意味着你不能申请新数组，必须在原数组上操作。 示例： 输入：nums = [3, 2, 2, 3], val = 3 你的函数操作后，数组可能变为 [2, 2, ...]，并返回新长度 2。 实现思路（“双指针”法，非常重要！）： 定义一个“慢指针” slow = 0，它指向下一个“有效元素”该存放的位置。 用一个“快指针” fast 从0到numsSize-1遍历整个数组。 如果 nums[fast] != val，说明这个元素应该保留。就把它复制到 nums[slow] 的位置，然后 slow 向前移动一位。 遍历结束后，slow 的值就是新数组的长度。 在main函数中测试你的代码。 第一次： #include \u0026lt;stdio.h\u0026gt; int removeElement(int* nums, int numSize, int val) { char* slow = 0; for (int* fast = nums; fast \u0026lt; numSize; fast++) { if (nums[fast] != val) { nums[slow] = nums[fast]; slow++; } } for (int i = 0; i \u0026lt; numSize; i++) { printf(\u0026#34;%d\u0026#34;, nums[i]); } } 修正： #include \u0026lt;stdio.h\u0026gt; int removeElement(int* nums, int numSize, int val) { int* slow = nums; for (int* fast = nums; fast \u0026lt; nums+numSize; fast++) { if (*fast != val) { *slow = *fast; slow++; } } for (int i = 0; i \u0026lt; numSize; i++) { printf(\u0026#34;%d \u0026#34;, nums[i]); } return slow-nums; } int main() { int a[5] = { 2,3,4,3,2 }; printf(\u0026#34;数组长度：%d\u0026#34;, removeElement(a, 5, 3)); } （3）：结构体浅拷贝深拷贝 结构体赋值时的拷贝 是否能像图中一样，s1赋值之后，直接用s1来拷贝到其他结构体\n浅拷贝和深拷贝 左，如果结构体中不包含指针变量，那么s2=s1是正确的\n右，结构体中的拷贝默认是浅拷贝，在赋值的同时也把指针所指向的的地址一起拷贝过去，而且s2中还未给指针分配内存，会导致s1和s2共享分配的100个字节的内存\n如果free(s1.p)，那么s2.p就变成了野指针，指向了一个无效的内存地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; typedef struct _struct1 { int a; char c; }struct1,*pstruct1; typedef struct _struct2 { int a; char *p; }struct2, *pstruct2; int main() { struct1 s1 = { 100,\u0026#39;A\u0026#39; }; struct1 s2=s1; printf(\u0026#34;s1:a:%d,c:%c\\n\u0026#34;, s1.a, s1.c); printf(\u0026#34;s2:a:%d,c:%c\\n\u0026#34;, s2.a, s2.c); struct2 s3; s3.a = 100; s3.p = (char*)malloc(16); if(s3.p == NULL) { return -1; } memset(s3.p, 0, 16); strcpy_s(s3.p, 16, \u0026#34;hello world\u0026#34;); struct2 s4=s3; printf(\u0026#34;s3:a:%d,p:%s\\n\u0026#34;, s3.a, s3.p); printf(\u0026#34;s4:a:%d,p:%s\\n\u0026#34;, s4.a, s4.p); free(s3.p); printf(\u0026#34;s4:a:%d,p:%s\\n\u0026#34;, s4.a, s4.p); return 0; } debug\n深拷贝的实现 需要程序员手动去分配内存\n图解 互有瑕疵\ncopy-on-writr 作业 1.浅拷贝，将对应的值和内存地址直接拷贝到对应的变量当中，也就是，两个指针指向同一个内存地址，共享这一个内存地址\n深拷贝，在拷贝指针中分配新的内存，然后将被拷贝指针中的值拷贝到新地址，原指针的改动对拷贝后的指针无影响\n2.浅拷贝对指针来说是两个指针指向同一个内存地址，如果原指针所在结构体运行完成后释放自己在堆上分配的内存，会导致拷贝后的指针变成野指针\n3.c语言中默认是浅拷贝\n4.拷贝时，先给拷贝指针分配一个内存，然后再对齐进行拷贝\n5.写时拷贝，是一种利用\u0026quot;节点\u0026quot;的拷贝方式,多个指针指向一个节点，然后节点再指向一个内存地址，节点用于记录所指向的指针的个数，当还有指针指向的时候，避免释放内存导致其他指针变为野指针\n另外，写实拷贝还能按某一指针需要修改内存地址中的数据并开辟一个新的地址来存放数据\n（4）：结构体应用 结构体数组 结构体数组的初始化与遍历\n结构体指针数组\n结构体做函数参数 传指针\n传值\n判断两个同学成绩\n作业 1.引用传参，c++中。c语言中指针的效率大于传值\n2.链表待定\n（5）：sizeof计算结构体长度 计算类型或者变量的长度，计算的是所占字节的长度\n基本类型 utf16编码，utf32编码\nlong ：win 都站4个字节，linux x64占8个字节\n结构体对齐-自然对齐 成员一样，位置不太一样\n如果是基本成员，存放地点就必须是成员类型的整数倍\nchar，可以存放在任何地址，地址都是1的整数倍\nshort，0 2 4 6 8\n结构体中包含结构体，按照结构体中子成员中最大的基本类型的整数倍\n最终结果成都必须为sizeof基本类型的整数倍，比如第一个a结构体，计算出来的结果如果是20，需要往后填充4个字节来满足必须要是基本类型double=8的整数倍，也就是24个字节\n一般从零地址开始存，这样计算存完即是结构体所占内存大小\n作用，保证cpu在一个时钟周期内把这些数据拿到，提高存取效率\npragma pack(n) ![pragma pack](C:/blog/my-blog/content/post/11-2025/11.08.2025/pragma pack.png)\npragma示例\n定义结构对齐\n![pragma pack1](C:/blog/my-blog/content/post/11-2025/11.08.2025/pragma pack1.png)\n如果按照1字节对齐，那就不用空格，全部加起来即是字节大小\n栈空间对齐 直接按4字节对齐\n在print函数中float会扩充成double字节。\nx64平台填充\nfloat有专门的寄存器，前四个参数存入寄存器，在栈上还会给这四个参数预留空间\n作业 1.sizeof(s1)=8 short 两个字节，long 四个字节 ，long为4，需要为4的倍数，所以最后为8\nsizeof(s2)= 24 char 1个字节， s1 有8个字节，long long 类有8个字节，结果17，因为要为8的倍数，所以为24\nsizeof(s3)= char 1个字节，short两个字节，long 4个字节，longlong 8个字节 16个字节\n2.sizeof(double) = 8 sizeof (long) = 4 sizeof(char) = 1\nsizeof(a) = 24 sizeof(b)=16\n","date":"2025-11-07T00:00:00Z","image":"http://localhost:1313/p/11-07/bj_hu_fe7103833b33bbf6.jpg","permalink":"http://localhost:1313/p/11-07/","title":"11-07 结构体指针，应用"},{"content":"第十五课-结构体 （1）：结构体定义与使用 基本类型与构建类型 结构体定义 一般形式\n第三种没有结构体名称，不能在用来定义新的变量名，只能在这起到临时的变量名1，变量名2的作用\n初始化定义，初始化与成员访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; typedef struct _student { int id; int age; char name[20]; char sex; float score; } student, *pstudent; int main() { student s1 = { 1001,19,\u0026#34;tom\u0026#34;,\u0026#39;m\u0026#39;,80.5 }; student s2 = { 0 }; s2.id = 1001; s2.age = 19; strcpy_s(s2.name, 20, \u0026#34;tom\u0026#34;);//名字是数组，需要用stucpy拷贝进去 s2.sex = \u0026#39;M\u0026#39;; s2.score = 99.5f; printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, s1.id,s1.age,s1.name,s1.sex,s1.score); printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, s2.id,s2.age,s2.name,s2.sex,s2.score); return 0; } 结构体的指针访问：-\u0026gt; 1 2 3 4 5 student* ps1 = \u0026amp;s1; pstudent ps2 = \u0026amp;s2;//pstudent = student * printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, ps1-\u0026gt;id, ps1-\u0026gt;age, ps1-\u0026gt;name, ps1-\u0026gt;sex, ps1-\u0026gt;score); printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, ps2-\u0026gt;id, ps2-\u0026gt;age, ps2-\u0026gt;name, ps2-\u0026gt;sex, ps2-\u0026gt;score); 注意，长度，加减\n1 2 3 4 5 6 //ps1+1 //sizeof(ps1) 指针大小，根据平台 ,sizeof(*ps1) = sizeof(student) printf(\u0026#34;sizeof(ps1)=%d,sizeof(*ps1)=%d,sizeof(student)=%d\\n\u0026#34;, sizeof(ps1),sizeof(*ps1),sizeof(student)); printf(\u0026#34;ps1:%p,ps1+1:%p\\n\u0026#34;, ps1, ps1 + 1); 在堆上分配内存来表示结构体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 student* ps3 = (student*)malloc(sizeof(student)); if (ps3 == NULL) { return -1; } memset(ps3, 0, sizeof(student)); ps3-\u0026gt;id = 25; ps3-\u0026gt;age = 21; strcpy_s(ps3-\u0026gt;name, 20, \u0026#34;leilei\u0026#34;); ps3-\u0026gt;sex = \u0026#39;m\u0026#39;; ps3-\u0026gt;score = 86.5f; printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, ps3-\u0026gt;id, ps3-\u0026gt;age, ps3-\u0026gt;name, ps3-\u0026gt;sex, ps3-\u0026gt;score); free(ps3); ps3 = NULL; 注意，在free之后，ps3指针依旧指向之前的地址，如果后续还要使用ps3指针，需要重新设为null，否是使用则是垃圾值\n运算符 *pstdt-\u0026gt;sex 第一个，箭头优先级高，箭头指向运算之后，所表示的值不是一个地址，无法解引用\n*pstdt-\u0026gt;name 依旧是箭头优先级高，取出了name，name是数组名，代表数组指针，可以解引用\n*pstdt.sex 点号优先级高，指针没有点号这个运算\n(*pstdt).sex 解引用指针，解出来是结构体的名字\n结构体中的结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; typedef struct _date { int year; int month; int day; }date, *pdate; typedef struct _student { int id; int age; char name[20]; char sex; float score; date birthday; } student, *pstudent; int main() { student s1 = { 1001,19,\u0026#34;tom\u0026#34;,\u0026#39;m\u0026#39;,80.5f,{1995,2,5} }; student s2 = { 0 }; s2.id = 1001; s2.age = 19; strcpy_s(s2.name, 20, \u0026#34;tom\u0026#34;);//名字是数组，需要用stucpy拷贝进去 s2.sex = \u0026#39;M\u0026#39;; s2.score = 99.5f; s2.birthday.year = 1997; s2.birthday.month = 6; s2.birthday.day = 21; printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f,year:%d,month:%d,day:%d\\n\u0026#34;, s1.id,s1.age,s1.name,s1.sex,s1.score, s2.birthday.year, s2.birthday.month, s2.birthday.day); printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, s2.id,s2.age,s2.name,s2.sex,s2.score); student* ps1 = \u0026amp;s1; pstudent ps2 = \u0026amp;s2;//pstudent = student * printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, ps1-\u0026gt;id, ps1-\u0026gt;age, ps1-\u0026gt;name, ps1-\u0026gt;sex, ps1-\u0026gt;score); printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, ps2-\u0026gt;id, ps2-\u0026gt;age, ps2-\u0026gt;name, ps2-\u0026gt;sex, ps2-\u0026gt;score); //ps1+1 //sizeof(ps1) 指针大小，根据平台 ,sizeof(*ps1) = sizeof(student) printf(\u0026#34;sizeof(ps1)=%d,sizeof(*ps1)=%d,sizeof(student)=%d\\n\u0026#34;, sizeof(ps1),sizeof(*ps1),sizeof(student)); printf(\u0026#34;ps1:%p,ps1+1:%p\\n\u0026#34;, ps1, ps1 + 1); printf(\u0026#34;sizeof(student *):%d\\n\u0026#34;, sizeof(student*)); student* ps3 = (student*)malloc(sizeof(student)); if (ps3 == NULL) { return -1; } memset(ps3, 0, sizeof(student)); ps3-\u0026gt;id = 25; ps3-\u0026gt;age = 21; strcpy_s(ps3-\u0026gt;name, 20, \u0026#34;leilei\u0026#34;); ps3-\u0026gt;sex = \u0026#39;m\u0026#39;; ps3-\u0026gt;score = 86.5f; ps3-\u0026gt;birthday.year=1996; ps3-\u0026gt;birthday.month = 8; ps3-\u0026gt;birthday.day = 1; printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f,year:%d,month:%d,day:%d\\n\u0026#34;, ps3-\u0026gt;id, ps3-\u0026gt;age, ps3-\u0026gt;name, ps3-\u0026gt;sex, ps3-\u0026gt;score,ps3-\u0026gt;birthday.year, ps3-\u0026gt;birthday.month, ps3-\u0026gt;birthday.day); free(ps3); ps3 = NULL; return 0; } 结构体中的指针 结构体中有指针必须要为这个指针赋值一个有效的内存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; typedef struct _student { int id; int age; char* name;//char name[20] 有指针的话，需要专门为指针指定内存 char sex; float score; }student, * pstudent; int main() { student s1 = { 11,21,\u0026#34;tom\u0026#34;,\u0026#39;m\u0026#39;,97.5f };//tom存储在静态常量区，name可以指向 student s2 = { 0 }; s2.id = 15; s2.age = 22; s2.name = (char*)malloc(20);//指向了堆上的内存 if (s2.name == NULL) { return -1; } memset(s2.name, 0, 20); strcpy_s(s2.name,20,\u0026#34;lily\u0026#34;); s2.sex = \u0026#39;F\u0026#39;; s2.score = 94.5f; student* s3 = (student*)malloc(sizeof(student)); if (s3 == NULL) { free(s2.name); return -1; } memset(s3, 0, sizeof(student)); s3-\u0026gt;id=18; s3-\u0026gt;age = 23; s3-\u0026gt;name = (char*)malloc(20); if (s3-\u0026gt;name == NULL) { free(s3); return -1; } memset(s3-\u0026gt;name, 0, 20); strcpy_s(s3-\u0026gt;name, 20, \u0026#34;david\u0026#34;); s3-\u0026gt;sex = \u0026#39;M\u0026#39;; s3-\u0026gt;score = 87.5f; printf(\u0026#34;s1:name:%s\\n\u0026#34;, s1.name); printf(\u0026#34;s2:name:%s\\n\u0026#34;, s2.name); printf(\u0026#34;s3:name:%s\\n\u0026#34;, s3-\u0026gt;name); free(s2.name); s2.name = NULL; free(s3-\u0026gt;name); s3-\u0026gt;name = NULL; free(s3); s3 = NULL; return 0; } 赋值要注意进行深拷贝\n左边，链表节点 右边，二叉树\n作业 1.\n1 2 3 4 5 typedef struct _date { int value; struct _date *next }date,*pdate; 2.\n.运算符加载结构体名称后面，用来访问非指针结构体的内部数据\n-\u0026gt;用来放在指针结构体名称后，访问结构体内数据\n3.结构体在函数中被调用的时候就是在栈上运行\n而在堆上运行需要手动在堆上分配内存\n4.链表看不懂。。。。\n","date":"2025-11-06T00:00:00Z","image":"http://localhost:1313/p/11-06/bj_hu_72b5cc32cb3d5d04.jpg","permalink":"http://localhost:1313/p/11-06/","title":"11-06 结构体定义与使用"},{"content":"第十四课-内存管理 物理内存，cpu根据物理地址在物理内存中存储数据\n（1）：内存分类与寻址 R0，内核空间，最高权限。R3，进程空间\n加载程序，就是把数据加载到程序的进程空间中部署运行\n程序内存布局 data 初始化的全局变量，静态变量\nrdata 常量\n堆和栈的区别 堆上的内存需要释放，否则会造成内存些泄露\n栈：自动分配内存，内存大小相对较小且固定，后进先出\n堆：手动分配内存，可以动态调整大小，大小受限于计算机\n指针函数不能返回栈上的地址，函数执行完了之后源地址已经销毁了\n内存碎片：存在着内存，但是无法分配到空闲的内存\n进程的地址空间是私有的，可能拥有相同的，类似的逻辑地址\n寻址模式 分段：用起始地址加偏移地址来表示位置 段的起始地址，低4位设置成零用来让16位寄存器表示段地址\n两个寄存器，一个寄存器中拿到起始地址，然后左移四位，加上段的偏移\n左移四位，低四位是0，未存放，也就是存放时右移四位\ncs 代码段起始地址， ds 数据段起始地址\n扁平模型 不需要设置起始地址，能够直接用一个寄存器寻址整个地址空间\n实模式，段寄存器中的地址加偏移能得到物理地址\n保护模式，地址使用虚拟地址，通过页表段表来映射得到物理地址\n保护模式中无需参与计算\n段选择符加段表和偏移量得到线性地址\nCR3寄存器，获得页目录，确定页表项，通过偏移找到物理地址\n作业 1.底层是静态区，存放了变量，数据，常量；往上是代码区，存放源代码；再往上是堆，一个手动管理的内存池；然后最后是栈，调用函数时存放变量的区域\n2.程序内存分为四个区域，内核区，两个非法区，进程区。内核区和进程区占4GB，内核区的权限最高，进程区R3的权限，非法区域用来隔绝两个区域的相互影响，只占64kb\n3.栈是函数调用时的临时存储区，由系统自动分配，后进先出，效率较高\n堆是由程序员手动分配的内存池，大小由计算机硬件决定，调用灵活，但是效率稍低\n4.分段模型是在计算机寄存器只有16位用来寻址的方法，计算机地址总线有20位，寄存器无法完全存储，于是采用分段模型的方式来存储，将20位总内存大小1m的内存分为16个64kb的段，然后规定最后四位都为0的方式，省略四位零，然后用两个寄存器，一个用来表示起始地址，另一个用来表示偏移量，这样用来将逻辑地址转换为物理地址\n平坦模型，则是计算机发展之后，一个寄存器能够完成将逻辑地址转换为物理地址之后发展出来的方式，能用一个寄存器去遍历所有的地址线\n5.实模式，没有保护，用分段模型构建的物理地址，可以读写任何内存位置\n保护模式，需要页表将虚拟地址转换为物理地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 直接物理内存访问：程序看到的地址就是真实的物理内存地址。一个程序可以读写任何内存位置，包括操作系统的核心代码。 无权限分级：没有“内核态”和“用户态”之分。所有代码都以最高权限运行。 内存空间小：由于16位架构和寻址方式限制，最多只能访问 1MB 内存。 虚拟内存：程序运行在独立的“虚拟地址空间”中，由CPU和操作系统负责映射到真实的物理内存。程序A无法直接访问程序B的内存。 权限分级：通常有4个特权级（Ring 0 ~ Ring 3）。操作系统内核运行在最高特权级（Ring 0），应用程序运行在最低特权级（Ring 3）。应用程序想执行特权指令（如操作硬件）会被CPU拒绝。 内存分段与分页：通过复杂的描述符表和页表来管理内存访问，提供了隔离和保护机制。 支持大内存：可以访问远超过1MB的物理和虚拟内存（如4GB甚至更多）。 （2）：内存分配 静态区，代码区，栈，堆，如何编译一个10m的程序\n全局数组，全局变量， 必然存放在静态区\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int g_iNum = 10; char g_Aarrat[] = \u0026#34;hello worlf\u0026#34;; int main(void) { int a = 123; int b = 127; char buf[128] = { 0 };//栈 char* p = (char*)malloc(256);//堆上，需要内存分配函数，nalloc是一个函数名，返回的变量名是一个void类型*指针 free(p == NULL); if (p == NULL) { return -1; } memset(p, 0, 256);//内存初始化为0 strcpy_s(p, 256, \u0026#34;hello world\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, p); free(p);//释放，把值重新放入到内存去，但是指针指向未必其余的 p = NULL; return 0; } 如果一个数组里面全是0，编译器不会打开数组将值存放在内存，可以压缩成一个存放\n比如 g_data区有10*1024*1024的数组，全是0即被压缩，如果有存放字符，就会开辟一个区域存放\nmalloc/calloc/realloc 作业 1.静态区存放全局变量，静态变量，从静态区分配内存只能从最开始的声明变量，内存由声明类型决定，不由程序员决定\n2.栈的内存是在函数调用时由机器分配使用，根据所写函数的声明类型定义来决定，不受程序员控制\n3.从堆上分配内存需要使用特定的函数，比如malloc，calloc，用来在堆上划取一部分内存来使用\n4.栈是函数调用时的临时存储区，由系统自动分配，后进先出，效率较高\n堆是由程序员手动分配的内存池，大小由计算机硬件决定，调用灵活，但是效率稍低\n（3）：内存泄漏预防与检测 内存泄漏 忘记了将调用的堆的内存释放，即内存泄漏\n系统内存耗尽后，系统会将磁盘的一部分用来存储内存的数据，导致系统性能大幅下降\n图中传参的代码，传的是值，而函数中定义的是指针，调用时并没有真正传入，但是堆上的内存会分配，导致程序崩溃，释放内存也没有用\nAPI不正确调用造成内存泄漏 预防内存泄漏 -1 预防内存泄漏-2 集中处理内存泄漏\n预防内存泄漏-3 预防内存泄漏-4 内存泄漏之后的检测 realloc会检查原来内存的容量，不够会开辟新的内存地址\n作业 1.写代码的时候，声明函数之后跟上释放，让划取和释放成对出现\n或者用goto集中处理所有的堆\n用内存使用计数，使用时+1，释放时-1，最后看是否还有+1\n2.用容器封存指向所划取堆的首地址的指针，在调用完成后检查是否有未释放的指针留存\n","date":"2025-11-05T00:00:00Z","image":"http://localhost:1313/p/11-05/bj_hu_fcb7d9e565857aa3.jpg","permalink":"http://localhost:1313/p/11-05/","title":"11-05 内存管理"},{"content":"（6）：二级指针 二级指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main(void) { int a = 10; int* p = \u0026amp;a; int** pp = \u0026amp;p; printf(\u0026#34;a:%d\\n\u0026#34;, a);//10 printf(\u0026#34;\u0026amp;a:%p\\n\u0026#34;, \u0026amp;a);//addr of a printf(\u0026#34;p:%p\\n\u0026#34;, p);//addr of a printf(\u0026#34;\u0026amp;p:%p\\n\u0026#34;, \u0026amp;p);//addr of p printf(\u0026#34;pp:%p\\n\u0026#34;,pp);//addr of p printf(\u0026#34;*p:%d\\n\u0026#34;,*p);//10 printf(\u0026#34;*pp:%p\\n\u0026#34;, *pp);//p,addr of a printf(\u0026#34;**pp:%d\\n\u0026#34;, **pp);//10 return 0; } 二级指针关系图 应用 分析\nstr是一个指针 ，第一个，我们将str作为一个值传递沟渠，函数拿不到这个值，必须串指针的地址，就是用二级指针来保存参数的地址，即\n传参的形式 分析运行结果\n1.\n解答\n作业： 1 2 3 4 5 6 7 8 9 10 1.函数f中，两个变量分别是二级指针**ptr1,指针*ptr2。 定义指针p1=i的地址，p2等于j的地址 然后调用f函数 \u0026amp;p1，也就是取指针p1的地址，作为二级指针**Ptr1；p2，就是j变量的地址作为指针变量导入f函数中 然后int 指针tmp=ptr2 也就是 tmp=ptr2=p2=\u0026amp;j 下一个**ptr1，两次解引用ptr1指针，结果为i，i*10=0，i=0 解ptr2指针，结果为j，j*10=200，j=200 ptr2 = *ptr1，解引用ptr1，即二级指针中存放的是p1的地址，解出来p1存放的i的地址，也就是ptr2 = \u0026amp;i *ptr1 = tmp 就是p1 = p2 = \u0026amp;j 所以，i=0，j=200，p1=p2=\u0026amp;j 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 2.问题：调用的getmemory函数中，malloc没有对应的free来清除堆上使用的内存，会造成内存泄漏 void中调用getmemory函数，传值传入的不是地址，定义getmemory的时候设定的指针，也就是需要传入地址， 所以程序会在调用函数的时候崩溃，还可能会造成内存泄露 修改： void getmemory(char *p) { p=(char*)malloc(100); free(p) } void test(char *s) { char *str = NULL; getmemory(\u0026amp;str); strcpy(str,s); printf(str); } ","date":"2025-11-04T00:00:00Z","image":"http://localhost:1313/p/11-04/bj_hu_135b6231849dc18.jpg","permalink":"http://localhost:1313/p/11-04/","title":"11-04 二级指针"},{"content":"第十三课-指针 （1）：指针定义与使用 变量在内存中的地址 \u0026amp;取值运算符\n指针定义 指针也是变量，指针也有类型，指针存放的值是内存地址\n指针字节就是内存地址的长度\n1 2 3 4 5 6 7 8 9 int main() { int i = 1; int* p = \u0026amp;i; printf(\u0026#34;p=%p,\u0026amp;i=%p,sizeof(p):%d\\n\u0026#34;, p, \u0026amp;i, sizeof(p)); return 0; } 指针的定义与初始化形式 初始化：1.指向某个变量的地址 2.指向一个分配的内存或者字符串常量 3.指向NULL\n1 2 int i,*p；定义了一个整型i和整型指针，这里*与int一起 p =\u0026amp;i 野指针，指向随机值 1 2 3 4 5 6 7 8 char *p=(Char*)malloc(100); 在堆上分配了地址，赋值给了一个指针 char *str = \u0026#34;hello world\u0026#34;; 指向的是字符串变量地址 char c=\u0026#39;A\u0026#39;; 一个字符变量\u0026#39;a\u0026#39; char *str = \u0026amp;c; 一个指针str，把c的地址赋值给了str，指向字符变量c char *pch= \u0026amp;c ; 字符指针既可以指向字符串，也可以指向字符变量 赋值给指针的时候，赋值的类型一定要匹配 字符指针赋值给整型指针，需要强制转化 *p：解引用运算符 与指针定义的*不是一个东西 1 2 3 4 5 6 7 int *p1,*p2 中 “*” 是定义指针p1，p2 printf 中*p1 *p2 是解引用符 *p1 == a *p2 == b 对 *p1+1 *p2+2 就是对a，b修改 但是必须要是可写的 a是常量指针，指针的一种形式，指向的数组的首地址 p指向的字符串的首地址 对a和p进行解引用，*a为数组第一个元素，*p为字符串第一个 野指针和NULL都不能被解引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() {\tint a = 100; int b = 10; int arr[10] = { 2,3,4,6,7,8 }; char* s = \u0026#34;hello world\u0026#34;; int* p1 = \u0026amp;a; int* p2 = \u0026amp;b; printf(\u0026#34;*p1=%d,*p2=%d\\n\u0026#34;, *p1, *p2); printf(\u0026#34;a=%d,b=%d\\n\u0026#34;, a, b); *p1 += 1; *p2 += 1; printf(\u0026#34;a=%d,b=%d\\n\u0026#34;, a, b); printf(\u0026#34;*arr:%d\\n\u0026#34;, *arr); printf(\u0026#34;*s:%c\\n\u0026#34;, *s); return 0; } \u0026amp;与* *arr = 100;\r*s = \u0026quot;X\u0026quot;;\r*arr 指向数组第一个元素，可以使用指针修改\n*s指向静态常量区，修改会报错\n\u0026amp;与*互为逆运算：*\u0026amp;与\u0026amp;* *运算符需要和指针联系在一起，a不是指针，所以\u0026amp;*a会报错\n易混淆 指针的赋值与使用 *p2 = *p1 即j = i j和i的值都变为\u0026rsquo;a'\n用双引号直接赋值的字符串是只读的，用数组或malloc创建的字符串是可修改的。\np2=p1 把p1的地址赋值给p2，相当于p2指向了p1的地址\n指针类型与互相转换 少了会导致数据丢失，多了可能会导致破坏其他内存地址。强制转化有可能会导致程序受到影响\n类型不一样宽度就不一样\nvoid *p void *p 没有任何类型，和类型指针不一样\nvoid的指针概念中没有内存长度的概念，拿不到内存长度\n不能用*p来取值，取不了其中的值\nGCC里面的扩展，void默认为1字节\n主要用在函数参数定义的时候，可以接受任何类型的指针的赋值，万能指针型\nvoid赋值成别的类型需要强转，而解引用也需要转换\n一般用在函数的形参位置，不用做任何的强制转换，只是在内部需要转换\n1 2 3 4 void *pv1 = p1 只是对pv1的赋值，类型并未转换，GCC应该可以 sizeof(pv1) 指针本身是变量 sizeof(*pv1) 只是无法解引用 字符指针 sizeof(p)\\sizeog(*p) sizeof(p) 指针对应的长度\nsizeof(*p) 指针对应类型的长度\n4 4 1 4 12 4 1 1\n指针的应用 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdbool.h\u0026gt; bool is_system_little() { int x = 0x1; char* p = (char*)\u0026amp;x; if (*p == 1) return true; else return false; } 作业 作业 1.指针含义：指针是一个存放内存地址的变量.指针长度：长度由所属变量类型决定，char 即1字节，int 即4字节，如果五类型，由所在平台决定，x86即4个字节，x64即8个字节\n2.p是指针时，*p的情况需要做讨论，如果是没有与int之类的声明语句相结合，则为解引用符号，读取指针中存放的地址，如果与声明语句结合，则可能是二级指针\n3.通过char类型的指针指向int 类型的整数1，然后打印指针值，int类型占四个字节，而char指针只有一个字节，会丢失另外三字节的数据，看打印结果是1或者0就能判断是高位还是低位优先。\n4.x86平台是低位优先储存，所以两个指针读取出的数都是ff，p1用的是有符号的字符型，p2是无符号的字符型，而输出的之后又采取转换成10进制输出，\nff转换成2进制应0111 1111 ，10进制是255，但是有符号数中，数的范围是-128~127，所以p1的输出应该是-1，因为补码的127+1整数溢出，p2的输出应该是255\n导入vs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main() { int num = 0x000000ff; char* p1 = (char*)\u0026amp;num; unsigned char* p2 = (unsigned char*)\u0026amp;num; printf(\u0026#34;%lu\\n\u0026#34;, *p1); printf(\u0026#34;%lu\\n\u0026#34;, *p2); return 0; } 第一个结果是随机数，第二个结果是255\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 ai解答 1. 整数提升规则 在C语言中，小于int的类型在表达式计算中会被提升为int： char → int unsigned char → int 2. 具体过程分析 对于 *p1 (有符号char，值0xff = -1)： c *p1 = 0xff // 内存中的字节 // 整数提升（保持值不变）： char -1 → int -1 二进制：11111111 (char) → 11111111 11111111 11111111 11111111 (int) // 提升后的int值：0xFFFFFFFF (-1) 对于 *p2 (无符号char，值0xff = 255)： c *p2 = 0xff // 内存中的字节 // 整数提升（保持值不变）： unsigned char 255 → int 255 二进制：11111111 (uchar) → 00000000 00000000 00000000 11111111 (int) // 提升后的int值：0x000000FF (255) printf的可变参数机制 printf 通过 va_list 从栈上读取参数，它不知道实际传入的类型，只按照格式符解释： c printf(\u0026#34;%lu\\n\u0026#34;, *p1); 栈上实际内容： text | 0xFFFFFFFF | (从*p1提升来的int -1) | 格式字符串地址 | printf的理解： %lu 期望 4/8字节的 unsigned long 但从栈上读取到的是 0xFFFFFFFF (int -1) 类型不匹配 → 未定义行为 ","date":"2025-11-03T00:00:00Z","image":"http://localhost:1313/p/11-03/bj_hu_8e6fd399c3ba5f20.jpg","permalink":"http://localhost:1313/p/11-03/","title":"11-03 指针定义与使用"},{"content":"第十二课-函数 （1）：函数定义与应用 定义 定义形式与调用，调试 输入参数：外部传递给函数\n输出参数：函数计算的结果，可以通过输出方式传递给调用值；也能用return方式返回给调用值\n有的函数即做了输出参数也做了输入参数\n变参函数：函数的参数个数可以变化，比如printf函数在打印的时候，可以打印多个\n函数应用，头文件写法（导出函数和变量） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int myadd(int x, int y)//声明的时候可以不用形参，只加两个类型也可以 { int res; res = x + y; return x + y; } int getmax(int x, int y) { return x \u0026gt; y ? x : y; } bool leep_year(int year) { (year % 4 == 0) \u0026amp;\u0026amp; (year % 100 || year % 400 == 0); } char mytolower(char ch) { if (ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) { ch += \u0026#39;a\u0026#39; - \u0026#39;A\u0026#39;; } return ch; } void swap(int x, int y)//整数进行交换就不需要返回值 { int tmp = x; x = y; y = tmp; } 暂时如此，后续实验出现问题有更改 1.使用bool类型需要包含头文件 这是在myfunc.c里面打的函数，跟main函数不在同一个源文件里 写头文件 1 2 3 4 5 6 7 8 #pragma once #include \u0026lt;stdbool.h\u0026gt; int myadd(int x, int y); //保证头文件项目在编译的时候只被包含一次 int getmax(int x, int y); //然后将刚刚写的函数全部放在里面声明 bool leep_year(int year); //再到源文件里写包含 char mytolower(char ch); //自己写的源文件用\u0026#34;\u0026#34;。引号是从当前目录开始查找 void swap(int x, int y); //而\u0026lt;\u0026gt;是从系统目录开始查找 预编译\n1 2 3 4 5 6 7 8 9 10 #ifndef _MYFUNC_H_ #define _MYFUNC_H_ int myadd(int x, int y); int getmax(int x, int y); bool leep_year(int year); char mytolower(char ch); void swap(int x, int y); #endif swap运行之后函数的值没有发生交换\n形参和实参的区别\n在函数内部完成了形参的交换，但实际上设定的函数实参没有发生改变\n采用的传参方法叫传值，传值是不能改变实参的，传值是将实参的值拷贝到了形参的位置，改变形参并不会改变实参，上述定义的函数都是采用传值的方法运行的\nmain函数参数的使用 例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; int _tmain(int argc, _TCHAR* argv[]) { if (argc != 2) { printf(\u0026#34;Invalid parameters\\n\u0026#34;); return 0; } for (int i = 0; i \u0026lt; argc; i++) { _tprintf(_T(\u0026#34;%s\\n\u0026#34;), argv[i]); } return 0; } exe中--\u0026gt;属性--\u0026gt;调试--\u0026gt;命令参数 argv中，argv[0]永远是我们程序自身，此程序中拿两个参数，即自身和在调试中输入的命令行参数，两个\n函数定义注意事项 功能单一 方便维护，可模块化\n输入输出，设计函数的接口\n局部变量要进行初始化\n严进宽出：严格判断是否合法，长度是否合理，类型是否匹配\nassert 断严\n复杂度 时间短 尽量不分配内存\n边界考虑：特殊情况，考虑所有的情况，大于小于，多了少了，内存是否重叠\n功能测试：调用，测试，不同的测试用语\nreturn不可以返回指向栈内存，栈内存在结束时会被释放\n逆置字符串 定义了函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; void reverse_str(char* str) { int len = 0; char* s = str; while (*s != \u0026#39;\\0\u0026#39;) { s++; len++; } for (int i=0; i \u0026lt; len / 2; i++) { char ch = str[i]; str[i] = str[len - 1 - i]; str[len - 1 - i] = ch; } return str; } int main() { char* str = \u0026#34;hello world\u0026#34;; printf(\u0026#34;str before:%s\\n\u0026#34;, str); reverse_str(str); printf(\u0026#34;str after:%s\\n\u0026#34;, str); return 0; } 改为char str[] = \u0026#34;hello world\u0026#34;; 就不会崩溃，这样是在栈上分配的地址，栈上的地址是可读可写的 在进行逆置字符串的操作，这一段内存必须是可读可写的，上述代码会崩溃\n用指针指向的 “hello world” 是存储在静态常量区是不能读写的\n该函数设计上问题：\n1.没有模块化\n也就是需要把计算字符串长度这一段代码单独弄出来形成一个函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; int mystrlen(const char* str) { int len = 0; char* s =(char *) str; while (*s != \u0026#39;\\0\u0026#39;) { s++; len++; } return len; } void reverse_str(char* str) { int len = mystrlen(str); for (int i=0; i \u0026lt; len / 2; i++) { char ch = str[i]; str[i] = str[len - 1 - i]; str[len - 1 - i] = ch; } return str; } int main() { char str[] = \u0026#34;hello world\u0026#34;; printf(\u0026#34;str before:%s\\n\u0026#34;, str); reverse_str(str); printf(\u0026#34;str after:%s\\n\u0026#34;, str); return 0; } 库函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; int main() { char *filename=\u0026#34;d:\\\\docs\\\\1.doc\u0026#34;; //1.txt 可行，改成1.doc不行，所以打错误代码 int res =remove(filename); if(res==0) { printf(\u0026#34;delted!\\n\u0026#34;); } else { printf(\u0026#34;failed\\n\u0026#34;); } errno_t err=GetLastError(); printf(\u0026#34;err:%d\\n\u0026#34;,err) //通过错误码32，tool中搜索得知是因为文件正在运行 return 0; } 面向对象和面向过程 面向过程：抽象出解决问题的步骤，然后用函数表达步骤，解决的时候一一调用\n面向对象：抽象出问题里面的对象，然后分析对象的行为，解决问题是对象发生了什么样的行为，调用对象的行为\n作业 1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char str[] = \u0026#34;hello world\u0026#34;; int len = sizeof(str) / 2 - 1; char* p1 = str[0]; char* p2 = str[len]; for (int i = 0; i \u0026lt;len; ) { for (int j = len+1 ; j \u0026lt; strlen(str); ) { char tep = str[i]; str[i] = str[j]; str[j] = tep; ++i; ++j; } } for (int i = 0; i \u0026lt; sizeof(str); i++) { printf(\u0026#34;%c\u0026#34;, str[i]); } return 0; } 2.\n（2）：函数传参 传引用是c++里面的\nc语言里面有两种，函数里面传参有三种\n传值 拷贝实参的值，无法改变实参\nfunc1 形参x是a的值的拷贝，x与a独立\n传指针 拷贝实参的地址，可以改变实参\nfunc2 形参*x是a的地址的拷贝，x就是a 引用中取用了a的地址\n传引用 void func3(int \u0026amp;x)\n传过来引用的地址，可以改变实参，x就是a\n如果一个函数有多个参数，每一个参数可以有不同的传值方法\n指针可能会指向错误的内存的地址，难以驾驭，可能破坏程序\n在传引用的情况下，形参就是实参的别名，代表的就是实参\n传值还是传指针 并非函数设定的指针，在传参的时候就是在传指针，而是看传的实参，是否是传的指针\nfunc2(\u0026amp;c2) //传c2的地址，是传指针，传指针的指针，二级指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void func1(char *c); void func2(char **c); int main(void) { char c1; char *c2; func1(\u0026amp;c1); func1(c2); //func1(\u0026amp;c2)错误,func1本身是一级指针，\u0026amp;c2取地址就二级指针了，就是语法错误 func(\u0026amp;c2); return 0; } swap-交换 ![swap jiaohuan](C:/blog/my-blog/content/post/11-2025/11.01.2025/swap jiaohuan.png)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; void swap1(int x,int y) { int tep = x; x = y; y = tep; } void swap2(int *x, int *y) { int tep = *x; *x = *y; *y = tep; } void swap3(int \u0026amp;x, int \u0026amp;y) { int tep = x; x = y; y = tep; } int main() { int x = 10; int y = 20; swap1(x,y); printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x,y); swap2(\u0026amp;x,\u0026amp;y); printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x, y); x = 10; y = 20; swap3(x,y); printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x, y); return 0; } 函数用参数作为返回值 做输出参数的时候，必须使用传指针或者传引用，因为传值无法改变实参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int add1(int x, int y) { return x + y; } void add2(int x, int y, int* sum) { if (sum == NULL) return; *sum = x + y; } void add3(int x, int y, int\u0026amp; sum) { sum = x + y; } void add4(int* x, int y) { *x = *x + y; } void add5(int \u0026amp;x, int y) { x = x + y; } int main() { int a = 10; int b = 20; int sum = 0; sum = add1(a, b); printf(\u0026#34;sum:%d\\n\u0026#34;, sum); add2(a, b,\u0026amp;sum); printf(\u0026#34;sum:%d\\n\u0026#34;, sum); add3(a, b,sum); printf(\u0026#34;sum:%d\\n\u0026#34;, sum); add4(\u0026amp;a, b); printf(\u0026#34;sum:%d\\n\u0026#34;, sum); a= 10; add5(a,b); printf(\u0026#34;sum:%d\\n\u0026#34;, sum); return 0; } 数组做函数参数 ，防溢出 右边程序，函数设定中\u0026lt;10，但是main函数引用函数时设定了9个元素也就是0-8的数组，会导致内存溢出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 第一种，多设置一个参数 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void print_array(int a[],size_t len) { for (int i = 0; i \u0026lt; len; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int a[9] = { 3,7,2,3,4,5,1,5,6}; print_array(a,9); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 第二种 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void print_array(int (\u0026amp;a)[10]) { for (int i = 0; i \u0026lt;10; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int a[9] = { 3,7,2,3,4,5,1,5,6}; print_array(a); return 0; } 取值10个元素的一维数组，在编译阶段就无法将九个元素的数组传参过去。 只接收十个数组的函数 分析问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void GetMemory(char **p) { *p = (char*)malloc(100); } void Test(char* s) { char* str = NULL; GetMemory(\u0026amp;str); strcpy_s(str,100,s); printf(str); } malloc 需要头文件 作业 1.\n1 2 3 4 5 6 7 8 fun(c) 输出 9 fun函数设定c[]，忽略了函数长度的影响，但是此题没有涉及函数长度的语句，结果不变 fun2(c) 输出 9 fun2函数设定\u0026amp;c，也就是传递指针，c数组指针传递过去，计算元素个数为9 fun3(c) 输出 报错 fun3中，（\u0026amp;c）[9]限制了输入数组的长度必须为9，但是原数组是1-8八个元素，所以报错 解析： 8 1 9 第一个，数组参数退化为指针，char c[]在函数参数中等价于char *c 即sizeof(char*)，与数组内容无关，只与指针类型有关 第二个， 第三个，(\u0026amp;c)[9]限定的九个元素里是包含了\u0026#39;\\0\u0026#39;这个元素的，所以实际上对于a[8]来说元素个数是符合条件的 2.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 1.传递空指针，会导致程序崩溃 2.手动分配内存，可能会出现导入字节数大于100的情况 ai解答： getmemory函数定义指针值，test传递值应该二级指针 或者get函数定义数组，返回指针 1. void GetMemory(char** p) // 传指针的地址 { *p = (char*)malloc(100); } void Test(char* s) { char* str = NULL; GetMemory(\u0026amp;str); // 传str的地址 if(str != NULL) { strcpy(str, s); printf(\u0026#34;%s\u0026#34;, str); free(str); } } 2. char* GetMemory() { return (char*)malloc(100); } void Test(char* s) { char* str = GetMemory(); if(str != NULL) { strcpy(str, s); printf(\u0026#34;%s\u0026#34;, str); free(str); } } （3）：函数调用约定 调用约定： cdecl 调用者还原栈\nstdcall 被调用函数自身修改栈\nfastcall 被调用者修改栈\nshort y 在入栈的时候，会将两个字节提升为四个字节（x86每一个都会对齐到4个字节）\n上面是内存的低地址，下面是内存的高地址。内存增长和栈增长方向相反\n首先是参数入栈，然后是返回地址入栈，这个过程中esp一直在往上走\neip 返回地址：调用完函数之后，下一条要执行的命令\n在程序运行期间，程序访问参数是用过[ebp+8]来访问的，访问局部变量通过[ebp-4]。加是高地址，减是低地址。\n返回地址过了就是老ebp入栈，形成老ebp和ebp指针，然后esp往上走一部分，形成局部变量空间\n函数走完了，退出时，发生esp往下走的过程\n首先是esp往下走，走到ebp，然后老ebp出栈，放到ebp寄存器中，然后ebp往下走\n紧接着返回地址出栈，重新放到eip寄存器中，这是esp指到参数1上面\n清理参数空间，也就是所谓的栈平衡，对cdecl来说是调用者完成这个过程\n将esp向下移动（只有栈顶指针指向的内存区域才是有效的，向下走，之前的区域都会无效掉\n其他调用约定是被调用者清理，在函数结束的时候会有return 12；就是rsp向下移动12位来清理参数空间。而fastcal更快，因为1.2个参数存放在寄存器中，只需要返回四个字节即可\n分析：\n。\n死循环问题：当i=16的时候,a[16]读取到的内存地址是i的内存地址，也就是说会把i赋值为0，重新开始循环，循环一直不会结束\n缓冲区溢出-栈溢出 超出200个字节后，多余的数据占用高位空间，假设有208个字节，会占用到老ebp和返回地址，而函数执行完之后的返回地址被占用了，就会去执行被修改之后的恶意代码\n思考：\nx64调用约定 x64 fastcall 变为调用者来维持栈平衡，统一采用fastcall\n栈的整体大小要能被16整除\n作业： 1.\n如图所示，根据x86的调用约定，printf默认使用edecl约定，参数从右往左压入栈中，形成xxyy这种样式\n而后printf开始调用，在存储的时候，int和float都是4字节，压入栈中参数也是4字节，但是在读取是，%f是读取8字节的double，就导致了第一个调用edp+8调用在x上，第二个应该是edp+c却变成edp+10，变到y取值之上，第四个直接取到栈外的垃圾值\n2.\n如图所示，在第一次函数addr调用时，去了k所在的内存地址赋值给*p指针，而后弹出栈，然后第二次调用loop函数，i可能存储的地址与k一模一样，所以在循环中的 (*p)\u0026ndash; 实际上针对的是k所在的地址，也就是现在的i的-1，导致i的值始终满足情况，造成死循环。\n而short，因为 (*p)-- 只修改 2 字节，破坏了i或j的值，使其变成一个很大的正数或特定的值，导致循环条件立即不成立。\n（4）：inline和static关键字 使用inline的效果\n未使用时在printf里使用get函数，会将参数导入函数而计算取返回值再输出，\n使用inline之后直接就将函数里的语句拷贝，对原函数的替换，到此处计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; inline int mygetmax(int x, int y) { return x \u0026gt; y ? x : y; } int main() { int a = 5; int b = 13; int res = mygetmax(a, b); printf(\u0026#34;max:%d\\n\u0026#34;, res); return 0; } stastic 全局变量，当然源文件有效\n局部变量，记忆作用，生命周期是程序运行时\n只能在当前源文件中有效\n函数设计常见问题与注意事项 问题1：接口设计问题 利用printf打印结果代替返回值 1.凡是在算法中通过printf打印出来，不合格。需要将结果提供给调用者，需要去使用这个结果\n2.十进制转换成36进制，输出无法调用\n问题2：逻辑全部或者部分放在了main函数 main主要用来测试函数功能，不要把逻辑写在main中\n问题3：调用了库函数 自己写算法必须是用纯c来实现\n代码缺少封装 两端重复代码，可以封装成一段单独的函数，然后在此直接调用即可\n问题4：函数内部内存分配 算法中，严禁调用内存分配函数\n让调用者自己去分配内存\n问题5：硬编码 考虑代码的可移植性\n在x64和x86中int为4没问题，但是以后计算机的发展可能会出现问题，而用sizeof来代替可以提高代码的可移植性\n代码中使用可读性的代码更适合\n模块化设计思想 变量都必须初始化 变量命名原则 自解释性代码\n指针移动 char*str和char str[] 写算法 strstr为例子 1.明确的知道算法的输入和输出:输出的应该是字串名 即 char\n2.严进宽出，检测算法中每一个值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; char *_strstr(const char* str, const char* substr) { if (str == NULL || substr == NULL) { return NULL; } if (*substr == \u0026#39;\\0\u0026#39;) { return (char *)str; } char* p1 = (char *)str; while (*p1!=\u0026#39;\\0\u0026#39;) { char* p2 = p1; char* p3 = (char*)substr; while (*p2 \u0026amp;\u0026amp; *p3 \u0026amp;\u0026amp; (*p2 == *p3)) { p2++; p3++; } if (*p3 == \u0026#39;\\0\u0026#39;) { return p1; } p1++; } return NULL; } int main() { printf(\u0026#34;strstr:%s\\n\u0026#34;, _strstr(\u0026#34;hello world\u0026#34;, \u0026#34;orl\u0026#34;)); printf(\u0026#34;strstr:%s\\n\u0026#34;, _strstr(\u0026#34;hello world\u0026#34;, \u0026#34;xyz\u0026#34;)); printf(\u0026#34;strstr:%s\\n\u0026#34;, _strstr(\u0026#34;hello world\u0026#34;, NULL)); return 0; } ","date":"2025-11-02T00:00:00Z","image":"http://localhost:1313/p/11-02/bj_hu_b9094a861f3953da.jpg","permalink":"http://localhost:1313/p/11-02/","title":"11-02 函数"},{"content":"(4):自己实现字符串api 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; size_t mystrlen(const char* str)//const 表示函数内部不会修改str的值 { size_t count = 0; if (str == NULL) return 0;//如果是指针，判断是否为0 while (*str != \u0026#39;\\0\u0026#39;) { count++; str++; } return count; } size_t mystrlen2(const char* str) { const char* eos = str; while (*eos++); return (size_t)(eos - str - 1);//eos末尾，str开头，相减是元素个数包含0字符，-1是非零字符的个数 } //递归 str==NULL || *str==\u0026#39;\\0\u0026#39; return 0; //1+mystrlen2(str+1) 递归出口 size_t mystrlen3(const char* str) { if (str == NULL || *str == \u0026#39;\\0\u0026#39;) return 0; return 1 + mystrlen3(str + 1);//递归式,子串加一 } size_t mystrlen4(const char* str) { return str == NULL || *str == \u0026#39;\\0\u0026#39; ? 0 : 1 + mystrlen4(str + 1); } //字符串拷贝函数 char* mystrcpy(char* dst, const char* src) { if (dst == NULL || src==NULL) { return NULL; } char* s = dst; while (*s++ = *src++);//依然会引起缓存区报错 //*s = \u0026#39;\\0\u0026#39;; return dst; } int mystrcmp(const char* s1, const char* s2) { // if (s1 == NULL || s2 == NULL) // { // return 0; // } assert(s1 != NULL \u0026amp;\u0026amp; s2 != NULL);//要求括号里面必须为真，如果其中应该为none，那么括号就是假 while (*s1 \u0026amp;\u0026amp; *s2 \u0026amp;\u0026amp; (*s1 == *s2)) { s1++; s2++; } return *s1 - *s2; } int main() { char str[] = \u0026#34;hello world\u0026#34;; char buf[128] = { 0 }; printf(\u0026#34;strlen:%lld\\n\u0026#34;, strlen(str)); printf(\u0026#34;mystrlen:%lld\\n\u0026#34;, mystrlen(str)); printf(\u0026#34;mystrlen2:%lld\\n\u0026#34;, mystrlen2(str)); printf(\u0026#34;mystrlen3:%lld\\n\u0026#34;, mystrlen3(str)); printf(\u0026#34;mystrlen4:%lld\\n\u0026#34;, mystrlen4(str)); mystrcpy(buf, str); printf(\u0026#34;buf: % s\\n\u0026#34;, mystrcpy(buf, str)); char* s1 = \u0026#34;hello world\u0026#34;; char* s2 = \u0026#34;hello world\u0026#34;; if (mystrcmp(s1, s2) == 0) { printf(\u0026#34;%s==%s\\n\u0026#34;, s1, s2); } else { printf(\u0026#34;%s != %s\\n\u0026#34;,s1,s2); } return 0; } 循环效率大于递归，递归，函数在自己调用自己的过程中涉及到入栈和出栈\n递归嵌套太深可能会导致栈溢出，但是递归代码更加简洁，需要保证防止栈溢出\n应用层的栈较大可以使用递归，内核层严禁使用递归\n防止程序崩溃，在定义函数之前应对设定值进行严格的校验\n作业 1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 char* rav_strtok(char* strToken, const char* strDelimit) { //定义局部变量 static char* text = NULL; unsigned char table[32]; const unsigned char* delimit; unsigned char* str; char *head; //更新静态字符串 if (strToken) text = strToken; //对不合法输入进行特殊判断 if (text == NULL) return NULL; if (strDelimit == NULL) return text; //改变 char 为 unsigned char 以便进行位运算 str = (unsigned char*)text; delimit = (const unsigned char*)strDelimit; //初始化位表 for (int i = 0; i \u0026lt; 32; i++) table[i] = 0; for (; *delimit; delimit++) { table[*delimit \u0026gt;\u0026gt; 3] |= 1 \u0026lt;\u0026lt; (*delimit \u0026amp; 7); } // 跳过分隔符直到起始位置 while (*str \u0026amp;\u0026amp; (table[*str \u0026gt;\u0026gt; 3] \u0026amp; (1 \u0026lt;\u0026lt; (*str \u0026amp; 7)))) str++; head = (char*)str; // 找到第一个分隔符 for (; *str; str++) { if (table[*str \u0026gt;\u0026gt; 3] \u0026amp; (1 \u0026lt;\u0026lt; (*str \u0026amp; 7))) { *str++ = \u0026#39;\\0\u0026#39;; break; } } // 更新结果 text = (char*)str; if (*text == \u0026#39;\\0\u0026#39;) text = NULL; return head; } 2.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 atoi: #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;ctype.h\u0026gt; int myAtoi(const char * str) { //判断是否是NULL指针或空白字符串 if (str == NULL) return 0; if (str == \u0026#39;\\0\u0026#39;) return 0; //过滤空白字符 while (isspace(*str)) { str++; } //使用标志flag来判断数字正负 int flag = 1; if (*str == \u0026#39;+\u0026#39;) { flag = 1; str++; } else if (*str == \u0026#39;-\u0026#39;) { flag = -1; str++; } //由于字符串里的数字可能大于int类型的最大值，所以使用long long类型变量记录数据 long long ret = 0; while (*str != \u0026#39;\\0\u0026#39;) { //如果是10进制数据 if (isdigit(*str)) { ret = ret * 10 + (*str - \u0026#39;0\u0026#39;) * flag; str++; if (ret \u0026gt; INT_MAX) ret = INT_MAX; if (ret \u0026lt; INT_MIN) ret = INT_MIN; } //如果不是10进制数据 else { //由于atoi函数返回值为int类型，而刚才定义的变量是long long类型，所以要进行转换 return (int)ret; } } return (int)ret; } 2.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 char* my_itoa(int value, char* str, int base) { if (base \u0026lt; 2 || base \u0026gt; 32) { printf(\u0026#34;Wrong radix!\\n\u0026#34;); return str; } char* ret = str; if (value == 0) { *str++ = \u0026#39;0\u0026#39;; *str = \u0026#39;\\0\u0026#39;; return ret; } if (base == 10 \u0026amp;\u0026amp; value \u0026lt; 0) { value = -value; *str++ = \u0026#39;-\u0026#39;; } char* start = str; // 从右到左依次将数字的每一位存储起来 size_t num = value; while (num != 0) { if (num % base \u0026lt; 10) { *str++ = \u0026#39;0\u0026#39; + (char)(num % base); } else { *str++ = \u0026#39;a\u0026#39; + (char)(num % base - 10); } num /= base; } *str = \u0026#39;\\0\u0026#39;; // 倒置字符串 for (char* left = start, *right = str - 1; left \u0026lt; right; left++, right--) { char tmp = *left; *left = *right; *right = tmp; } return ret; } 3.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; char* my_strstr(const char* str1, const char* str2) { const char* cur = str1; //用cur用来记录当前的位置 const char* s1 = NULL; //通过s1 和 s2 比较元素 const char* s2 = NULL; assert(str1 \u0026amp;\u0026amp; str2); //assert断言，如果传入的地址有有一个会空指针，则直接返回str1的地址 if (str2 == \u0026#39;\\0\u0026#39;) return (char*)str1; while (*cur) //当cur中的值不为\u0026#39;\\0\u0026#39;时，进入循环 { s1 = cur; //s1回到比较时的位置 s2 = str2; //s2回到初始位置 while (*s1 \u0026amp;\u0026amp; *s2 \u0026amp;\u0026amp; *s1 == *s2) //当s1和s2指向的值相等时，进入循环 { s1++; //找到下一个元素 s2++; //找到下一个元素 //再次比较 } if (*s2 == \u0026#39;\\0\u0026#39;) //当s2中的元素为\u0026#39;\\0\u0026#39;时，则说明在str1中找到了str2 return (char*)cur; //返回当前的位置 cur++; //第一次没找到，找到下一个元素重新寻找 } return NULL; //如果在循环中没有找到，则返回一个空指针 } int main() { char arr1[] = \u0026#34;abcadefdef\u0026#34;; char arr2[] = \u0026#34;def\u0026#34;; char* ret = my_strstr(arr1, arr2); if (ret != NULL) { printf(\u0026#34;%s\\n\u0026#34;, ret); } else { printf(\u0026#34;找不到\\n\u0026#34;); } return 0; } ","date":"2025-11-01T00:00:00Z","image":"http://localhost:1313/p/11-01/bj_hu_f7edab3c703d9c0c.jpg","permalink":"http://localhost:1313/p/11-01/","title":"11-01 自己实现字符串api"},{"content":"（3）：字符串API 常见操作和库函数 定义了标准的用来操作字符串的库函数，叫做api\n第一套：str 操作多字节字符串\n第二套：wcs 计算宽字节字符串\n第三套：_tcs #include \u0026lt;tchar.h\u0026gt; 既可以是多字节也可以是宽字节\n建议统一使用第三种方式来定义字符串 比较灵活，可以自动切换\n字符串库函数应用 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #pragma warning(disable:4996) int main() { char *s1 = \u0026#34;hello world 1\u0026#34;; wchar_t *s2 = L\u0026#34;hello world 2\u0026#34;; TCHAR *s3 = _T(\u0026#34;hello world 3\u0026#34;); char buf1[128] = { 0 }; wchar_t buf2[128] = { 0 }; TCHAR buf3[128] = { 0 }; printf(\u0026#34;s1:%s\\n\u0026#34;, s1); printf(\u0026#34;s2:%ws\\n\u0026#34;, s2); _tprintf(_T(\u0026#34;s3:%s\\n\u0026#34;), s3); //tcs 处理方法 //_tcscpy(buf3,s3); // int min_len3 = 128 \u0026gt; len3 ? len3 : 127; //_tcscpy_s(buf3, 128, s3); //_tprintf(_T(\u0026#34;buf3:%s\\n\u0026#34;), buf3); // printf(\u0026#34;%d,%d,%d\\n\u0026#34;, len1, len2, len3); // 两个字符串进行比较 char* st1 = \u0026#34;hello world\u0026#34;; char* st2 = \u0026#34;hello china\u0026#34;; //if (strcmp(st1, st2) == 0) //{ //\tprintf(\u0026#34;%s==%s\\n\u0026#34;, st1, st2); //} //else //{ //\tprintf(\u0026#34;%s!=%s\\n\u0026#34;, st1, st2); //} //if (strnicmp(st1, st2,5) == 0) //{ //\tprintf(\u0026#34;%s==%s\\n\u0026#34;, st1, st2); //} //else //{ //\tprintf(\u0026#34;%s!=%s\\n\u0026#34;, st1, st2); //} //返回位置地址 //strchr从左往右找strrchr从右往左找 //比如在上述的path路径中找冒号 //path:c:\\doc\\test\\mallocfree.txt //strchr(path, \u0026#39;:\u0026#39;);//该函数返回的是path中冒号的指针值，所以应该是: char *p=strchr(path, \u0026#39;:\u0026#39;); if (p != NULL) { printf(\u0026#34;found it:%s\\n\u0026#34;, p); } else { printf(\u0026#34;not found it\\n\u0026#34;); } //对于单独找出文件名部分，从右往左找，找斜线位置，再斜线加一 printf(\u0026#34;filename:%s\\n\u0026#34;, strrchr(path, \u0026#39;\\\\\u0026#39;) + 1); printf(\u0026#34;filename:%s\\n\u0026#34;, strrchr(path, \u0026#39;.\u0026#39;) );//求拓展名 return 0; } strcmp 两个字符串进行整体的比较，有一个字符不对就不相等，相等返回0，如果第一个大于第二个返回正数，小则负数\nstrncmp表示前n个字符，只要前n个字符相同返回0\nstricmp 比较大小时候忽略大小写\nstrnicmp 比较前面n个字符是否一样并且忽略大小写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //计算字符串的长度 size_t len1 = strlen(s1); size_t len2 = wcslen(s3); size_t len3 = _tcslen(s3); //拷贝字符串 //不安全的,只是可以使用\tstrcpy(buf1, s1); // strcpy_s(buf1, 128, s1); 会将拷贝字符串与限定字节大小作比较，如果大于则不会拷贝 // printf(\u0026#34;buf1:%d\\n\u0026#34;, buf1); // linux平台拷贝 // 需要定义长度，计算实际拷贝大小，防止内存溢出 // int min_len = sizeof(buf1) \u0026gt; len1 ? len1 : sizeof(buf1) - 1 //\tstrncpy(buf1, s1,min_len); // printf(\u0026#34;buf1:%s\\n\u0026#34;,buf1); //宽字符的处理 //wcscpy(buf2, s2); //wcscpy_s(buf2,123, s2); //int min_len2 = sizeof(buf2) / sizeof(wchar_t) \u0026gt; len2 ? len2 : sizeof(wchar_t) - 1; //wcsncpy(buf2, s2,min_len2); //printf(\u0026#34;buf2:%ws\\n\u0026#34;, buf2); 1 2 3 4 5 6 7 8 //字符串拼接 char path[260] = \u0026#34;c:\\\\doc\\\\test\\\\\u0026#34;; char* filename = \u0026#34;mallocfree.txt\u0026#34;; //对path来说，filename过长会超出范围，导致缓存区溢出，strcat不检查 strcat(path, filename); printf(\u0026#34;path:%s\\n\u0026#34;, path); 1 2 3 4 5 6 7 8 9 10 11 //strstr 从一个字符串中找到子串 char* p1 = strstr(s1, \u0026#34;orl\u0026#34;); if (p1 != NULL) { printf(\u0026#34;p1:%s\\n\u0026#34;, p1); } else { printf(\u0026#34;not found it\\n\u0026#34;); } //strtok 拆分字符串\rchar ip[] = \u0026quot;192.168.100.1\u0026quot;;\rconst char *delim = \u0026quot;.\u0026quot;;//分隔符可以多设定几个，比如\u0026quot;._ \u0026quot;\rchar* next = NULL;\rchar* p2 = strtok_s(ip, delim,\u0026amp;next);//char *p2 = strtok(ip, delim);\rwhile (p2 != NULL)\r{\rprintf(\u0026quot;%s\\n\u0026quot;, p2);\rp2 = strtok_s(NULL, delim,\u0026amp;next);//拆分之后会记住地址，不用传参到null位置\r}\r1 2 3 4 5 6 7 8 9 10 11 //strstr 从一个字符串中找到子串 char* p1 = strstr(s1, \u0026#34;orl\u0026#34;); if (p1 != NULL) { printf(\u0026#34;p1:%s\\n\u0026#34;, p1); } else { printf(\u0026#34;not found it\\n\u0026#34;); } 1 2 3 4 5 6 7 8 9 10 11 12 13 //字符串，整数，浮点数转换方法 char *value = \u0026#34;3.1415\u0026#34;; float f = atof(value); printf(\u0026#34;f:%f\\n\u0026#34;, f); char* v1 = \u0026#34;123\u0026#34;; int i = atoi(v1); printf(\u0026#34;i:%d\\n\u0026#34;, i); TCHAR *v2 = _T(\u0026#34;678\u0026#34;); int v = _ttol(v2); printf(\u0026#34;v:%d\\n\u0026#34;, v); 作业： 作业：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 思路： for循环从右往左遍历函数然后存入新的字符串中再拷贝 #include \u0026lt;stdio.h\u0026gt; void reverse_str(char *str) { while (*str != \u0026#39;\\0\u0026#39;) { str++; int x = str; } for (int i = str; i \u0026gt;= 0; i--) { char str2[] = \u0026#34;0\u0026#34;; for (int j = 0; j \u0026lt; str; j++) { str2[j] = str[i]; } return 0; } } int main() { char str[] = \u0026#34;hello world\u0026#34;; reverse_str(*str); printf(\u0026#34;%s\u0026#34;,reverse_str(*str)); return 0; } 问题： 1.主函数中，调用函数之后，怎么将函数返回值导入变量中 2.void是什么语法，” 不允许使用不完整的类型 \u0026#34;void\u0026#34; “ 什么叫做不完整，输入void也报错 网络： #include \u0026lt;stdio.h\u0026gt; void Reverse(char* str) { char* left = str;//left指向字符串数组的首元素 char* right = str + strlen(str) - 1;//right指向字符串的最后一个元素 while (left \u0026lt; right)//进行首元素和尾元素的交换，直至left等于right为止，此时字符串完成1逆置 { char temp = *left; *left = *right; *right = temp; ++left; --right; } } int main() { char str[10000]=\u0026#34;hello world\u0026#34;; Reverse(str); printf(\u0026#34;%s\u0026#34;, str); return 0; } 使用指针首位互换，在指针互相相遇后停止 字符串作业代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 1. #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char path[50]=\u0026#34;c:\\\\docs\\\\mallocfree.txt\u0026#34;; char* p = strrchr(path,\u0026#39;m\u0026#39;); if (p != NULL) { printf(\u0026#34;found it :%s\\n\u0026#34;, p); } else { printf(\u0026#34;found it not :%s\\n\u0026#34;, p); } return 0; } 2.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char path[100]=\u0026#34;http://www.mallocfree.com/? x=y\u0026amp;mm_gxb=1_87adefc12d\u0026amp;id=9988\u0026#34;; char* p = strstr(path, \u0026#34;1_8\u0026#34;); if (p != NULL) { printf(\u0026#34;found it :%s\\n\u0026#34;, p); } else { printf(\u0026#34;found it not :%s\\n\u0026#34;, p); } return 0; } 3.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char path[100]=\u0026#34;http://www.mallocfree.com/?x=y\u0026amp;mm_gxb=1_98adefc12e\u0026#34;; char* p = strstr(path, \u0026#34;1_9\u0026#34;); if (p != NULL) { printf(\u0026#34;found it :%s\\n\u0026#34;, p); } else { printf(\u0026#34;found it not :%s\\n\u0026#34;, p); } return 0; } 4.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char ip[] = \u0026#34;192.168.100.1\u0026#34;; const char* delim = \u0026#34;.\u0026#34;; char* next = NULL; char* p2 = strtok_s(ip, delim, \u0026amp;next); while (p2 != NULL) { int f = atof(p2); printf(\u0026#34;%d \u0026#34;, f); p2 = strtok_s(NULL, delim, \u0026amp;next); } return 0; } ai生成： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char ip[] = \u0026#34;192.168.100.1\u0026#34;; const char* delim = \u0026#34;.\u0026#34;; char* next = NULL; unsigned int result = 0; // 32位整数结果 int shift = 24; // 从最高位开始 char* token = strtok_s(ip, delim, \u0026amp;next); while (token != NULL \u0026amp;\u0026amp; shift \u0026gt;= 0) { int num = atoi(token); result |= (num \u0026lt;\u0026lt; shift); // 按位合并 shift -= 8; // 每次移动8位 token = strtok_s(NULL, delim, \u0026amp;next); } printf(\u0026#34;IP地址: %s\\n\u0026#34;, \u0026#34;192.168.100.1\u0026#34;); printf(\u0026#34;32位整数: %u\\n\u0026#34;, result); printf(\u0026#34;十六进制: 0x%08X\\n\u0026#34;, result); return 0; } ","date":"2025-10-31T00:00:00Z","image":"http://localhost:1313/p/10-31/bj_hu_db8d56b60bf97e75.jpg","permalink":"http://localhost:1313/p/10-31/","title":"10-31 字符串API"},{"content":"(2):程序中的字符串 1.赋值给了字符指针，其字符存放在静态常量区，赋值是将字符内存的首地址赋给了该指针\n通过指针++，可以不断的扫描该字符，直到遇到\\0字符为止\n2.赋值给了字符数组 str2 ，与上面不同，是将静态区的字符拷贝到str2数组里面，而且字符数组的内存是可以修改的，元素个数，即包含0字符在内的所有字符\n3.该字符数组包含了100个元素，赋值的字符串没有100个元素，多余的部分默认为0\n4.该字符数组占12个字符，相当于整体的字符串赋值进入，sizeof(str4)=12,但是如果用strlen来计算字符串的值的话，会在第一个\\0截断\n程序中使用字符串 堆上 可以存在全局数组里面，可以用指针指向，可以拷贝到栈上，可以从堆里分配字节来存放\n堆上用了之后需要free，否则会造成内存的泄露\ns2指向了hello world的地址，不能通过s2来更改数组里元素的值 编译发现不了，但是程序会崩溃\n静态常量区是不可以修改的\n字符串的遍历 字符串做参数 字符串与字符数组 1.纯粹的字符数组\n2.可以当作一个字符串\n3.作为字符数组有5个元素，作为字符串有前面三个元素\n4.即是数组也是字符串\n字符串数组 作业\n作业\n1.\n1 2 3 4 5 6 7 8 9 sizeof(p1)=4 x86 sizeof(p2)=9 sizeof(p3)=1024 sizeof(p4)=8 strlen(p1)=8 strlen(p2)=8 strlen(p3)=1024 strlen(p4)=8 2.\n1 2 3 4 5 char name1[3][20]= 定义一个二维数组，有三行，每一行能存20个字节，引号中的字符存入数组中，按顺序排列，然后数组存放在内存中 char *name2{3}= 定义一个一维数组指针，存放了三个元素，三个元素存在静态常量区，将字符内存的首地址赋值给了指针 char *S1 = \u0026#34;hello world\u0026#34; 定义一个指针指向存放在静态常量区的一个字符串 char s2[] = \u0026#34;hello world\u0026#34; 定义了一个数组，存放了字符串 ","date":"2025-10-30T00:00:00Z","image":"http://localhost:1313/p/10-30/bj_hu_72198dfee38f1539.jpg","permalink":"http://localhost:1313/p/10-30/","title":"10-30 程序中的字符串"},{"content":"第十一课-字符串 （1）：字符串定义 定义：\n\u0026lsquo;0\u0026rsquo;\u0026ndash;\u0026gt;48\n\u0026lsquo;\\0\u0026rsquo;\u0026ndash;\u0026gt;0\n遇到\\0字符串即结束\n转义字符：\nc语言中字符串是用双引号包裹起来的，需要用转移字符表示此处双引号只是一个引号\n单引号包裹起来的字符叫字符常量\n字符串常量：\n“hello world” 字符常量\n‘a’是一个字符，\u0026ldquo;a\u0026quot;是一个字符串\n“123”是一个字符串，123是一个整数值 可以调用函数互相切换\n“1”.‘1’,1 字符串，字符，整数\n“0”，‘0’，‘\\0’，0，NULL 字符串，字符，字符，整数，指针\n“” 空字符串，仍然有看不见的0字节\nchar *str = \u0026ldquo;hello world\u0026rdquo; 字符指针 ，字符串存放在静态常量区，赋值给了字符指针，指向了常量区\nchar str[]= \u0026ldquo;hello world\u0026rdquo; 字符常量区的字符赋值给了这个字符数组，并且有0字节，一共12个字节\nstr1指向静态常量区，静态常量区不能更改 (str1+1)=\u0026lsquo;a\u0026rsquo; 会报错\nstr2[1]=\u0026lsquo;1\u0026rsquo;;\n字符不可以赋值给指针，地址可以赋值给指针\nL\u0026rsquo;a\u0026rsquo; 占两个字节 unicode编码\n\u0026lsquo;a\u0026rsquo; 占一个字节\n作业：\n0:一个整数，数值 \u0026lsquo;0\u0026rsquo;一个字符常量，值类型 \u0026ldquo;0\u0026rdquo; 一个表示0的字符串 \u0026lsquo;\\0\u0026rsquo; 一个字符变量 “123” 一个字符串 123 一个整数数值 用\\转义符，表示此引号不具有特殊含义 用双引号括起来,然后内部再用两个斜杠来表示 9，1-8八个字符再加上\\0的末尾不可见字符 区别在于每一个元素所占字节数，未标注L 所用是ASCII编码，每一个元素占一个字节，标注L所用UNICODE编码，每一个元素占两个字节 考核1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; int main() { char array_1; printf(\u0026#34;请输入字符串：\u0026#34;); gets_s(\u0026#34;%s\u0026#34;, array_1); int len=strlen(array_1); printf(\u0026#34;%d\u0026#34;, len); return 0; } //上述自打，搜索得问题 1.未引入头文件，使用gets语法需要引用string.h头文件 2.gets语法使用错误，正确使用方式gets_s(数组名, 数组大小); 3.使用了未定义字符串array，会警告，应在定义时初始化。 这是用strlen函数方法 或许不是通过键盘输入字符串的方式来取得字符串长度 因为输入之前需要定义字符串长度，而用sizeof直接是输出定义长度，strlen输出除\\0长度 //* #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int lens(char str[]) { char *p = str; int counts = 0; while(*p++ != \u0026#39;\\0\u0026#39;) { counts++ ; } return counts+1; } int main() { char str[] = \u0026#34;10d2n821 ma\u0026amp;@\u0026amp;@ 93cdw1!\u0026#34;; int res = lens(str); printf(\u0026#34;%d\u0026#34;, res); return 0; } *//代码来源 https://blog.csdn.net/st66688/article/details/108356361 //自打 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int lens(char str[]) { int j = 0; for (int i=0; str[i] != \u0026#34;\\0\u0026#34;; i++) { j++; } return j+1; } int main() { char str[] = \u0026#34;10d2n821 ma\u0026amp;@\u0026amp;@ 93cdw1!\u0026#34;; int res = lens(str); printf(\u0026#34;%d\u0026#34;, res); return 0; } !!! 注意\u0026#34;\\0\u0026#34; \u0026#39;\\0\u0026#39; 应该是for遍历到\u0026#39;\\0\u0026#39; 而不是字符串\u0026#34;\\0\u0026#34; !!! 考核2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int a[4][4] = { {0x16,0x99,0xae,0xc3}, {0xf8,0xab,0x8f,0x19}, {0x4d,0xe7,0x65,0x3d}, {0x30,0x91,0xb1,0xb9} }; int b[4][4] = {0}; int x = 0; for (int i= 0;i\u0026lt;4;i++) { for (int j = 0; j \u0026lt; 4; j++) { if (i == 0) { b[i][j] = a[i][j]; } else if (i == 1\u0026amp;\u0026amp;j+1\u0026lt;4) { b[i][j] = a[i][j+1]; } else if (i == 1 \u0026amp;\u0026amp; j == 3) { b[1][3] = a[i][j - 3]; } else if (i == 2\u0026amp;\u0026amp;j+2\u0026lt;4 ) { b[2][j] = a[i][j + 2]; } else if (i == 2) { b[i][2] = a[i][0]; b[i][3] = a[i][1]; } else if (i == 3) { b[i][0] = a[i][3]; b[i][1] = a[i][0]; b[i][2] = a[i][1]; b[i][3] = a[i][2]; } printf(\u0026#34;%02x \u0026#34;, b[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } //ai #include \u0026lt;stdio.h\u0026gt; // 用for循环行移位 void shiftbytes(int arr[4][4]) { int temp; for(int i = 0; i \u0026lt; 4; i++) { // 第0行不移位，第1行左移1位，第2行左移2位，第3行左移3位 int shift = i; for(int s = 0; s \u0026lt; shift; s++) { // 左移一位 temp = arr[i][0]; for(int j = 0; j \u0026lt; 3; j++) { arr[i][j] = arr[i][j+1]; } arr[i][3] = temp; } } } int main() { int a[4][4] = { {0x16,0x99,0xae,0xc3}, {0xf8,0xab,0x8f,0x19}, {0x4d,0xe7,0x65,0x3d}, {0x30,0x91,0xb1,0xb9} }; printf(\u0026#34;原始数组:\\n\u0026#34;); for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 4; j++) { printf(\u0026#34;%02x \u0026#34;, a[i][j]); } printf(\u0026#34;\\n\u0026#34;); } shiftbytes(a); printf(\u0026#34;\\n变换后数组:\\n\u0026#34;); for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 4; j++) { printf(\u0026#34;%02x \u0026#34;, a[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 补作业4代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 2. #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = { 1,7,6,3,4,2 }; int max_num = a[0]; int second_num = 0; for (int i=0; i \u0026lt; sizeof(a)/sizeof(a[0]); i++) { if (max_num \u0026lt; a[i]) { max_num == a[i]; if (second_num \u0026lt; max_num \u0026amp;\u0026amp; second_num \u0026lt; a[i]) { second_num == a[i]; } } printf(\u0026#34;该数组最大值是%d，第二大的值是%d\\n\u0026#34;, max_num, second_num); } return 0; } 问题： 1.赋值符号，= == 不对 2.第二大值的赋值逻辑不对 应该是有两条逻辑 1）second 比max小，max比a[i]小的时候，second更新到max，max更新到更大值 2）second 比max小，但是a[i]值大于second小于max ai修正后 #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = { 1,7,6,3,4,2 }; int max_num = a[0]; int second_num = a[0]; for(int i = 1; i \u0026lt; sizeof(a)/sizeof(a[0]); i++) { if(a[i] \u0026gt; max_num) { second_num = max_num; // 旧最大值变成第二大 max_num = a[i]; // 更新最大值 } else if(a[i] \u0026gt; second_num \u0026amp;\u0026amp; a[i] != max_num) { second_num = a[i]; // 更新第二大值 } } printf(\u0026#34;该数组最大值是%d，第二大的值是%d\\n\u0026#34;, max_num, second_num); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 作业1： 思路， int 一个数组 从右边开始，也就是从 a[sizeof(a)/sizeof(a[0]) -1] int一个整数 int x = sizeof(a)/sizeof(a[0]) 每一次比较a[x-1]与a[x]的大小 if a[x-1]\u0026gt;a[x] 将a[x]填入新数组的从0开始的顺序 else a[x-1] 填入 用i--来表达 限制x的大小，需要使得x-1\u0026gt;0 最后再将所形成的新数组拷贝到原来的a数组 代码： #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = {3,7,2,1,8,9,5}; int b[] = {0,0,0,0,0,0,0}; int x = sizeof(a) / sizeof(a[0]); for (int i=x; i - 2 \u0026gt;= 0; i--) { if (a[i-2] \u0026lt; a[i-1]) { for (int y = 0; y \u0026lt; sizeof(a) / sizeof(a[0]); y++) { b[y] = a[i - 1]; } } else(a[i - 2] \u0026gt; a[i-1]); { for (int y = 0; y \u0026lt; sizeof(a) / sizeof(a[0]); y++) { b[y] = a[i]; } } } for (int i = 0; i \u0026lt; sizeof(a) / sizeof(a[0]); i++) { a[i] = b[i]; } printf(\u0026#34;数组a:%p,数组b:%p\u0026#34;, a, b); return 0; } ai修复： #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = {3,7,2,1,8,9,5}; int b[] = {0,0,0,0,0,0,0}; int x = sizeof(a) / sizeof(a[0]); for (int i = x-1; i - 2 \u0026gt;= 0; i--) // 从最后一个有效索引开始 { if (a[i-2] \u0026lt; a[i-1]) { for (int y = 0; y \u0026lt; sizeof(a) / sizeof(a[0]); y++) { b[y] = a[i - 1]; } } else // 去掉括号和条件 { for (int y = 0; y \u0026lt; sizeof(a) / sizeof(a[0]); y++) { b[y] = a[i - 2]; } } } for (int i = 0; i \u0026lt; sizeof(a) / sizeof(a[0]); i++) { a[i] = b[i]; } printf(\u0026#34;数组a:%p,数组b:%p\u0026#34;, a, b); return 0; } //错误： 1.else后面不跟条件以及； 2.第一次索引a[7]访问未定义内存导致程序崩溃 3.逻辑漏洞 for (int y = 0; y \u0026lt; sizeof(a) / sizeof(a[0]); y++) { b[y] = a[i - 2]; } 此内层循环中，没有设置条件，导致每次都是循环遍历b数组每一个值 #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = { 3,7,2,1,8,9,5 }; int b[] = { 0,0,0,0,0,0,0 }; int x = sizeof(a) / sizeof(a[0]); for (int i = x - 1; i - 2 \u0026gt;= 0; i--) { if (a[i - 2] \u0026lt; a[i - 1]) { for (int i = x - 1; i - 2 \u0026gt;= 0; i--) { if (a[i - 2] \u0026lt; a[i - 1]) { b[i] = a[i - 1]; } else { b[i] = a[i - 2]; } } for (int i = 0; i \u0026lt; sizeof(a) / sizeof(a[0]); i++) { a[i] = b[i]; } printf(\u0026#34;数组a: \u0026#34;); for (int i = 0; i \u0026lt; sizeof(a) / sizeof(a[0]); i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } printf(\u0026#34;\\n数组b: \u0026#34;); for (int i = 0; i \u0026lt; sizeof(b) / sizeof(b[0]); i++) { printf(\u0026#34;%d \u0026#34;, b[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } } } 主要问题 1. 循环嵌套混乱 c for (int i = x - 1; i - 2 \u0026gt;= 0; i--) { if (...) { for (int i = x - 1; i - 2 \u0026gt;= 0; i--) { // 重复的循环 内外层循环都用同一个变量名 i，造成混乱。 2. 逻辑不完整 只处理了 a[i-2] \u0026lt; a[i-1] 的情况 else 分支没有对应的内层循环 3. 提前返回 return 0 在第一次满足条件时就结束程序。 正确的冒泡思路： #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = {3,7,2,1,8,9,5}; int n = sizeof(a) / sizeof(a[0]); // 冒泡排序 for(int i = 0; i \u0026lt; n-1; i++) { for(int j = 0; j \u0026lt; n-1-i; j++) { if(a[j] \u0026gt; a[j+1]) { // 交换相邻元素 int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } } } // 输出结果 printf(\u0026#34;排序后: \u0026#34;); for(int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } return 0; } ","date":"2025-10-29T00:00:00Z","image":"http://localhost:1313/p/10-29/bj_hu_9285a17996426751.jpg","permalink":"http://localhost:1313/p/10-29/","title":"10-29 字符串定义"},{"content":"第十课-数组 （2）：二维数组 在内存中依然是线性编址\n内存页：\n两种遍历的实例：\n思考：\n数组中用（）括起来的是逗号表达式，需要计算其中的值，此数组中的值{2，4，3，0，0，0}，因为是二维数组，所以写为\n1 2 3 {2,4 3,0 0,0} 作业2：\n1.\n1）直接赋值\n1 int a[1][1]={{1,2},{1,2}} 2）循环遍历输入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 int a[6][6]={0}; for(int i;i\u0026lt;6;i++) { for(int j;j\u0026lt;6;j++) { a[i][j] = rand // 固定数值，或者随机数生成 } } //*还可以通过键盘输入来往数组里面输入值 参考 for(int i=0;i\u0026lt;10;i++) { for(int j=0;j\u0026lt;5;j++) { printf(\u0026#34;Please input the score for %d\\n\u0026#34;,o) scanf_s(\u0026#34;%d\u0026#34;,\u0026amp;score[i][j]); } } //* //个人想法，未搜索 //*以下是网络搜索 #include \u0026lt;stdio.h\u0026gt; int main() { int rows = 3; // 定义二维数组的行数 int cols = 4; // 定义二维数组的列数 int matrix[3][4]; // 定义一个3行4列的二维数组 // 为二维数组的每个元素赋值 for(int i=0; i\u0026lt;rows; ++i) { // 外层循环遍历行 for(int j=0; j\u0026lt;cols; ++j) { // 内层循环遍历列 // 赋值操作 matrix[i][j] = i * cols + j; // 赋值逻辑，这里只是示例，可以根据需要修改 } } // 打印二维数组以验证赋值是否成功 for(int i=0; i\u0026lt;rows; ++i) { for(int j=0; j\u0026lt;cols; ++j) { printf(\u0026#34;%d \u0026#34;, matrix[i][j]); // 打印矩阵元素 } printf(\u0026#34;\\n\u0026#34;); // 每行结束后换行 } return 0; } ———————————————— 版权声明：本文为CSDN博主「凭栏落花侧」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/m0_67484548/article/details/140399701 2.\n存储方式：\n线性存储方式，按照a[0]行，a[1]行的方式，一行一行一个数据一个数据的方式存储，每个元素的长度根据定义长度来\n3.按行遍历的效率高\n因为涉及内存页存储\n内存页是操作系统分配内存的最小单位，通常大小为4KB，用于实现虚拟内存和内存管理。\n内存页的定义:内存页（Memory Page）是操作系统在内存管理中使用的基本单位。它将物理内存划分为固定大小的块，通常为4KB（4096字节）。操作系统通过页表来管理这些内存页，记录虚拟地址与物理地址之间的映射关系\n如果存储数据过多，二维数组的数据存放在不同的内存页，那么按列遍历的方式 就是在内存中频繁跳转，容易导致缓存未命中，预取的命中率不高的问题\n现代cpu可以做到提前加载数据，按行遍历的方式能够完全利用这个机制快速遍历，而按列方式预取器难以预测\n（3）：数组重要注意事项 首地址\na1，代表的int *类型的指针\n\u0026amp;a1，代表的是整个的一维数组\na2，代表二维数组中的一行\n\u0026amp;a2，代表一整个数组\n地址相同，类型不一样，指向的内存也不一样，a1代表的指针就指向了4个字节的内存，而\u0026amp;a1代表十个元素也就是指向了40个字节\na1+1,\u0026amp;a1+1\na2+1,\u0026amp;a2+1 意思是，当前数组所在内存地址，向前移动所属类型的字节数的地址，比如int类型4个字节，这个意思就是a1所在内存地址，向前移动4个字节。\u0026amp;a1+1代表了移动40个字节\n代码：\n1 2 3 4 5 6 7 8 9 10 int a1[10]={0}; int a2[4][5]={0}; printf(\u0026#34;a1:%d,\u0026amp;a1:%d\\n\u0026#34;,a1,\u0026amp;a1); printf(\u0026#34;a2:%d,\u0026amp;a2:%d\\n\u0026#34;,a2,\u0026amp;a2); printf(\u0026#34;a1+1:%d,^a1+1:%d\\n\u0026#34;,a1+1,\u0026amp;a1+1); printf(\u0026#34;a2+1:%d,^a2+1:%d\\n\u0026#34;,a2+1,\u0026amp;a2+1); return 0; 数组做参数\n外部计算长度为40个字节，传入函数内部计算长度退化为指针，长度为4个字节，但是依然可以通过这个指针来访问数组中的每一个元素的\n数组的溢出\n内存溢出，如果访问的该内存地址不存在，导致非法访问，会造成程序崩溃，如果访问的内存地址存在，有可能访问到其他数据，有可能访问到一个垃圾值，对其进行修改可能会破坏程序中其他有用的值，引起整个程序出现异常\n程序1：for循环中i\u0026lt;=16，但是定义的a[16]只有0-15号元素，会导致数组溢出\n程序2：第一个循环遍历里面设定了i\u0026lt;10，也就是说i会遍历0-9号元素，第二个函数定义里面定义a[9]，只包含了0-8号元素，第九号没有定义，也会导致数组溢出\n程序3：i = i+1，a[i]是不存在的，也会导致数组的溢出\n1.代码输出：\nprintf(\u0026ldquo;sizeof(a)=%d\\n\u0026rdquo;,sizeof(a)) 输入应是 40 字节长度 int是整型，代表四字节长度，a数组里有10个元素，共40字节的长度\nfunc(a,10）输入应该4字节长度，因为数组导入函数之后，缩成指针，函数中输出int a 应是int对应的指针长度为4\n2.\n如图，在内存区高到低存储的内存地址分布， ！！！！低到高！！！！\nptr1 int * \u0026amp;a+1 取整个数组a的内存长度往前移动一位 移动之后如图中红色部分所示\nptr2 int) a+1 将数组指针a强制转化为整型并且移动一位\nprintf() ptr1[-1] 往前移动一位之后，再往后取一位，也就是如图中蓝色部分\n​ ptr2 a所处的地址被转化为int型，然后移动一位就是移动一个字节，ptr2所输出是图中黄色部分\n（4）：数组应用 1.斐波那契数列求和（前20项）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int a[20]={0}; a[0]=1; 1[1]=1; for(int o=2;i\u0026lt;20;i++) { a[i]=a[i-1]+a[i-2]; } for(int i=0li\u0026lt;20;i++) { printf(\u0026#34;%d\u0026#34;,a[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; 字符串变大小写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 char str[]=\u0026#34;Hello World, 12345678\u0026#34;; //*从键盘上输入 char str[128]={0}; printf(\u0026#34;Please input a str:\\n\u0026#34;); gets_s(str,128); //* int len = sizeof(str)/sizeof(str[0]); for(int i=0;i\u0026lt;len;i++) { if(str[i]\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp; str[i]\u0026lt;=\u0026#39;Z\u0026#39;) { str[i] += \u0026#39;a\u0026#39;-\u0026#39;A\u0026#39;; } } printf(\u0026#34;%s\\n\u0026#34;,str); return 0; 计算平均值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int score[10]={0}; for(int i=0;i\u0026lt;10;i++) { pruintf(\u0026#34;Please input the score for %d\\n\u0026#34;,o) scanf_s(\u0026#34;%d\u0026#34;,\u0026amp;score[i]); } for(int i=0;i\u0026lt;10;i++) { total += score[i]; } float average_score = (float)total/10; printf(\u0026#34;average score is:%f\\n\u0026#34;,average_score); return 0; 求数组中的最大值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int a[]={98,123,7,2,77,95,23,999,1001,273}; int max_num=a[0]; for (int i=0;i\u0026lt;sizeof(a)/sizeof(a[0]);i++) { if(max_num\u0026lt;a[i]) { max_num=a[i]; } } printf(\u0026#34;%d\\n\u0026#34;,max_num); return 0; 剪刀石头布： 0,1,2\nresult=(man-computer+4)%3-1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include\u0026lt;stdlib.h\u0026gt; %include\u0026lt;time.h\u0026gt; char name[3][20]={\u0026#34;剪刀\u0026#34;，\u0026#34;石头\u0026#34;，\u0026#34;布\u0026#34;}; int computer=0; int man=0; srand((unsigned int)time(0)); computer=rand()%3 printf(\u0026#34;0:剪刀\\n1：石头\\n2：布3:退出\\n请输入一个数字与计算机一起玩石头剪刀布:\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;man); if(man\u0026lt;0\u0026amp;\u0026amp;man\u0026gt;2) { printf(\u0026#34;非法输入\\n\u0026#34;); return -1; } else if(man==3) { break } printf(\u0026#34;computer:%s,man:%s\\n\u0026#34;,name[computer],name[man]); int res=(man-computer+4)%3-1; if(res\u0026gt;0) { printf(\u0026#34;man win\\n\u0026#34;); } else if(res==0) { printf(\u0026#34;draw\\n\u0026#34;); } else(res\u0026lt;0) { printf(\u0026#34;computer win\\n\u0026#34;); } return 0; //* while(1) { computer=rand()%3 printf(\u0026#34;0:剪刀\\n1：石头\\n2：布\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;man); if(man\u0026lt;0\u0026amp;\u0026amp;man\u0026gt;2) { printf(\u0026#34;非法输入\\n\u0026#34;); return -1; } printf(\u0026#34;computer:%s,man:%s\\n\u0026#34;,name[computer],name[man]); int res=(man-computer+4)%3-1; if(res\u0026gt;0) { printf(\u0026#34;man win\\n\u0026#34;); } else if(res==0) { printf(\u0026#34;draw\\n\u0026#34;); } else(res\u0026lt;0) { printf(\u0026#34;computer win\\n\u0026#34;); } return 0; } 求五位同学三个科目每一个科目的平均成绩：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 char name[3][20]={\u0026#34;Math\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;Foxpro\u0026#34;}; int score[3][5]={ {80,61,59,85,76}, {75,65,63,87,77}, {92,71,70,90,85} }; for(int i=0;i\u0026lt;3;i++) { int total=0; float average=0.0f; for(int j=0;j\u0026lt;5;j++) { total+=score[i][j]; } average=(float)total/5; printf(\u0026#34;%s\u0026#39; s average score is:%.2f\\n\u0026#34;,name[i],average); } return 0; 作业：\n","date":"2025-10-28T00:00:00Z","image":"http://localhost:1313/p/10-28/bj_hu_cf11fd87aa5b674d.jpg","permalink":"http://localhost:1313/p/10-28/","title":"10-28 二维数组"},{"content":"第十课-数组 （1）：一维数组 统计多个人的平均成绩，引入数组\n数组，一组相同类型的变量连续的存储在一段内存上，并共用一个名字（数组名）。\n每个变量使用下标来区别，并被称作数组的元素。数组的下标是从0开始的\n由定义看出，每个元素的类型相同，因此各个元素在内存中存放的长度也一样，即他们占用的空间等长的，而数组名，就是这段内存的首地址。存放数组的内存也是连续的\n数组根据存放的数据的类型，可分为数值数组，字符数组，指针数组，结构数组等各种类别；而按照数组的维度，又可以分为一维数组，二维数组，三维数组等\n最容易出错，很容易溢出\n数组名，跟表示名一样，必须使用字母，数字，下划线，且数字不开头\na[10]中有0-9，没有10，如果访问a[10]会导致数组溢出，但是程序依然会编译成功，如果溢出之后访问内存，程序会崩溃，读出垃圾数据，或者影响到存储的其他数据。编译器不检测\n“7”的位置可以是表达式，但是必须是常量表达式\n使用a[i]可以直接访问到某个元素（随机访问，通过固定长度乘以下标，能够直接算出地址并对其进行访问连续，加偏移，加固定长度）\n链表不可以，每一个元素不是连续的，每一次找节点必须要从开头开始一个一个寻找\n定义实例：\n*a表示指针\n#define SIZE 宏定义\n初始化：\n已定义了的数组的值可以改变\n如果只定义了一些，没有定义完，那么剩下未定义的值默认为0\n3.是逗号表达式，等价于 int a[10]={1,3,4}\n5.未指定个数，通过后续定义的值来定义数组的长度\n程序赋值，i\u0026lt;10，满足有效元素\n或者通过键盘来输入一个数\n一维数组的初始化与遍历\n键盘为数组赋值例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; int main() { int a[10] = {0}; for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;Please input the value for %d\\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d\u0026#34;, a[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } 定义函数用来打印数组\n1 2 3 4 5 6 7 8 9 10 11 boid print_array(int a[],int len) { for(int i=0;i\u0026lt;len;i++) { printf(\u0026#34;%d\u0026#34;,a[i]); } printf(\u0026#34;\\n\u0026#34;) } print_array(a,number) sizeof(a) a数组所占的长度\nsizeof(a[0]) a数组中第一个元素所占的长度\n因为数组中每一个元素所占长度相同，所以用总长度除以每一个元素所占长度，就能够计算出数组中元素个数\n即sizeof(a)/sizeof(a[0])\n字符数组 strlen(str1)是非法的，str1不是一个字符串\nstrlen会从左到右遍历所有元素直到找到最后的0为止，然后减去0，用来计算str1会导致内存溢出\n字符串的规定就是最后一位是0\na必须是实参，如果是形参的话会导致计算出错，形参的a会退化成指针，一个指针的长度是四个字节或者说是八个字节\n作业：\n1.随机访问：指能通过 a[下标值] 直接访问到数组中这个下标所在的值 原因：数组的存储方式是按照顺序一个一个字节数相同，连续排列的组合，通过长度乘以下标值能够直接找到对应的内存地址，所以数组能够支持随机访问\n2.在C语言中，数组的长度是固定的，因此无法直接删除数组中的某一项。通常通过覆盖法或辅助数组法来实现删除操作。\n覆盖法 确定需要删除元素的下标位置，然后从此位置开始将后续元素全部往前移动一位，而后更新数组长度或者将最后一位换为0\n代码示例：(百度复制)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; void removeElement(int arr[], int *size, int index) { if (index \u0026lt; 0 || index \u0026gt;= *size) { printf(\u0026#34;索引超出范围\\n\u0026#34;); return; } for (int i = index; i \u0026lt; *size - 1; i++) { arr[i] = arr[i + 1]; } (*size)--; // 更新数组长度 } int main() { int arr[] = {1, 2, 3, 4, 5}; int size = 5; int index = 2; // 要删除的元素索引 removeElement(arr, \u0026amp;size, index); for (int i = 0; i \u0026lt; size; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } return 0; } 辅助数组 创建一个新的数组，然后将除了删除元素的其他元素复制到新数组，再复制回去\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; void removeElement(int arr[], int *size, int index) { if (index \u0026lt; 0 || index \u0026gt;= *size) { printf(\u0026#34;索引超出范围\\n\u0026#34;); return; } int temp[*size - 1]; int j = 0; for (int i = 0; i \u0026lt; *size; i++) { if (i != index) { temp[j++] = arr[i]; } } for (int i = 0; i \u0026lt; j; i++) { arr[i] = temp[i]; } (*size)--; // 更新数组长度 } int main() { int arr[] = {1, 2, 3, 4, 5}; int size = 5; int index = 2; // 要删除的元素索引 removeElement(arr, \u0026amp;size, index); for (int i = 0; i \u0026lt; size; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } return 0; } 3.\n1 2 3 #define array_number[int a[],int len] len = sizeof(a)/sizeof(a[]); return 0; 4.数组溢出：访问到数组未定义的内存地址\n现象：如果是内存中未定义的地址，进入非法区域，会导致程序崩溃\n或者是访问到其他数据所在的地址，导致数据破坏影响程序运行\n或者是得到一些未定义的垃圾值\nc语言并不检测数组溢出，所以这算是一个隐性的bug\n注意事项\n右边，在定义时候打了； 也就是没有进行初始化，用循环进行遍历初始化\n","date":"2025-10-27T00:00:00Z","image":"http://localhost:1313/p/10-27/bj_hu_d5957c798504a6a6.jpg","permalink":"http://localhost:1313/p/10-27/","title":"10-27 一维数组"},{"content":"第八课：程序的语句 三种结构\n定义语句\u0026amp;表达式语句\u0026amp;赋值语句 定义语句，在使用变量之前必须要对去其进行定义\nint i=1; \u0026ndash;\u0026gt;定义一个整型变量i，它的值为1，值为1相当于初始化，也可以不初始化，不初始化i的值就是一个垃圾值，尽量不要不初始化，定义一个值\n表达式语句\ni++; 自增\ni+1; 无意义\ni; 无意义\n5； 无意义\na=5;\n函数调用语句\n#include\u0026lt;stdlib.h\u0026gt;\nsrand((int)time(0)); srand生成随机数的种子，一般是以当前时间作为随机数的种子\nrand() ; 生成一个随机整数 必须包含上述stdlib的头文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() {\tsrand((unsigned int)time(0)); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d\u0026#34;, rand()%100); } printf(\u0026#34;\\n\u0026#34;); return 0; } 控制语句之分支语句：\n1.if{}\n2.if{}\nelse{}\n3.if{}else if 可以有多个else if\n{}\nelse //else部分可以省略\n{}\n判断函数奇偶性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() {\tint value = 0; printf(\u0026#34;Please input an integer:\\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;value); if (value % 2 == 0) { printf(\u0026#34;%d is an even number\\n\u0026#34;, value); } else { printf(\u0026#34;%d is an odd number\\n\u0026#34;, value); } return 0; } 语句里只有一句话可以不加大括号，否则需要\n大写转换小写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() {\tchar ch; printf(\u0026#34;Please input an character:\\n\u0026#34;); scanf_s(\u0026#34;%c\u0026#34;,\u0026amp;ch,1); if(ch\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;Z\u0026#39;) { ch+=\u0026#39;a\u0026#39;-\u0026#39;A\u0026#39;; } printf(\u0026#34;%c\\n\u0026#34;,ch); return 0; } 条件判断必不可少，否则如果输入了其他数字会导致输出出错\n控制语句之分支语句：switch语句 switch语句是一种多路判定语句，它测试表达式是否与一些常量整数值中的某一个值匹配，并执行相应的分值动作。所以switch语句也是一种分支语句，可以和if语句互相转换。\nswitch(a) // a只能为整数(char,short,int,long等)，不能为指针，浮点数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char ch; printf(\u0026#34;Please unput the score level:\\n\u0026#34;); scanf_s(\u0026#34;%c\u0026#34;, \u0026amp;ch, 1); switch (ch) { case \u0026#39;A\u0026#39;: printf(\u0026#34;your score \u0026gt;=90\\n\u0026#34;); break; case \u0026#39;B\u0026#39;: printf(\u0026#34;your score \u0026gt;=80\\n\u0026#34;); break; default: printf(\u0026#34;your score \u0026lt;=60\\n\u0026#34;); } return 0; } 控制语句之循环语句：for,while,do-while 表达式1，可以进行初始化\n条件表达式，用来控制循环是否开始或退出的\n表达式3，更新，比如i++，用来更新循环里的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 循环求和 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int sum = 0; for (int i = 0; i \u0026lt; 10; i++) { sum += i; } printf(\u0026#34;sum:%d\\n\u0026#34;,sum); return 0; } do while循环后有分号，\n先执行循环体，再执行是否符合条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int i = 0; do { printf(\u0026#34;i:%d\\n\u0026#34;,i); i++; } while (i \u0026gt; 100); return 0； } 会输出一个i = 0，因为是先执行循环体语句，再执行while语句，不符合条件即停止。\n控制语句之转向语句 goto\n慎用goto\n出错处理（2内存，1文件打开失败）；\n跳出多重循环\n循环中的转向语句\nbreak 退出循环\ncontinue // 吃饭看到头发？break；吃饭筷子夹肉掉地上了？continue\n即忽略之后的语句，重新开始下一次的循环\nreturn：返回语句，后面是返回值，一般存储在寄存器中，32位放在eax中，64位放在rax中\n未定返回值可以直接return，定了就必须返回一个值\nreturn不仅退出循环，退出的是整个函数，执行return后，后续的代码将不再被执行\nreturn 0；\nreturn；\nbreak跳出多重循环\ngoto out\n可以直接跳到out的语句，一部能跳出多重循环\n复合语句\u0026amp;空语句 复合语句-{}；\n空语句-；\n第九课：编码风格 断行 一般按照运算符切断\n每一行只写一条语句方便进行调试\n1 2 a += 5; b -= 10; 分行定义变量\n1 2 3 int a=10; int b=20; int c=30; 空行分割代码块\n功能相近的代码块之间可以用空行\n1 2 3 4 5 6 7 8 9 int a=10; int b=20; int c=30; a += 5; b -= 10; printf(\u0026#34;a:%d\\n\u0026#34;,a); printf(\u0026#34;b:%d\\n\u0026#34;,b); 未缩进示例：\n判断比较\n补作业代码4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 用while来写 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int a=0,b=0; printf(\u0026#34;Please input two shuzi:\\n\u0026#34;); scanf_s(\u0026#34;%d,%d\u0026#34;, \u0026amp;a, \u0026amp;b); while (a / b \u0026gt; 0) { printf(\u0026#34;%d\u0026#34;,a); goto out; } printf(\u0026#34;%d\u0026#34;,b); out: return 0; } 用一个while和goto来写。\nif除了报错就是程序运行不完善，还在重写。\n除了goto不知道如何在循环执行完了之后忽略后续printf直接到return\n思路缺陷：\n1.怎么将第二次相除之后的结果是否为0和除数代入下一次运算的被除数\n2.循环中如何使用，应该使用几个变量来写入代码\n以下是网络搜索思路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int a, b, t; printf(\u0026#34;请输入两个数字:\\n\u0026#34;); scanf_s(\u0026#34;%d,%d\u0026#34;, \u0026amp;a, \u0026amp;b); while (a % b != 0) { t = b;//存上一轮的除数 b = a % b;//这一轮的余数做下一轮的除数 a = t;//做下一轮的被除数 } printf(\u0026#34;%d\u0026#34;, b);//最后剩下的除数就是答案 return 0; } 多设置了一个变量在循环体内赋值，更改算式的值，用的是while循环语句\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; int main(void) { int x, y, gcd; printf(\u0026#34;请输入两个正整数：\u0026#34;); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if(x \u0026lt; y) gcd = x; else gcd = y; while(x % gcd ||y % gcd) gcd--; printf(\u0026#34;gcd = %d\\n\u0026#34;, gcd); return 0; } 用if和while语句并且加上逻辑判断符，先判断大小，\n","date":"2025-10-26T00:00:00Z","image":"http://localhost:1313/p/10-26/bj_hu_df269ae190dc3e5a.jpg","permalink":"http://localhost:1313/p/10-26/","title":"10-26 程序语句与编码风格"},{"content":"第七课 (1):运算符 运算符是指对特定类型的变量或者常量要进行的操作，在运算符中被操作的变量或者常量叫做操作数。只有一个操作数的运算符叫单目运算符，只有两个操作数的叫双目运算符，有三个操作数的叫三目运算符。\n举例：\n1 2 3 4 \u0026amp;，++，！，~ 都是单目运算符 sizeof也是单目运算符 + - * / 就是一种二目运算符 ？： 唯一的三目运算符 逻辑非 !false !FALSE !0\ntrue\n!-1,!1,!2\nfalse\n自增，自减：I++,++i,i\u0026ndash;,\u0026ndash;i\ni++和i\u0026ndash; 1,c语言的内建型别：\ni++；\n++i；是没有任何区别的，单独形成语句，都是把i进行+1操作\n2.c++里\n如果i是一个对象，不是内建型别，++i的效率要比i++要高\n3.在复合表达式或者赋值语句里：\nint i=0;\nint a = i++; 先把i的值赋值给a，然后再对i进行相加// a = i ; i = i + 1 \u0026mdash;. a = 0 , i = 1\nint i=0;\nint b = ++i; // i = i + 1 ; b = i ; \u0026mdash;\u0026gt; b == 1,i == 1\n4.函数中：\nint i=0;\nprintf(\u0026ldquo;i:%d\\n\u0026rdquo;,i++);\ni = 0;\nprintf(\u0026ldquo;i:%d\\n\u0026rdquo;,++i);\ni = 0;\nprintf(\u0026quot;%d %d\\n\u0026quot;,i++,++i); // 不同的编译器产生的结果不一样\n强转 (int)3.14f \u0026ndash;\u0026gt;浮点转整数\nsizeof 用来计算类型，变量，常量的长度 如图，类型必须加括号，常量、变量可以不加括号\n/ 取商 %取余数\n比较运算符 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= == !=\n写a\u0026gt;b\u0026gt;c，需要写成 a\u0026gt;b \u0026amp;\u0026amp; b\u0026gt;c 必须单独比较\n可以用常量 == 变量的相等方式来验证是否赋值 （常量与变量比较）\na == 1 a = 1 1 = a 1 == a\n0和整数进行比较直接用== 即可\n如果是和浮点数和零比较 ,不能直接进行比较，浮点数不精确 fabs是math.h中的绝对值\nfabs(x)\u0026lt;=1e-6 \u0026mdash;\u0026gt;\n逻辑运算符：含义与计算顺序 \u0026amp;\u0026amp;：只要一个为0就停止计算 和\n||：只要一个为1就停止运算 或\n与的优先级大于或的优先级\n三目 ？： 常量变量都可以，也可以是一个符合要求的表达式\na?b:c \u0026ndash;\u0026gt;如果a为真，则取b的值为这个式子的表达式\n​ 如果a为假，则取c的值为运算符的值\n复合运算符 =\n+= a = a+50 a += 50\n*= a=a *100 a *= 100\n-= a = a -20 a -= 20\n/=\n%=\na \u0026laquo;= 2; a = a\u0026laquo;2 a左移两位\n逗号运算符 , i++,j++,(逗号表达式的求值，非常容易错)\n运算符的结合律与优先 运算符的优先级和结合律决定操作数的结合方式，当复合表达式中的运算符的优先级不同时操作数的结合方式是由优先级决定。当符合表达式中的运算符的优先级相同时，操作数的结合方式由结合律决定。不过，我们也可以使用扩号强制把操作数结合在一起。\n作业\n1.\n代码中的比较 NULL == p ,p ==NULL ,0 == i 与 i == 0 比较意义上是等效的，不过反写成0 == i ,NULL == p可以防止，如果在少打了一个等号的情况下，代码打成 0 = i 这样的代码会报错，能够有效的检查出代码错误\n2.\na %= 5 等效为 a = a % 5\na *= 5 等效为 a = a * 5\n表达式由运算符、常量及变量构成。每一个表达式，都有对应的一个值。该值与表达式中操作符的优先级和结合律有关\n逗号表达式：先算a的值，再算b的值，从左往右依次计算，f的值，就是整个式子最终的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main() { int a, b, c; a = b = 1; printf(\u0026#34;%d\\n\u0026#34;, (c = a++, b++, ++b); printf(\u0026#34;a:%d\\n\u0026#34;, a); printf(\u0026#34;b:%d\\n\u0026#34;, b); printf(\u0026#34;c:%d\\n\u0026#34;, c); return 0; } 输出结果为\n3 a:2 b:3 c:1\n1 2 3 4 int get_max(int a,int b,int c) { return (a\u0026gt;b?a:b)\u0026gt;c?(a\u0026gt;b?a:b):c; } ()(a++)++)+b会报错，a++之后是常量，常量不能再进行++\n作业\n1.\ni++和++i 单独成语句的时候，都是对i进行加1操作，无区别\n但是在赋值语句中\na = i++ 意为，先把i的值赋给a，在对其进行加1操作\na = ++i 意为，先对i进行加1操作，在赋值给a\n2.\nc=a++,b++,++b\n先算\u0026quot;=\u0026quot;,即c=a++ 结果是c = 1 ，a = 2\n然后是逗号运算符，b++和++b，取++b的值为逗号运算符的结果，即为2\n算完++b，最后算b++，即b=3\n分析结果为 a=2,c=1,b=3\n输入代码查看结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int a, b, c; a = b = 1; c = a++, b++, ++b; printf(\u0026#34;a:%d\\n,b:%d\\n,c:%d\\n\u0026#34;, a, b, c); return 0; } 结果正确\n3.分析，\n逗号运算符，从右往左开始运算，\u0026ndash;i,先减1再取i，第四个值取9，也就是整个逗号运算的值取9\n然后是i\u0026ndash;，先取i再减1，第三个值为9，i=8，\n之后++i，先加后取，i=9\n最后i++，先取后加，取9，i = 10\n表达式求值顺序结果应该为 9,9,9,9\n从编译器角度，从左到右编译，即\ni++, 取10,i=11\n++i,取12，i=12\ni\u0026ndash;,取12，i=11\n\u0026ndash;i,取10，i=10\n从左到右编译器取值应该为 10,12,12,10\n导入c语言程序中，取值为9.10.9.10。询问ai得知：\n//为了得到 9,10,9,10，我们需要一个更“激进”的假设：编译器在处理前置操作时，考虑到了所有排队中的后置操作。\n初始状态：i = 10 编译器发现：有两次后置操作（i++ 和 i--）在排队。它们的效果是 +1 和 -1，净效果为0。所以编译器“聪明地”认为，在计算前置操作时，可以忽略这些后置操作的影响，因为它们会相互抵消。 计算前置操作： ++i：基于 i=10，10 + 1 = 11。 --i：基于 i=10，10 - 1 = 9。 注意：这里 --i 的结果变成了 9。 计算后置操作： i++：取当前 i 的值。如果编译器在计算完所有前置操作后，将 i 的最终值（基于所有修改）临时设定为 9（来自 --i 的效果），那么 i++ 取到的值就是 9。 i--：同样，如果此时 i 被认为是 10（比如 ++i 的效果也应用了），那么 i-- 取到的值就是 10。 通过这种极其混乱且不符合常规逻辑的中间状态计算，理论上编译器可能产生 9,10,9,10 这样的输出。//\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int i = 10; printf(\u0026#34;%d,%d,%d,%d\\n\u0026#34;, i++, ++i, i--, --i); return 0; } 4.可以之间让两个数相减或者相除，然后进行if判定，是否大于0，或者大于1，或者余数大于0等\n1 2 3 4 5 6 7 8 9 int main() { int a,b; printf(\u0026#34;Please input two shuzi\u0026#34;); if(a/b\u0026gt;0): printf(\u0026#34;%d,a\u0026#34;); else: printf(\u0026#34;%d,b\u0026#34;); } ","date":"2025-10-25T00:00:00Z","image":"http://localhost:1313/p/10-25/bj_hu_c61698d7d7a62cf7.jpg","permalink":"http://localhost:1313/p/10-25/","title":"10-25 运算符"},{"content":"第六个：输入输出 stdio scanf 输入 printf 输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #pragma warning(disable : 4996) int main(int argc, _TCHAR* argv[]) { char c; wchar_t wc; short s; int i; long 1; //float f; //double d; //char buf[80] = {0}; printf(\u0026#34;Please input a character:\\n\u0026#34;); //scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); scanf_s(\u0026#34;%c\u0026#34;, \u0026amp;c, 1); //只能用在windos平台 printf(\u0026#34;%c\\n\u0026#34;, c); fflush(stdin); //清空回车键 printf(\u0026#34;Please input a another character:\\n\u0026#34;); scanf(\u0026#34;%C\u0026#34;, \u0026amp;wc); //宽字符，大写的C,或者wc也可以 printf(\u0026#34;%wc\\n\u0026#34;, wc); scanf_s(\u0026#34;%c\u0026#34;, \u0026amp;c, 1); fflush(stdin); printf(\u0026#34;please input a char\\n\u0026#34;); char c1 = getch();//不会显示在屏幕上 ,a prindf(\u0026#34;plesse int input a char\\m\u0026#34;); char c2 = getchar(); printf(\u0026#34;c1:%c,c2:%c\\n\u0026#34;,233,c2); fflush(stdin); return 0; } 其中scanf会提示4996的错误，调用scanf可能会导致数据溢出带来的安全风险。\n输出16进制前缀的整数\n%#x\\n 即可，如果想用0补充位数不够显示的，比如15转化为16进制为f，想要显示0f就\u0026quot;%02x\\n\u0026quot;\n输出64位整数\n__int64 value=100I64\nprintf(\u0026quot;%I64d\\n\u0026quot;,value)\nhd，短整型。d，标准整形。ld，长整型\n无符号：%u 来打印\n%f 单精度浮点数 %lf 双精度浮点数 %.7lf 保留到7位双精度浮点数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #pragma warning(disable : 4996) int main(int argc) { //char c; //wchar_t wc; //float f; //double d; char buf[80] = {0}; printf(\u0026#34;Please input a string:\\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, buf); //数组名称代表了内存地址，之前的所有数都需要取内存地址输入 printf(\u0026#34;%s\\n\u0026#34;, buf); //scanf函数遇到空格即退出函数， return 0; } 浮点数和整数可以不设定长度，因为长度固定且已知\n字符，字符串等都需要设定长度，如果输入超过设定长度的数，那么多出来的数会破坏原本存储在内存空间里的其他的数据，导致其他破坏\nscanf_s(\u0026quot;%s,buf,80\u0026quot;)\ngets_s(\u0026quot;%s,buf,80\u0026quot;)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; #pragma warning(disable : 4996) int main(int argc) { char c; wchar_t C; short s; int i; long l; __int64 value = 100I64; float f; double d; char buf[80] = {0}; printf(\u0026#34;Please input the data:\\n\u0026#34;); scanf(\u0026#34;%c%hd%d%ld%I64d%f%lf%s\u0026#34;,\u0026amp;c,\u0026amp;s,\u0026amp;i,\u0026amp;l,\u0026amp;value,\u0026amp;f,\u0026amp;d,buf); printf(\u0026#34;c:%c s:%hd i:%d l:%ld value:%I64d f:%f lf:%lf buf:%s\\n\u0026#34;, c, s, i, l, value, f, d, buf); return 0; } 多重输出，加宽字节会出bug导致无法输出。\nfd，文件描述符表，每个进程独立拥有的指向任何一打开的文件，管道，设备等任何资源的引用或句柄，一种资源调配的数字编号\n1.输入一个变量需要用取值符\u0026amp;获取其内存地址，字符串不需要，字符串的数组存储在计算机\n2.scanf函数调用\u0026quot;%ws\u0026quot;或\u0026quot;%S\u0026quot;,用w加s或者大写s来输入，printf(\u0026quot;%S\u0026quot;)同样用%S来表示输出\n3.scanf不检测缓存区，只将输入值原封不动导入，如果大于其原本设置的内存长度，会挤压其内存空间中其他数据，导致数据错误等安全问题。scanf_s能够检测缓存区，比scanf更安全\n溢出检测\n4.scanf遇到空格即会退出函数，gets会包括空格一起输入\n5.gets与gets_s和scanf与scanf_s一样，是否检测缓存区的问题\n6.getch不显示输入字符，按下任意一个键即返回.\ngetchar显示输入字符，需要按下回车键才返回\n7._getch是新的安全的函数,安全在哪：1.函数内部对线程的调动上锁，防止字符或者字节在调用的过程中被不同线程影响。2.两次不同的调用，来增加安全\n8.代码中某些函数过时，有安全风险，没有安全检测，容易产生安全漏洞\n","date":"2025-10-24T00:00:00Z","image":"http://localhost:1313/p/10-24/bj_hu_a05c4a6bdb74789f.jpg","permalink":"http://localhost:1313/p/10-24/","title":"10-24 输入输出 stdio"},{"content":"查漏补缺 初始化与预处理 区别：预处理发生在程序运行之前，也就是导入模块，替换头文件等操作\n​ 初始化发生在程序开始运行时，将代码中的值写入变量对应的内存\n程序构成 预处理，导入代码中需要的模块，函数\n编译，将输入的高级语言，转化为汇编语言，\n汇编，将汇编语言转变为机器语言，也就是二进制语言\n链接，将多个文件合并装订在一起，形成可执行文件\n壳 将原本的文件加密压缩到新文件，然后混合壳的代码形成新的可执行文件，在新的可执行文件中，文件头记录的ep即是壳的入口也就是更改之后的文件入口，而原始文件入口oep被隐藏，此为加壳\n调试信息 调试信息包含源代码，内存地址，寄存器，函数地址等大量汇编简化信息，用来辅助调试程序运行和修复错误\n程序，进程，线程 程序是静态的，是代码的链接，进程的启动器\n进程是一次程序的执行过程，拥有开始到结束运行的完整的生命周期，进程与进程之间相互隔离，通信难度大\n线程是一个进程内的cpu调度，一个进程可以有多个线程来帮助完成作业，但是线程与线程之间相互影响\n进程是资源分配的基本单元，线程是调度的基本单元\n处理器，核，cpu 核是一个计算核心，包括了算术逻辑单元核浮点数逻辑单元\ncpu是用来运算核流程控制的部件，可以同时装载多个核来提高并行处理能力\n处理器是完整的计算芯片，可能包含多个cpu和gpu\n内建型别 即函数的基本类型，c语言中一定要明确函数的类型，不同类型的数不能够轻易改变\n字符，数据，整形，布尔，头文件，实数，\n数据结构体，列表节点，二次参数 数据结构体相当于一个自定义的数据包裹，捆绑了多个不同类型的数据变量，作为一个整体来使用\n列表节点是构成“链表”的基本单元，用来帮助链表动态的增长或者缩短\n二次参数，主函数的命令行参数\n栈增长，高地址到低地址\n数据存入，低地址到高地址\nesp ding ebp di\neip 保存吓一跳要执行的指令的地址\nleave指令相当于\nrip64 eip32\n","date":"2025-10-23T00:00:00Z","image":"http://localhost:1313/p/10-23/bj_hu_b4ea9c55e4fb2c4.jpg","permalink":"http://localhost:1313/p/10-23/","title":"10-23 查漏补缺"},{"content":"第五课-变量 c语言变量定义与命名 常量:固定不变的量 100 //int 整数\n‘a’ //character 字符\n\u0026ldquo;hello world\u0026rdquo; //string 字符串\n3.1415926 //double 双精度浮点数\n1.732f //float 单精度浮点数\n#define PI 3.1415926 定义一个PI，宏定义\n变量 变量是内存或寄存器中用一个标识符命名的存储单元，可以用来存储一个特定类型的数据，并且数据的值在程序运行的过程中可以进行修改\n变量就至少可为我们提供两个信息：\n一是变量的地址，也就是操作系统为变量在内存中分配的若干内存的首地址\n二是变量的值，也就是，变量在内存中所分配的那些内存单元中所存放的数据\nint a = 10 常量赋值整型a\na = 100 修改a的值\n\u0026amp;a \u0026amp;：取值符，获得变量a在内存中的地址，常量是没有内存的，不能在常量前加\nprintf(\u0026ldquo;addr.%p,value:%d\\n\u0026rdquo;,\u0026amp;a,a);\n变量命名原则 ***变量名由字母，下划线和数字组成，但第一个字符必须为字母，下划线也被看做是字母。***大写字母与小写字母是有区别的，比如a与A是两个不同的变量名。一般大写字母组成的名字用作符号常量。\n变量名不能与C编译系统中哥已经预定义的，具有特殊用途的关键字同名。比如float,auto,break等\n一个变量的名字，一般说来，变量名与函数名应该足够长，以有效地描述所命名的变量或函数。应该避免使用短而模糊的名字，因为它们在别人理解你的程序时会带来麻烦。大多数ANSI编译程序允许有至少31个有效字符，即只有变量或函数名的钱31个字符的唯一性会被检查。一种较好的经验是使函数名的前31个字符的唯一性会被检查。一种较好的经验是使函数名或变量名读起来符合英语习惯。代码的自解释性。\n一般来说，一个局部变量的名字，建议使用比较短的名，而全局变量，使用比较长的名字。比如，一个用于循环的局部变量，一般用一个i来作为名字就足够了\n在windows平台，变量的命名一般遵循匈牙利法则，unix和linux不推荐\n基本原则：变量名=属性+类型+对象描述\nlinux：不推荐大小写混用，一般标识符或者函数名只有小写字母和数字和下划线构成\n匈牙利命名法则 图中helloworld改成人名更贴切\n其他变量法则\nlinux也可以叫做下划线命名法\n作业\n变量作用域，存储空间，生命周期 重点 绝对重点\n系统内存布局\n内核空间，只能有最高权限的内核代码才能访问\n进程空间，\nNULL空间是无法访问的\n非法区域隔离内核和进程，所有的进程进入内核空间，对所有进程共享，每个进程在进程空间中是互相隔离的，不能互相访问，传递；或者使用专门的通信\n程序内存布局\n一个进程空间的布局\n代码区存放代码，静态区存放数据\n堆区，可以在堆区上手动分配内存\n栈是从上往下增长，空间有限，不能无限增长\n内核空间严禁使用递归算法，不断调用自己的时候会吞空间\n未初始化的全局变量和静态变量（没有被定义）的值默认为零\n汇编代码会在程序运行时将没有定义的变量全部设为0，变量需要经过初始化才能使用\n变量分类：全局变量，局部变量，静态变量（静态全局变量和静态局部变量），寄存器变量\n全局变量：全局变量的说明的位置在所有函数之外，整个程序可见，生命周期为整个程序运行期间，存储位置为静态存储区\n全局静态变量：与全局变量唯一不同的地方是作用域：当前源文件，别的文件不饿能访问该变量-demo\n局部变量：在函数内部说明的变量为局部变量，只有在函数执行时，局部变量才存在，当函数执行完推出后，局部变量随之消失。作用域为函数内部，存储空间为栈\n局部静态变量：与局部变量的区别是，存储在静态区，整个程序运行期间有效，具有记忆功能，值初始化一次，下次调用函数，保留着上次函数运行之后的值-demo\n寄存器变量：不像其他变量那样在内存中存放数据，而是在cpu的寄存器中暂存数据，使用寄存器变量比使用内存变量的操作速度快得多，只有整形和字符型变量可定义为寄存器变量，由于cpu中寄存器有限，尽量减少使用数量和占用时间，用完马上释放；不能定义为全局变量，也不能定义在结构或者类中\n举例\n初始化的全局变量，存放在.data区，未初始化的全局变量存放在.bss区。例如例子中的0和p1，一个是初始化了存放在data区，一个没有初始化存放在bss区\n生命周期：变量的有效期，从创建到消亡到失去作用。全局变量，即从程序开始运行到结束运行，都有意义\n在不同源文件中定义的全局变量，他们的初始化是不分先后的。如果在同意文件中给，先定义的就先初始化。\n全局静态变量，存储空间和生命周期都与全局变量一样，但是作用域不一样，只能在当前源文件可以访问使用，别的源文件无法访问和使用，用来防止命令冲突（一个项目中不能同时出现两个一样的变量名 ）\n用extern 来声明，导入其他源文件的全局变量\n函数的调用，数据的传递，内存的分配都是在栈上\n作业\n","date":"2025-10-22T00:00:00Z","image":"http://localhost:1313/p/10-22/bj_hu_3ba1bc852e2ca5af.jpg","permalink":"http://localhost:1313/p/10-22/","title":"10-22 变量"},{"content":"类型长度与取值范围 类型长度-sizeof sizeof(char) 1 sizeof(wchar_t) 2或4 sizeof(short) 2 sizeof(int) 4 sizeof(long) 4 linux X86为4，X64为8 sizeof(float) 4 sizeof(double) 8 sizeof(bool) 1 C99之后或者C++ sizeof(BOOL） 4 win 在需要使用类型长度的时候，不要使用硬编码，直接使用1，2，4这种就是使用硬编码，使用sizeof，比如用sizeof（int）代替4，提高代码的可移植性，（同一串代码的不同平台的移植性）\nsizeof计算类型或者变量长度，字节为单位，是操作符，不是函数，在编译阶段确定，而不是运行阶段 决定一串代码是函数还是操作符，看其结果是在编译阶段确定还是在运行阶段确定，sizeof在编译阶段即确定\n各个类型表示的数的范围 最大值和最小值表示： 无符号： unsigned int max = (unsigned int)-1;//1111 1111 1111 1111 unsigned int min = 0 有符号 int max = 0x7fffffff=0111 1111 1111 1111 0x7f ff ff ff int min =0x80000000 = 1000 0000 0000 1111,0x80 00 00 00 （除了符号位之外其他的全部为0）\n整数溢出之后发生什么 char(-128*-1) 上溢 1：变成最小值 下溢出1：最大值 举例：有符号 -129-1// -129 -\u0026gt;127 127+1//128 -\u0026gt;-128 无符号 255+1 = 0 0-1=255\nUTC 世界标准时，与GMT（格林尼治时间）\n类型转换 强制转换 类型转换：将一种类型转换为另一种类型，一种类型指针转为另一种类型指针 强制转换：（新类型，写要转换的哪一个量）变量 从小到大：小，指的是字节小，从字节小的转化为字节大的 char c = \u0026lsquo;a\u0026rsquo; short i = (short)c int a = (int)i unsigned int u = (unsigned int)a （有符号数和无符号数也能强制转化） long b = (long)a float c = (float)b double d = (double)c 小到大转换的时候，符号位填充多出的尾数 00110101 \u0026ndash;\u0026gt; 00000000 00110101 \u0026ndash;\u0026gt; 10110100 \u0026ndash;\u0026gt;11111111 10110100 \u0026ndash;\u0026gt; short s = 0x12 int i = (int) s ..i -\u0026gt;0x00 00 00 12 short s = -0xff ee //-18 int i = (int)s //i -\u0026gt;0xff ff ff ee\n浮点数到整数 int i =(int)3.14 //取整，非四舍五入\n从大到小： int x = 0x12345678 short y = (short)x y==0x5678截断，丢弃高位 大字节缩小到小字节\n自动（隐式）转换（1） 1）若参与运算量的类型不同，则先转换成同一类型，然后进行运算 2）转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算 a.若两种类型的字节数不同，转换成字节数高的一种类型 b.若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型 3）所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，在做运算 4）char型和short型参与运算时，必须先转换成int型 5）再赋值运算中，赋值号两边量数据类型不同时，赋值号右边量的类型将转换为左边量的类型，类型不一致，可以能降低精度 6）算数运算中，加减乘除取余以及符号运算。 不同类型数据必须转换成同一类型的数据才能运算，算数转换的原则为： a若运算数中有double型或float型，则其他类型数据均转换成该类型进行运算 b若运算数种最长的类型为long型，则其他类型数据转换lang型函数 c若运算数种最长类型为int型，则char型也转换成int型进行运算，算术转换是再运算过程中自动填充而行的 7）函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。char和short会被转换成int，float会被转化为double 8）函数有返回值时，系统将隐式地返回表达式类型转换为返回值类型，赋值给调用函数 无论是强制转换后世自动转换，都只是为了本次运算的需要而对变量的数据长度进行的临时性转换，而不改变数据说明是对该变量定义的类型 float f = 5.34f int x = (int)f f虽为强制转为int型，但只在运算中起作用，是临时的，而f本身的类型并不改变\n赋值中的类型转换 当赋值运算符两边的运算对象类型不匹配时，将要发生的类型转换，转换的规则是：把赋值运算符右侧表达式的类型转换为左侧变量的类型 （1）浮点型与整形 将浮点数（单双精度）转换为整数时，将舍弃浮点数的小数部分，只保留整数部分。将整型值赋给浮点型变量，数值不变，只将形式改为浮点形式，即小数点后带若干个0，注意，负值时的类型转换实际上是强制的 （2）单双精度浮点型 由于c语言中的浮点值总是用双精度 表示的，所以float型数据知识在尾部加0延长为double型数据参加运算，然后直接赋值，double型数据转换为float型时，通过截尾数来实验，截断前要进行四舍五入操作 （3）char型与int型 int型数值赋给char型变量时，只保留其最低八位，高位部分舍弃 char型数值赋给int型变量时，一些编译程序不管其值大小都做整数处理，而另一些编译程序在转换时，若char型数据值大于127，就作为负数处理。对使用者来讲，如果原来char型数据取正值，转换后仍然为正值；如果原来char型值可正可负，则转换后也仍然保持原值，只是数据的内部表示形式有所不同 （4）int型与long型 long型数据赋给int型变量时，将低16位值送给int型变量，而将高16位截断舍弃。（这里假定int型占两个字节）将int型数据送给long型变量时，其外部值保持不变，而内部形式有所改变。 （5）无符号整数 将一个unsigned型数据赋给一个占据同样长度存储单元的整形变量时（如：unsigned-\u0026gt;int，unsigned long-\u0026gt;long，unsigned short -\u0026gt;short），原值照赋，内部的存储方式不变，但外部的值却可能改变。 将一个signed整形数据赋给长度相同的unsigned型变量时，内部存储形式不变，但外部表示时总是无符号的。\n","date":"2025-10-21T00:00:00Z","image":"http://localhost:1313/p/10-21/bi_hu_6517c387130871dc.jpg","permalink":"http://localhost:1313/p/10-21/","title":"10-21 类型长度与取值范围"},{"content":"内建型别 c语言是一个强类型的语言，数据必须明确指定类型，C++还加强了类型安全的检查 程序与数据：程序的任务：处理数据（信息），图片，视频，文本，日志，数据库等。 一个人的年龄，身高，体重，名字，健康状况，性别等数据，对应了不同的类型\nc语言标准，所有的都支持，占字节意为在磁盘中进行存储的时候必须要占这么多空间才能进行存储 字符类型：char/wchar_t 2个字节或者4个字节 char对应 wchar_t对应 整型：short 短暂，2个字节/int 标准，4个字节/long 长整型，winx86 8个字节/longlong 再linux用的多/_int64 win多，8字节 实数单精度：float 4字节 实数双精度：double 8字节 有符号和无符号：signed 有/unsigned 无,(signed)int 默认有/ unsigned int 布尔类型：bool,0/1(true/false) C99 \u0026lt;stdbool.h\u0026gt; 头文件 c语言内部支持的型别\n数据类型的实例 char gender = \u0026lsquo;M\u0026rsquo;;ASCII字符 wchar_t sex = L\u0026rsquo;F\u0026rsquo;;UNICODE字符 此字符一个字符占两个字节，ios和linux占4个字节 char name[16] = \u0026rsquo;tom\u0026rsquo;; 字符组有16个元素 wchar_t nick[16] = L\u0026rsquo;Jcak\u0026rsquo;;\nint age=30; float weight=79.1f; double height= 1.80 bool bhealthy= ture;\n内建型别，数据以字节为单位存储在内存中，不同类型的数据，存储占用的内存空间长度不同\n字符型：char./wchar_t sizeof(char) = 1 即char类型占1个字节空间 采用ASCII编码，一个字符对应一个字节 sizeof(wchar_t) = 2或者4,字符数与字节数的区别 Unicode编码，一个字符对应多个字节 char c=\u0026lsquo;a\u0026rsquo;// \u0026lsquo;a\u0026rsquo;是字符常量，c是字符变量。常量用单引号包围 \u0026lsquo;\u0026rsquo;\u0026rsquo;-\u0026gt;\u0026rsquo;'\u0026rsquo; 表示字符常量的时候用单引号引起来，单引号也是一个字符，需要用转义字符来表示该引号不是字符 wchar_t wc=L\u0026rsquo;a\u0026rsquo;; unsigned char/signed char,只写char，由编译器决定是有符号无符号 字符编码：字符在计算机中是通过字符编码（字符的id）的形式存储的，\u0026lsquo;a\u0026rsquo;-\u0026gt;97,\u0026lsquo;A\u0026rsquo;-\u0026gt;65 ASCII码，美国标准信息交换代码\nASCII码是单字节编码系统，它使用指定的7位或者8位二进制数组合来表示128或256种可能的字符 标准ASCII码也叫基础ASCII码，使用7位二进制数来表示所有的大写和小写字母，数字0-9，标点符号，以及在美式英语中使用的特殊控制字符 char c= \u0026lsquo;A\u0026rsquo;,//c=65\nchar ch=\u0026lsquo;0\u0026rsquo;;//ch=48\nUNICODE编码 ASCII编码只能表示有限的字符数，为了能够将世界上所有的字符都纳入编码范围，UNICODE字符编码便产生了，在UNICODE字符编码中，经常采用的是用2个字节或4个字节来表示一个字符，UNICODE编码的具体实现包括UTF-8，UTF-16和UTF-32。其中UTF-8中的字符占用的字节可以从1到4个，而UTF-16占两个字节，UTF-32占4个字节。 unicode编码兼容ASCII编码 \u0026lsquo;0\u0026rsquo; \u0026lsquo;1\u0026rsquo;被引号括起来，表示1和0的字符，有对应的编码，而0，和1对应的就是整数的值， 如何把一个字符转化成整数： c - \u0026lsquo;0\u0026rsquo;// \u0026lsquo;5\u0026rsquo;-\u0026lsquo;0\u0026rsquo;=5 (减0这个字符) 整数转化成字符： i + \u0026lsquo;0\u0026rsquo;// 5+\u0026lsquo;0\u0026rsquo;=\u0026lsquo;5\u0026rsquo; （加0这个字符） 大写转小写 char c = \u0026lsquo;M\u0026rsquo; c + \u0026lsquo;a\u0026rsquo; - \u0026lsquo;A\u0026rsquo; 字母大小写之间转化差32位值，所以加上小a减大A，不直接写32是为了能看懂 char ch=\u0026lsquo;y\u0026rsquo; ch + \u0026lsquo;A\u0026rsquo;-\u0026lsquo;a\u0026rsquo; a=97 A=65\n","date":"2025-10-20T00:00:00Z","image":"http://localhost:1313/p/10-20/bj_hu_11ea6599ea83224e.jpg","permalink":"http://localhost:1313/p/10-20/","title":"10-20 内建型别"},{"content":"整形 short int 简写为 short int long int 简写为 long long long _int64 char也可以看作一种整型 short a1 = 100 int a2 = 0x64 long a3 = 100L unsigned short a4 = 100 unsigned int a5 100 unsigned long a6 = 100UL long long a7 100ll;Linux _int64 a8 = 100i64 ;windows 长度不对，会容易出很多漏洞，\n浮点类型 float//单精度, 4个字节 double//双精度，8个字节 float x=3.1415f 如果不写f系统会认为这是一个双精度浮点数 double y = 1.732\n自定义新的类型 typedef int INTl typedef unsigned int UINT typedef unsigned short USHORT typedef char CHAR typedef unsigned long ULONG typedef usigned short WORD typedef unsigned int DWORD typedef unsigned char BYTE typedef unsigned int size_t\n数据结构体，列表节点，二次参数 可以用来应对c语言代码中的标准或者平台发生了变化，重新定义可以减少代码的修改量 代码更简单 统一编码风格\n","date":"2025-10-19T00:00:00Z","image":"http://localhost:1313/p/10-19/bj_hu_24ba452ff7b4968e.jpg","permalink":"http://localhost:1313/p/10-19/","title":"10-19 整形"},{"content":"程序基础 程序的编译和链接\nvc\n预处理 a.c 编译 a.i 汇编 a.s 链接 a.o(a.obj) \u0026gt; a.exe c \u0026gt; i \u0026gt; s \u0026gt; o \u0026gt; exe\n多个c会编辑成多个obj，然后与lib一起链接成exe。pe格式 (可执行文件)\npe格式存放了程序执行的代码啊，数据，资源 是一种规范和标准\nwin:. exe/.dll/.sys =\u0026gt; pe Linux: elf\n病毒分析逆向\ndos ‘MZ’ e_magic MZ 开头 0X5a4d\ndos stub 主要起兼容作用\ne_lfanew 指向 pe文件头 PE\\0\\0: 0x50 0x45 00 00\n块表 记录每一个块的位置\n块 存放着可执行代码\n调试信息\nsection 节，块，段 eop 入口点，第一条指令所在地址 oep 原入口点，壳里面的概念 epo 入口模糊 病毒概念 病毒感染了程序，模糊了入口点 imageBase:0x4000000 exe从磁盘加载到内存中，有一个基地值，不修改的话是固定的（）编译可修改 VA 加载到内存中，pe文件的每一条指令，数据，变量的虚拟地址 RVA 相对虚拟地址，相对于imagebase VOFFSET 每一节的起始的虚拟地址减去imagebase得到的值 内存中起始地址截取imagebase ROFFSET 每一节的起始地址减去文件的首地址得到的偏移 磁盘中起始地址减去文件的首地址\npeid/petool pe petool 查壳查地址 notepad++/winhex\nextrypoint eop\nep section 所在的节 text 存放代码\n程序，是指令和数据的有序集合，本身没有任何运行的含义，静态概念\n存放在磁盘上的exe程序叫做映像文件 imagefile\n进程是程序在处理机上的一次执行过程，他是一个动态的概念，拥有一个完整的生命周期\n进程的是指是程序在系统中的一次执行过程，进程是动态产生，动态消亡的\n一个程序在不同的数据集里就构成不同的进程\n不同的程序可以启动不同数量的进程\n程序在运行的时候就有一个pid标识\n进程的三个状态：\n1，就绪状态\n已经获得除了处理器的所需资源，等待分配处理器\n2，运行状态\n占用cpu资源，\n3，阻塞状态\n等待某种条件，在条件满足前无法继续执行\n线程：为了提高系统并发的度。\n一个程序至少有一个进程\n一个进程至少有一个线程，进程是资源分配的基本单元，线程的调度的基本单元\n冯诺依曼体系 cpu(算术逻辑单元和浮点数逻辑单元) 寄存器 内存(RAM) 磁盘\ncpu 》计算 》计算器 》 储存\n系统总线，控制总线，地址总线，数据总线 连接cpu和内存，通过线路传输连接计算\ncpu：多核时代，一个cpu上有多个核，每一个核就是一个processor，操作系统的视角中一个核就是一个逻辑处理器\n系统内存布局\n分为俩个部分\nuser space 应用程序运行空间 2GB内核空间 0xffffffff\nkernel space 内核空间，操作系统的运行空间 0x7fffffff 64kb非法区域\n最下层是硬件 0x7fff0000 进程空间（私有的，每一个进程 之间的内存）\n64kb null空间 应用层程序R3\n内核层R0（最高权限）\nx86支持32位寻址，pae技术可以扩大内存空间\n2^32=4GB 32位系统，四个字节\nx64内存理论上支持2^64的寻址空间，目前一般只支持到40多位\n","date":"2025-10-18T00:00:00Z","image":"http://localhost:1313/p/10-18/tutu_hu_64d12a5cb395fe5.jpg","permalink":"http://localhost:1313/p/10-18/","title":"10-18 程序基础"},{"content":"第一周学习总结（未完） 首先是在ctfplus做的题\n做了一部分misc和一部分re的题\n先说re\n有两道sign题\nsign1 在ida中反编译在代码中直接能看到flag\nsign2 根据运行提示和代码分析，flag应该是通过ROT47方式加密的\nROT47：凯撒加密变种，通过映射ASCII 字符集进行移位加密。可以将数字，字母，符号全部混合互换\n加密解密算法完全相同\n此题已知flag开头为\u0026quot;0xGame\u0026quot;,将问题喂给ai，通过python代码暴力破解可以得到答案\n不过此题中还进行了一个变换\n其中decrypt是一个解密函数，并不是常规rot47解密，此题是一个rot47的变种\n一道BaseUPX的题\n用软件检查exe发现是UPX壳，然后脱壳之后再查看反编译代码\n根据代码中base64_encode的提示，找到base64的编码，再利用ai解码\n一道睡觉zzz的题\n此题的核心是sha-256，ASCII字符，长度验证，%8x格式说明符\n根据代码提示，format error和wrong的区别，先检查格式问题，再排查其他\n然后是sscanf(s1, \u0026ldquo;0xGame{%8x%8x%8x%8x}\u0026rdquo;, \u0026amp;x1, \u0026amp;x2, \u0026amp;x3, \u0026amp;x4)这一段说明是4个8位十六进制数\nSHA=256哈希无法反推出原始数据\n最后就是编写代码使得4个十六进制数满足代码中所给出的方程，导入ai可得\n但本题还有一个问题，已在程序中获得正确提示的答案提交不对\n一道简单异或题\n找到str函数对应代码，导入ai进行编译可得\n一道dydebug复杂加密问题，四种加密方式，也是利用ai解出，具体图片未保存\n然后是misc方向的题目\n一道base64编码和凯撒加密的题目\n一道图片lsb隐写题，利用stegsolve看RGB编码解出\n最后一道是docx，利用010查询编码发现是504b0304，改格式解压得出\n接着是学习的linux基本命令，询问ai之后在系统中试过抄写命令\n","date":"2025-10-12T00:00:00Z","image":"http://localhost:1313/p/first-week/gui_hu_71ce81c2b99a7331.png","permalink":"http://localhost:1313/p/first-week/","title":"第一周总结"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2025-10-08T00:00:00Z","image":"http://localhost:1313/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"http://localhost:1313/p/emoji-support/","title":"Emoji Support"},{"content":"创建虚拟机：unbuntu 24.04.3\n新建虚拟机 自定义，典型 都可以\n自定义 \u0026ndash;\u0026gt; 稍后安装操作系统 \u0026ndash;\u0026gt; 系统加版本\n\u0026ndash;\u0026gt; 名称加位置 \u0026ndash;\u0026gt; 磁盘大小（直接创建一个磁盘会限制虚拟机总大小，最好选择拆分多个文件）内存小于自己电脑内存，满足使用即可，网络选择NAT即可\n然后启动,安装桌面版\n1.尽量英文环境，中文环境可能会有bug\n2.一些组件\n3.\u0026gt;不连接互联网，减少联网更新组件，后续需要升级自己用升级程序升级\n4.更新，\u0026gt;不更新\n5.\u0026gt;交互式安装和自动安装\n6.软件包，defalut 基础包 ，extended 拓展包\n7.专有软件\n8.磁盘的分区使用\n9.设置用户名，计算机的名字，密码\n10.时区\n11.总结\n第一次启动之后的快速配置\nskip for now \u0026ndash;\u0026gt; not share 而后finish\n完成操作系统安装\n实现虚拟机与宿主机之间文本内容，文件的快速复制和粘贴\n两个组件，开源实现\n1 2 sudo apt install pen-vm-tools sudo apt install pen-vm-tools-desktop 命令行输入 sudo apt install pen-vm-tools-desktop VM中 \u0026ndash;\u0026gt; 虚拟机 \u0026ndash;\u0026gt; 安装vmtools 也可以实现\n优化系统设置\n1.更新系统，选择镜像\nsofaware\u0026amp;updates 软件与更新\ndownload中可以测试最快的源，增加下载速度\nsudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y\n检查更新并安装最新的软件包\n2.正确的驱动，选择了显卡驱动的会自动安装，额外驱动程序\n3.安装必备app\n应用中心\n1 2 3 4 5 sudo apt install vlc gimp gparted synaptic 安装vlc媒体播放器 chrome 中心下载，然后包处运行 sudo dpkg -i ... 4.preload 提升应用启动速度（不能从app里安装）\n5.个性化仪表板（dash），自定义删除，添加，排列。键盘可以快捷启动应用\n6.系统备份，timeshift, 创建系统快照。\nsudo apt install timeshift\n7.切换主题，暗色主题\nsettings \u0026ndash;\u0026gt; appearance\n8.优化dns提升网络速度，配置谷歌dns提升网络访问速度(8.8.8.8, 8.8.4.4)\n9.优化火狐浏览器性能：在 about:config 中启用硬件加速和渲染优化\n10.Ubuntu Restricted Extras编解码支持\nsudo apt install ubuntu-restricted-extras\n11.夜间模式 settings -\u0026gt;display -\u0026gt; night light 影响色温\n12.安装 GNOME Tweaks：安装系统调整工具，注意避免修改光标主题。\ngnone-browser-connector\n13.图标包主题，个性化桌面\n14.自定义桌面搜索功能\n15.个性化设置，图标大小等\n16.分数缩放，显示设置\n","date":"2025-09-01T00:00:00Z","image":"http://localhost:1313/bj.jpg","permalink":"http://localhost:1313/p/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8/","title":"虚拟机使用"},{"content":"第一篇文章 介绍 我已出仓，感觉良好。\n刚看啥也不是，点开一看更是啥也不是\n在第一篇文章里面做一些尝试\n引用 我曾经爱过你，爱情，也许；\n在我的心灵里还没有完全消亡；\n但愿它不会再打扰你；\n我也不想再使你难过悲伤；\n我曾经默默无语，毫无指望地爱过你；\n我既忍受着羞怯，又忍受着嫉妒的折磨；\n我曾经那样真诚，那样温柔地爱过你；\n但愿上帝保佑你，它会比我更爱你。\n\u0026mdash;普希金\n莫言在《晚熟的人》里这样写道：\n“烟火人间，各有遗憾。\n想过安稳日子的女人，却嫁给了挣不来qian的男人；\n想过安稳日子的男人，却娶了爱败家的女人；\n做得一手好菜的女人，等不到回家吃饭的男人；\n经常回家吃饭的男人，偏偏娶了不会做饭的女人。\n山山而川，不过尔尔。在喜欢你的人那里去热爱生活，在不喜欢你的人那里去看清世界，就这么简单。”\n活着活着你就会明白，这个世界是守恒的。\n很多婚姻好的人，事业不行；\n事业好的人，婚姻不行；\n事业婚姻都好的人，可能身体不好。\n大部分有成就的人，大多是六亲无靠，六亲无靠大概就是他们用来交换成功的代价，所以对于很多事不必太执着。\n枕边人成不了心上人，心上人也成不了枕边人。枕边人给不了爱，心上人给不了家；\n最终，枕边人守着过了一辈子，心上人待在心里一辈子。\n我们本不善言辞，为了生活，却不得不忙于交际；\n我们本喜欢独处，为了生活，却不得不四处奔波。\n在无人问津的地方，拿尊严换qian；\n在人声鼎沸的地方，拿qian换取尊严。\n有工作的地方没有家，有家的地方没有工作。\n他乡容不下灵魂，故乡安不了肉身。\n上苍不会让所有幸福集中到某个人身上。\n得到了爱情未必拥有金qian，拥有金qian未必得到快乐；\n得到快乐未必拥有健康，拥有健康未必一切都会如愿以偿。\n你得到了这个，还想要那个，但不可能所有的好处你都能得到。你不可能同时拥有春花和秋月，也不可能同时拥有硕果和繁花。\n人生最忌讳的就是过于圆满，不信你看看身边的人。\n有人婚姻不好，但子女很优秀；\n有人婚姻很好，但身体不太好；\n有人事业很顺，但家庭不和睦；\n有人家庭和睦，日子却过得很清贫。\n人生哪能都如意，万事只能半称心。美满的婚姻是由瞎子女人和聋子男人缔成，我们都是和对方的优点谈恋爱，却和他们的缺点生活在一起，天下没有十全十美的男女。婚姻不是争输赢，半睁眼半闭眼过生活，少用放大镜看对方，否则连上帝身上都能挑出毛病。\n时光煮雨，岁月缝花。这烟火人间，事事遗憾，但事事也值得！\n图片 注意 +++ \u0026mdash; +++ 和 \u0026mdash; 是两种语法\n","date":"2021-09-03T00:00:00Z","image":"http://localhost:1313/p/first-word/121_hu_217da5c3ce36f442.jpg","permalink":"http://localhost:1313/p/first-word/","title":"人生总有第一次"}]
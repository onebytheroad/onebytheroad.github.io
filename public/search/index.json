[{"content":"1.3 汇编语言的组成 汇编指令 （可以直接翻译成机器码） 伪指令 （伪指令，用编译器执行） 其他符号 （由编译器识别） 核心是汇编指令，它决定了汇编语言的特性\n1.4 存储器 cpu是计算机的核心部件，它控制整个计算机的运作并进行运算，想cpu工作，必须提供指令和数据\n指令和数据在存储器中存放，也就是内存\n内存是其中一种存储器\npc机中内存作用仅次于cpu，离开了内存，cpu无法工作\n磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被cpu使用\n1.5 指令和数据 指令和数据是应用上的概念，在内存或磁盘上，指令和数据都是二进制信息\n1.6 存储单元 存储器被划分为若干个存储单元，每个存储单元从0开始顺序编号\n比如128个存储单元，编号0~127\n1.7 cpu对存储器的读写 用什么做，怎么做，做什么\n电子计算机处理，传输的信息都是电信号，，电信号要用导线传送\n在计算机中专门链接cpu和其他芯片的导线，通常称之为总线\n物理上：一根根导线集合 逻辑上划分： 地址总线 数据总线 控制总线 8086cpu，最基础的cpu\n1.8 地址总线 cpu是通过地址总线来指定存储单元的\n地址总线上能传送多少个不同的信息，cpu就可以对多少个存储单元进行寻址\n多少位的cpu，就是描述cpu寻址的能力，\n64位的速度需要：64位的cpu，64位的操作系统，64位的软件\n![1.8 shili](1.8 shili.png)\n最多可以寻找2的n次方个内存单元\n一个地址总线，可以索引到一个内存单元，就是一个字节，包含8个位\n1.9 数据总线 cpu与内存或其他期间之间的数据传送时通过数据总线来进行的\n数据总线的宽度决定了cpu和外界的数据传输速度\n8088cpu，一次传8位数据，传送89 D8，传两遍\n8086cpu传输，16位，比8088cpu快一倍\n1.10 控制总线 cpu对外部器件的控制是通过控制总线来进行。这里控制总线是一个总称，控制总线是一些不同控制线的集合\n有多少根控制总线，就意味着cpu提供了对外部器件的多少钟控制\n所以，控制总线的宽度绝对cpu对外部器件的控制的能力\n控制总线发送控制信息\n内存读写的命令是由几根总控制线综合发出的：其中由一根名为读信号输出控制线负责由cpu向外传送读信号，cpu向该控制线上输出低电平表示将要读取数据；\n有一根名为写信号输出控制线负责由cpu向外传送写信号\n小结： 1.11 内存地址空间（概述） 内存地址空间\n一个cpu的地址线宽度为10，那么可以寻址到1024个内存单元，这1024个可寻到的内存单元就构成这个cpu的内存地址空间\n1.12 主板 每一台pc机种，都有一个主板，主板上由核心器件和一些主要器件\n器件通过总线相连\n1.13 接口卡 计算机系统中，所有可用程序控制其工作的设备，都必须受到cpu的控制\ncpu对外部设备不能直接控制，如显示器，音响，打印机等。直接控制这些设备进行工作的是插在拓展插槽上的接口卡\n接口卡通过总线与cpu相连，cpu可以通过总线向接口卡发送指令，以此来间接控制设备\n1.14 各类存储器的芯片 从读写属性上看分为两类：\n随机存储器（RAM）和只读存储器（ROM）\n内存就是一个大的随机存储器，断了电之后数据将会遗失\n(主随机存储器一般是由装载主板上的RAM和插在拓展插槽上的RAM组成)\n只读存储器，永远只能读，数据只要不把他刷掉，一直都存在那里\n装有BIOS的ROM BIOS: Basic Input/Output System 基本输入输出系统\nBIOS是由主板个各类接i卡（显卡，网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最近本的输入输出。子在主板你和某些接口卡上插有存储相应的BIOS的ROM\n从功能和连接上分类：\n随机存储器RAM 装有BIOS的ROM 接口卡上的RAM 某些接口卡上的RAM需要对大批量输入输出数据进行存储，比如显示卡上的RAM，一般叫显存\nPC机种各类存储器的逻辑链接情况\n各类储存器的逻辑链接\n1.15 内存地址空 上述那些存储器在物理上是独立的器件\n以下两点相同\n都和cpu的总线相连 cpu对他们进行读或写的时候都通过控制线发出内存读写命令 不同的计算机内存的分配地址是不同的\n内存地址空间：\n最终运行程序的是cpu，我们用汇编编程的时候，必须从cpu角度考虑问题 对cpu来将，系统中所有的存储器中的存储单元都处于一个统一的逻辑储存器中，它的容量受cpu寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间\n地址总线宽度，决定了定位的地址单元的数量，地址单元的数量，决定了cpu能够访问到的地址，也是各类设备能够储存的地址空间 补充 电平，电信号的电压值，两个不同的电压范围用来表示二进制\n管脚，也叫引脚，cpu与外部电路进行连接的接口\n存储单元，存储器最小寻址单位，每个单元占一个字节，\n1Byte = 1 bit -\u0026gt; 1KB = 8*1024 bit = 1024B\n第二章 寄存器（cpu工作原理） CPU，寄存器 一个典型的CPU由运算器，控制器，寄存器等器件组成，器件靠内部总线相连\n区别：\n内部总线实现CPU内部各个器件之间的联系\n外部总线实现CPU和主板上其他器件的联系\n2.1 通用寄存器 8086CPU由14个寄存器，名称为AX,BZ,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW\n8086CPU所有的寄存器都是16位的，可以存放两个字节\nAX,BX,CX,DX 通常用来存放一般性数据被称之为通用寄存器\nAX作例子\n![2.1 jicunqi8weio](2.1 jicunqi8weio.png)\n2.2 字在寄存器中的存储 字 word = 2B 8086 8位升级到16位， 把一次性读取16位的内存单元称之为字\n2.3 几条汇编指令 示例：\n8226H+8226H 进位溢出 1044C 答案是044C\n这里的1被放到了进制位中去（请听下回分解）\n0000H 其中，AH代表了ax的高位，AL代表了ax的低位\nadd ah，bl 就是对ax的高位和bx的低位进行运算\n答案不等于0158H，AH和AL是两个分开的存储，溢出了不会互相进入，会抛到另一个地方\n如果是ax则为0158H\n监测点2.1 另附 add al,6\tax=\n​\tadd al.al\tax=\n​\tmov ax,cx\tax=\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 AX = F4A3H AX = 31A3H AX = 3123H AX = 6246H BX = 826CH CX = 6246H AX = 826CH AX = 04D8H AX = 0482H AX = 6C82H AX = D882H AX = D888H AX = D810H AX = 6246H （2）只能使用目前削过的汇编指令，最多能够使用四条指令，编程计算2的4次方\nadd ax,0008H\nadd ax,0008H\n1 2 3 4 add ax,2 add ax,ax add ax,ax add ax,ax 2.4 物理地址 cpu访问内存单元是要给出内存单元的地址，所有的内存单元构成的存储空间是一个一位的线性空间。\n我们将这个唯一的地址成为物理地址。\n线性空间里的每一个存储单元都有唯一的地址，这个唯一的地址称为物理地址\n","date":"2025-11-16T00:00:00Z","image":"http://localhost:1313/p/11-16/bj_hu_bf82909c341e984d.jpg","permalink":"http://localhost:1313/p/11-16/","title":"11-16 笔记"},{"content":"2.\n某酒店有若干楼层，每层有若干房间。\n请你编写一个程序，使用 三维指针 char ***hotel 存储所有房间的住客姓名。\n要求：\n从键盘输入楼层数 f 和每层的房间数 r。 动态分配三维指针内存，使得每个房间都能存放一个住客姓名字符串。 用户依次输入每个房间的住客姓名（如空房请输入 \u0026quot;Empty\u0026quot;）。 程序输出整个酒店的入住情况（按楼层打印）。 最后释放所有分配的内存 输入\n1 2 3 4 5 6 7 2 3 Alice Bob Empty Cindy David Eve 输出\n1 2 3 4 5 6 7 8 9 酒店入住情况： 第 1 层： 房间 1: Alice 房间 2: Bob 房间 3: Empty 第 2 层： 房间 1: Cindy 房间 2: David 房间 3: Eve 代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int f, r; printf(\u0026#34;input hotel`s floor and room:\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;f, \u0026amp;r); char*** hotel = (char***)malloc(f * sizeof(char**)); for (int i = 0; i \u0026lt; f; i++) { hotel[i] = (char**)malloc(r * sizeof(char*)); for (int j = 0; j \u0026lt; r; j++) { hotel[i][j] = (char*)malloc(20 * sizeof(char)); } } for (int i = 0; i \u0026lt; f; i++) { for (int j = 0; j \u0026lt; r; j++) { printf(\u0026#34;input human`s name:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, hotel[i][j]); } } printf(\u0026#34;酒店入住情况:\\n\u0026#34;); for (int i = 0; i \u0026lt; f; i++) { printf(\u0026#34;第%d层:\\n\u0026#34;, i + 1); for (int j = 0; j \u0026lt; r; j++) { printf(\u0026#34;房间%d:%s\\n\u0026#34;, j + 1, hotel[i][j]); } } for (int i = 0; i \u0026lt; f; i++) { for (int j = 0; j \u0026lt; r; j++) { free(hotel[i][j]); } free(hotel[i]); } free(hotel); return 0; } 逆s盒替换 逆s盒：\n初始化s盒\n1 2 3 4 5 6 7 8 9 10 uint8_t i,j; uint8_t s_box_ary[16][16] = {0}; for(i=0;i\u0026lt;0x10;i++) { for(j=0;j\u0026lt;0x10;j++) { s_box_ary[i][j] = ((i\u0026lt;\u0026lt;4)\u0026amp;0xF0) + (j\u0026amp;(0xF)); } } 使得每行每列按顺序打印\n欧几里得算法拓展\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 printf(\u0026#34;\\r\\n\u0026#34;); for(i=0;i\u0026lt;0x10;i++) { for(j=0;j\u0026lt;0x10;j++) { if(s_box_ary[i][j] != 0) { s_box_ary[i][j] = extEuclidPolynomial(s_box_ary[i][j],0x11B); } } } printf(\u0026#34;\\r\\n\\r\\n 0 1 2 3 4 5 6 7 8 9 A B C D E F\u0026#34;); for(i=0;i\u0026lt;0x10;i++) { printf(\u0026#34;\\r\\n%2x\u0026#34;,i); for(j=0;j\u0026lt;0x10;j++) { printf(\u0026#34; %2x\u0026#34;,s_box_ary[i][j]); } } 这样可以得到一个再GF（2^8）的域里的的逆，0映射到自身\n之后还可以对每一个字节进行变换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 for(i=0;i\u0026lt;0x10;i++) { for(j=0;j\u0026lt;0x10;j++) { s_box_ary[i][j]=byteTransformation(s_box_ary[i][j], 0x63); } } printf(\u0026#34;\\r\\n\\r\\n 0 1 2 3 4 5 6 7 8 9 A B C D E F\u0026#34;); for(i=0;i\u0026lt;0x10;i++) { printf(\u0026#34;\\r\\n%2x\u0026#34;,i); for(j=0;j\u0026lt;0x10;j++) { printf(\u0026#34; %2x\u0026#34;,s_box_ary[i][j]); } } } re逆s盒代码题目：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; void Create_Inv_SBOX(unsigned char SBOX_AFTER[256]) { unsigned char SBOX[256] = { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16 }; for (int i = 0; i \u0026lt; 256; i++) { SBOX_AFTER[SBOX[i]] = i ; } } int Inv_SubBytes() { char* path = \u0026#34;d:\\\\11\\\\1.bin\u0026#34;; char* path1 = \u0026#34;d:\\\\11\\\\1.jpg\u0026#34;; FILE* fp = NULL; FILE* fp1 = NULL; errno_t err = fopen_s(\u0026amp;fp, path, \u0026#34;rb\u0026#34;); if (err != 0 || fp == NULL) { return -1; } fseek(fp, 0, SEEK_END); int SIZE = ftell(fp); fseek(fp, 0, SEEK_SET); printf(\u0026#34;%d\\n\u0026#34;, SIZE); unsigned char* buf = (unsigned char*)malloc(SIZE); fread(buf, 1, SIZE, fp); fclose(fp); unsigned char SBOX_AFTER[256] = { 0 }; Create_Inv_SBOX(SBOX_AFTER); err = fopen_s(\u0026amp;fp1, path1, \u0026#34;wb\u0026#34;); if (err != 0 || fp == NULL) { return -1; } unsigned char* p = buf; for (int i = 0; i \u0026lt; SIZE; i++) { p[i] = SBOX_AFTER[p[i]]; } fwrite(p, 1, SIZE, fp1); fclose(fp); return 0; } static int main() { Inv_SubBytes(); return 0; } 1.1 机器语言 引言\n课程的目的主要是研究如何让硬件更有效率的工作\n1.2 汇编语言的产生 寄存器：cpu中可以储存数据的期间，一个cpu可以有多个寄存器\n寄存器的代号表示有不同作用的寄存器\n","date":"2025-11-15T00:00:00Z","image":"http://localhost:1313/p/11-15/bj_hu_27bf33d33c509316.jpg","permalink":"http://localhost:1313/p/11-15/","title":"11-15 笔记"},{"content":"5.从标准输入读入 R×C 矩阵，将其：\n以整齐的表格形式写入文本文件 matrix.txt； 以二进制格式写入 matrix.bin，格式为（均 32 位小端有符号整数）：R、C 头两个数，然后是按行主序存放的 R*C 个元素。 示例输入\n1 2 3 2 3 11 26 32 24 85 96 matrix.txt 内容（文本）：\n1 2 11 26 32 24 85 96 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int WriteFile(int **arr,int R,int C) { char *path = \u0026#34;d:\\\\11\\\\matrix.txt\u0026#34;; FILE* file = NULL; errno_t err = fopen_s(\u0026amp;file,path,\u0026#34;w\u0026#34;); if (err != 0 \u0026amp;\u0026amp; file == NULL) { return -1; } for (int i = 0; i \u0026lt; R; i++) { for (int j = 0; j \u0026lt; C; j++) { fprintf(file,\u0026#34;%d \u0026#34;,arr[i][j]); } fprintf(file,\u0026#34;\\r\\n\u0026#34;); } fclose(file); } int WriteFileBin(int** arr, int R, int C) { char* path = \u0026#34;d:\\\\11\\\\matrix.bin\u0026#34;; FILE* file = NULL; errno_t err = fopen_s(\u0026amp;file, path, \u0026#34;wb\u0026#34;); if (err != 0 \u0026amp;\u0026amp; file == NULL) { return -1; } for (int i = 0; i \u0026lt; R; i++) { for (int j = 0; j \u0026lt; C; j++) { fwrite(\u0026amp;arr[i][j], sizeof(int),1,file); } } fclose(file); err = fopen_s(\u0026amp;file, path, \u0026#34;rb\u0026#34;); if (err != 0 || file == NULL) { return -1; } int buf[128*128] = {0}; fread(buf, sizeof(int), R * C, file); for (int i = 0; i \u0026lt; R*C; i++) { printf(\u0026#34;buf:%d\\n\u0026#34;, buf[i]); } fclose(file); } int main() { int a, b; printf(\u0026#34;input R\u0026amp;C:\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); int** arr = (int**)malloc(a * sizeof(int*)); for (int i = 0; i \u0026lt; a; i++) { arr[i] = (int*)malloc(b * sizeof(int)); } for (int i = 0; i \u0026lt; a; i++) { for (int j = 0; j \u0026lt; b; j++) { printf(\u0026#34;input data:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i][j]); } } WriteFile(arr,a,b); WriteFileBin(arr, a, b); free(arr); return 0; } 1.编写一个程序，定义一个 Student 结构体，包含以下成员：\nchar name[20] —— 学生姓名 int id —— 学号 float score —— 成绩 要求：\n从键盘输入 n 个学生的信息。 按成绩从高到低排序（若成绩相同则按学号升序）。 输出排序后的学生信息。 输入\n1 2 3 4 5 6 5 Alice 1001 85.5 Bob 1003 90.0 Cindy 1002 90.0 David 1004 78.0 Eve 1005 85.5 输出\n1 2 3 4 5 6 排序后的学生信息： Bob 1003 90.00 Cindy 1002 90.00 Alice 1001 85.50 Eve 1005 85.50 David 1004 78.00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct Student { char name[20]; int id; float score; }Student, * pStudent; int main() { int a; printf(\u0026#34;input quantity:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); Student* stu= (Student*)malloc(a * sizeof(Student)); if (stu == NULL) { return -1; } for (int i = 0; i \u0026lt; a; i++) { printf(\u0026#34;input stu message:\u0026#34;); scanf(\u0026#34;%s %d %f\u0026#34;, stu[i].name, \u0026amp;stu[i].id, \u0026amp;stu[i].score); } for (int i = 0; i \u0026lt; a; i++) { for (int j = i+1; j \u0026lt; a; j++) { if (stu[i].score \u0026lt; stu[j].score) { Student tmp = { 0 }; tmp = stu[j]; stu[j] = stu[i]; stu[i] = tmp; } if (stu[i].score == stu[j].score \u0026amp;\u0026amp; stu[i].id \u0026lt; stu[j].id) { Student tmp = { 0 }; tmp = stu[j]; stu[j] = stu[i]; stu[i] = tmp; } } } for (int i = 0; i \u0026lt; a; i++) { printf(\u0026#34;%s %d %.2f\\n\u0026#34;, stu[i].name, stu[i].id, stu[i].score); } free(stu); return 0; } ","date":"2025-11-14T00:00:00Z","image":"http://localhost:1313/p/11-14/bj_hu_1a685397fb5dca45.jpg","permalink":"http://localhost:1313/p/11-14/","title":"11-14 笔记"},{"content":"4.定义一个名为 BinaryString 的结构体，包含一个字符串 str 用于存储二进制数字，和一个整型变量 length 用于存储字符串的长度。编写一个函数，ring` 结构体数组中，最后返回这个数组\n示例输入：\n1 hello 输出：\n1 2 3 4 5 h: 01101000 e: 01100101 l: 01101100 l: 01101100 o: 01101111 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef struct BinaryString { char str; int length; }BinaryString,*pBinaryString; void PrintBinary(unsigned char dec) { unsigned int quotient = 1; unsigned int Remainder = 1; char c[8] = { 0 }; int count = 0; while (dec \u0026gt; 0) { Remainder = dec % 2; quotient = dec / 2; c[count] = Remainder; count++; dec = quotient; } for (int i = 8 - 1; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, c[i]); } printf(\u0026#34;\\n\u0026#34;); } void Change_ASCII_Bin(char a[], int len) { for (int i = 0; i \u0026lt; len; i++) { BinaryString b1 = { 0 }; b1.str = a[i]; printf(\u0026#34;%c:\u0026#34;, b1.str); char n = (int)b1.str; PrintBinary(n); } } int main() { char a[6] = {0}; printf(\u0026#34;input array:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, \u0026amp;a); int len = sizeof(a) / sizeof(a[0]) - 1; Change_ASCII_Bin(a,len); return 0; } 学习十进制转换为二进制\n以及二进制的正序逆序打印\n","date":"2025-11-13T00:00:00Z","image":"http://localhost:1313/p/11-13/bj_hu_2038fdfeff213915.jpg","permalink":"http://localhost:1313/p/11-13/","title":"11-13 笔记"},{"content":"将之前除链表，pe读取，配置文件读取的作业写了\n1.将一个2行3列的二维数组转置为3行2列的数组 1 2 3 4 5 6 7 Input 6 integers: 123 43 12 00 01 02 64 234 12 10 11 12 转换后的数组: 123 64 00 01 43 234 10 11 12 12 20 21 代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; int main() { int a[2][3] = { 0 }; int b[3][2] = { 0 }; for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 3; j++) { printf(\u0026#34;Input 6 integers:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); } } for (int i = 0; i \u0026lt; 2; i++) { for (int j = 0; j \u0026lt; 3; j++) { b[j][i] = a[i][j]; } } for (int i = 0; i \u0026lt; 3; i++) { for (int j = 0; j \u0026lt; 2; j++) { printf(\u0026#34;%d \u0026#34;, b[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 2.编写一个C语言程序，使用指针将数组{10, 20, 30, 40, 50}反转并输出结果。 实现如下：\n1 2 原数组: 10 20 30 40 50 反转后: 50 40 30 20 10 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int a[5] = { 10,20,30,40,50 }; int len = sizeof(a) / sizeof(a[0]) - 1; int* pl = \u0026amp;a[0]; int* pr = \u0026amp;a[len]; while (pl != pr) { int tmp =*pr; *pr = *pl; *pl = tmp; pl++; pr--; } for (int i=0; i \u0026lt; len+1; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } return 0; } ","date":"2025-11-12T00:00:00Z","image":"http://localhost:1313/p/11-12/bj_hu_ed96abcad5bcf6d0.jpg","permalink":"http://localhost:1313/p/11-12/","title":"11-12 笔记"},{"content":"文件的读写 格式化输入输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; int format_io() { char* filepath = \u0026#34;d:\\\\1111111111111\\\\format_io.txt\u0026#34;; FILE *fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;w\u0026#34;); if (err != 0||fp == NULL) { return -1; } // int data = 100; 可以传入变量 fprintf(fp,\u0026#34;%s %d\u0026#34;,\u0026#34;hello-world\u0026#34;,100); fclose(fp); err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0||fp == NULL) { return -1; } char buf[128] = { 0 }; int value = 0; fscanf_s(fp, \u0026#34;%s%d\u0026#34;, buf,128, \u0026amp;value); printf(\u0026#34;format io:buf:%s,value:%d\\n\u0026#34;, buf, value); fclose(fp); return 0; } int main() { format_io(); return 0; } 字符输入输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; int char_io() { char* str = \u0026#34;hello world\u0026#34;; char* filepath = \u0026#34;d:\\\\11\\\\char_io.txt\u0026#34;; FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } while (*str != \u0026#39;\\0\u0026#39;) { fputc(*str, fp); str++; } fputc(\u0026#39;\\0\u0026#39;, fp); fclose(fp); err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } while (!feof(fp))//判断是否到达文件末尾 { char ch = fgetc(fp); printf(\u0026#34;%c\u0026#34;, ch); } printf(\u0026#34;\\n\u0026#34;); fclose(fp); return 0; } int main() { char_io(); return 0; } 字符串输入输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; int str_io() { char* data[4] = { \u0026#34;hello world\\n\u0026#34;, \u0026#34;hello beijing\\n\u0026#34;, \u0026#34;hello china\\n\u0026#34;, \u0026#34;hello dlrow\\n\u0026#34; }; char* filepath = \u0026#34;d:\\\\11\\\\str_io.txt\u0026#34;; FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } for (int i = 0; i \u0026lt; 4; i++) { fputs(data[i], fp); } fclose(fp); err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } while (!feof(fp)) { char buf[128] = { 0 }; fgets(buf, 128, fp); printf(\u0026#34;str io:buf:%s\u0026#34;, buf); } fclose(fp); return 0; } int main() { str_io(); return 0; } fopen popen fwrite write 读写缓存：调用io来写入磁盘非常消耗性能，而缓存就是将写入字节累计，到一定程度在写入磁盘\n作业 （3）：文件其他相关操作 读写指针控制 读写指针，有一个指针在文件中移动，\n从文件头开始移动，表示读和写的相应位置\nrewind 移动到文件头\nfseek 第二个参数是相对位置的偏移，第三个参数是某某位置 还有后续三张是个表格黑奴奥尔不过发选举过后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;string.h\u0026gt; int seek_demo() { char* filepath = \u0026#34;d:\\\\11\\\\see_demo.txt\u0026#34;; FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } fwrite(\u0026#34;hello world\u0026#34;, strlen(\u0026#34;hello world\u0026#34;) + 1, 1, fp); fseek(fp, -6, SEEK_CUR); fwrite(\u0026#34;china\u0026#34;, strlen(\u0026#34;china\u0026#34;) + 1, 1, fp); fclose(fp); err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } fseek(fp, 6, SEEK_SET); char buf[123] = { 0 }; fread(buf, strlen(\u0026#34;china\u0026#34;) + 1, 1, fp); printf(\u0026#34;buf:%s\\n\u0026#34;, buf); //fwrite(\u0026#34;welcome world\u0026#34;, strlen(\u0026#34;welcome world\u0026#34;) + 1, 1, fp); fclose(fp); return 0; } int main() { seek_demo(); return 0; } fseek 定位末尾\nflen=ftell(fp) 读写偏移，返回值就是文件大小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;string.h\u0026gt; int seek_demo() { char* filepath = \u0026#34;d:\\\\11\\\\see_demo.txt\u0026#34;; FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } fwrite(\u0026#34;hello world\u0026#34;, strlen(\u0026#34;hello world\u0026#34;) + 1, 1, fp); fseek(fp, -6, SEEK_CUR); fwrite(\u0026#34;china\u0026#34;, strlen(\u0026#34;china\u0026#34;) + 1, 1, fp); fclose(fp); err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } fseek(fp, 6, SEEK_SET); char buf[123] = { 0 }; fread(buf, strlen(\u0026#34;china\u0026#34;) + 1, 1, fp); printf(\u0026#34;buf:%s\\n\u0026#34;, buf); //fwrite(\u0026#34;welcome world\u0026#34;, strlen(\u0026#34;welcome world\u0026#34;) + 1, 1, fp); fclose(fp); return 0; } long get_filesize(const char* filepath) { if (filepath == NULL) { return 0; } FILE *fp = NULL; errno_t err = fopen_s(\u0026amp;fp, filepath, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return 0; } fseek(fp, 0, SEEK_END); long size = ftell(fp); fclose(fp); } int main() { seek_demo(); long size = get_filesize(\u0026#34;d:\\\\11\\\\see_demo.txt\u0026#34;); printf(\u0026#34;size:%d\u0026#34;, size); return 0; } 文件重命名 1 2 3 4 5 6 7 8 9 10 11 12 13 int rename_demo() { char* file1 = \u0026#34;d:\\\\11\\\\see_demo.txt\u0026#34;; char* file2 = \u0026#34;d:\\\\11\\\\seek1_demo.txt\u0026#34;; rename(file1, file2); return 0; } 还可以重命名到其他目录里面去 不可以跨盘符重命名 文件删除 1 2 3 4 5 6 7 8 int remove_demo() { char* filepath = \u0026#34;d:\\\\11\\\\see_demo.txt\u0026#34;; int res = remove(filepath); return res; } 删除不掉可能是因为进程被占用\n作业 remind() (SEEK_CUR) (SEEK_END) (SEEK_SET)\nftell = flen 指针指向末尾在显示偏移量\n两次声明文件，一次原名字一个名字，然后调用rename 。。 删除指定文件之后调用remove\n与指向end的偏移值做对比，相等即是读到结束了\n（4）：结构体IO与优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define FILENAME \u0026#34;d:\\\\11\\\\student_data_base.dat\u0026#34; #define MAXLEN 64 typedef struct _record { char name[MAXLEN]; int age; }record,*precord; int write_record(FILE* fp) { while (1) { record r = { 0 }; printf(\u0026#34;Please input the age:\\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;r.age); if (r.age == 0) { break; } printf(\u0026#34;Please input the name:\\n\u0026#34;); scanf_s(\u0026#34;%s\u0026#34;,r.name, MAXLEN); fwrite(\u0026amp;r, sizeof(r), 1, fp); } return 0; } int read_record(FILE* fp) { while (!feof(fp)) { record r = { 0 }; int count = fread(\u0026amp;r, sizeof(r), 1, fp); if (count == 0) { break; } printf(\u0026#34;age:%d,name:%s\\n\u0026#34;, r.age, r.name); } return 0; } int main() { FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } write_record(fp); fclose(fp); err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } read_record(fp); fclose(fp); return 0; } 如图，存放年龄和名字之后，还有大量的空间被无意义的数据占用\n优化：\n在名字前面存放每一个名字的字节数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define FILENAME \u0026#34;d:\\\\11\\\\student_data_base.dat\u0026#34; #define MAXLEN 64 typedef struct _record { char name[MAXLEN]; int age; }record,*precord; int optwrite_record(FILE* fp) { while (1) { record r = { 0 }; printf(\u0026#34;Please input rhe age:\\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;r.age); if (r.age == 0) { break; } printf(\u0026#34;Please input the name:\\n\u0026#34;); scanf_s(\u0026#34;%s\u0026#34;, r.name, MAXLEN); int len = strlen(r.name); fwrite(\u0026amp;len, sizeof(len), 1, fp); fwrite(r.name, len, 1, fp); fwrite(\u0026amp;r.age, sizeof(r.age), 1, fp); } return 0; } int optread_record(FILE *fp) { while (!feof(fp)) { record r = { 0 }; int len = 0; int count = fread(\u0026amp;len, sizeof(len), 1, fp); if (count == 0) { break; } fread(r.name, len, 1, fp); fread(\u0026amp;r.age, sizeof(r.age), 1, fp); printf(\u0026#34;age:%d,name:%s\\n\u0026#34;, r.age, r.name); } return 0; } int main() { FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } optwrite_record(fp); fclose(fp); err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } optread_record(fp); fclose(fp); return 0; } 查询在数据库里人名\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 int optquery_record(FILE* fp) { char name[MAXLEN] = { 0 }; printf(\u0026#34;Please input the name :\\n\u0026#34;); scanf_s(\u0026#34;%s\u0026#34;, name, MAXLEN); bool bFind = false; while (!feof(fp)) { record r = { 0 }; int len = 0; int count = fread(\u0026amp;len, sizeof(len), 1, fp); if (count == 0) { break; } fread(r.name, len, 1, fp); fread(\u0026amp;r.age, sizeof(r.age), 1, fp); if(strcmp(r.name,name)==0) { printf(\u0026#34;found it,age:%d,name:%s\\n\u0026#34;, r.age, r.name); bFind = true; break; } } if (!bFind) { printf(\u0026#34;nor found\\n\u0026#34;); } } 此处报错，可能是进行比较时没有清零，未匹配上\n问题：在第一次record时文件指针移动到文件末尾，而后续指针调用实际上无法再进行遍历\n修改后代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #define FILENAME \u0026#34;d:\\\\11\\\\student_data_base.dat\u0026#34; #define MAXLEN 64 typedef struct _record { char name[MAXLEN]; int age; }record,*precord; int optwrite_record(FILE* fp) { while (1) { record r = { 0 }; printf(\u0026#34;Please input rhe age:\\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;r.age); if (r.age == 0) { break; } printf(\u0026#34;Please input the name:\\n\u0026#34;); scanf_s(\u0026#34;%s\u0026#34;, r.name, MAXLEN); int len = strlen(r.name); fwrite(\u0026amp;len, sizeof(len), 1, fp); fwrite(r.name, len, 1, fp); fwrite(\u0026amp;r.age, sizeof(r.age), 1, fp); } return 0; } int optread_record(FILE *fp) { while (!feof(fp)) { record r = { 0 }; int len = 0; int count = fread(\u0026amp;len, sizeof(len), 1, fp); if (count == 0) { break; } fread(r.name, len, 1, fp); fread(\u0026amp;r.age, sizeof(r.age), 1, fp); printf(\u0026#34;age:%d,name:%s\\n\u0026#34;, r.age, r.name); } return 0; } int optquery_record(FILE* fp) { char name[MAXLEN] = { 0 }; printf(\u0026#34;Please input the name :\\n\u0026#34;); scanf_s(\u0026#34;%s\u0026#34;, name, MAXLEN); bool bFind = false; rewind(fp); while (!feof(fp)) { record r = { 0 }; int len = 0; memset(\u0026amp;r, 0, sizeof(r)); int count = fread(\u0026amp;len, sizeof(len), 1, fp); if (count == 0) { break; } fread(r.name, len, 1, fp); fread(\u0026amp;r.age, sizeof(r.age), 1, fp); if(strcmp(r.name,name)==0) { printf(\u0026#34;found it,age:%d,name:%s\\n\u0026#34;, r.age, r.name); bFind = true; break; } } if (!bFind) { printf(\u0026#34;nor found\\n\u0026#34;); } return 0; } int main() { FILE* fp = NULL; errno_t err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;w\u0026#34;); if (err != 0 || fp == NULL) { return -1; } optwrite_record(fp); fclose(fp); err = fopen_s(\u0026amp;fp, FILENAME, \u0026#34;r\u0026#34;); if (err != 0 || fp == NULL) { return -1; } optread_record(fp); optquery_record(fp); fclose(fp); return 0; } 删除：\n找到这一条记录，将后面的记录重新覆盖前一条数据\n更新：\n1.更新年龄，更改覆盖\n2.更改名字，名字长度更改，会破坏储存数据。只能够使用临时文件，拷贝之前的文件，然后写入，再拷贝之后的文件，在删除源文件\n作业 ","date":"2025-11-11T00:00:00Z","image":"http://localhost:1313/p/11-11/bj_hu_a555a92545837721.jpg","permalink":"http://localhost:1313/p/11-11/","title":"11-11 笔记"},{"content":"（2）：递归的应用 问题1\n1 2 3 4 5 6 7 8 9 10 11 int mystrlen(const char* str) { if (str == NULL || *str == \u0026#39;\\0\u0026#39;) { return 0; } return 1 + mystrlen(str + 1); //一句话计算出非空字符串的长度 //(str==NULL || *str==\u0026#39;\\0\u0026#39;)?0:1+mystelen(str+1) } 问题2\n1 2 3 4 5 6 7 8 9 void reverse_print(const char *str) { if(str==NULL || *str==\u0026#39;\\0\u0026#39;) { return; } reverse_print(str+1); printf(\u0026#34;%c\u0026#34;,*str); } 直接定义*指向内存地址是静态区不可更改，需要改成在栈上才可以更改\n比如：\nchar *str=\nchar buf[] =\n问题3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void reverse_str(char *str,int len) { if (str == NULL || *str == \u0026#39;\\0\u0026#39; || len==0) { return 0; } reverse_str(str + 1,len-2); char tmp = *str; *str = *(str + len - 1); *(str + len -1)=tmp; return; } 运用递归 作业 寻找解决问题的子式，也就是寻找一个式子能让递归一直嵌套下去直到嵌套到递归出口\n递归或者循环解决\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 int fibonacci(int n) { if(n == 0) { return 0; } else if(n == 1) { return 1; } else { return fibonacci(n-1) + fibonacci(n-2); } } int main() { int n; printf(\u0026#34;请输入一个整数：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;斐波那契数列的第%d项为：%d\\n\u0026#34;, n, fibonacci(n)); return 0; } #include\u0026lt;stdio.h\u0026gt; // 斐波那契数列函数 int fibonacci(int n) { if(n \u0026lt;= 1) { return n; } int a = 0, b = 1; for(int i = 2; i \u0026lt;= n; i++) { int temp = a + b; a = b; b = temp; } return b; } int main() { int n; printf(\u0026#34;请输入一个整数：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;斐波那契数列的第%d项为：%d\\n\u0026#34;, n, fibonacci(n)); return 0; } 第二十课-文件 （1）：文件概念 文件分类 文件系统 文本文件与二进制文件 字符编码\n基于值编码\n作业 文本文件，基于字符编码的方式编写 二进制文件，基于值编码的方式的文件 文件系统：管理，读写，调用一个文件的数据结构 FAT ZFS\n（2）：文件创建、打开与读写 1 2 3 4 5 6 7 8 9 10 fopen(\u0026#34;newfile.txt\u0026#34;,\u0026#34;w,ccs=UTF-8\u0026#34;); 第一个参数是路径，路径分为相对路径和绝对路径 第二个参数是文件的打开方式， r 读 w 写 文本方式打开，存在换行之间的转换 css 用来指定文件打开的编码 默认为ascii编码，可以通过读取文件头的形式来获取文本所用的编码方式 记得关闭文件，否则会一直有程序或者进程占用文件使用\nfopen也是老函数，需要安全的调用，\nfopen_s(\u0026amp;pfile)指针的值\n1 2 _mkdir 创建文件夹的指令 \u0026lt;direct.h\u0026gt; 包含 代码演示 创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; int create_file() { char* path = \u0026#34;d:\\\\1111111111111\\\\mallocfree.txt\u0026#34;; FILE *file = fopen(path, \u0026#34;w\u0026#34;); if (file == NULL) { return -1; } fclose(file); return 0; } int main() { create_file(); return 0; } 打开\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int open_file() { char* path = \u0026#34;d:\\\\111111111111\\\\mallocfree.txt\u0026#34;; FILE* file = NULL; errno_t err = fopen_s(\u0026amp;file, path,\u0026#34;r\u0026#34;); if (err != 0 || file == NULL) { return -1; } fclose(file); return 0; } 创建文件夹\n1 2 3 4 5 6 7 8 int create_dir() { char* dirpath = \u0026#34;d:\\\\1111111111111\\\\mf\\\\\u0026#34;; int res = _mkdir(dirpath); return res; } 文件的读写 buffer 数据 size 字节数 ntime 写入多少长度 fp 文件指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;direct.h\u0026gt; #include \u0026lt;windows.h\u0026gt; void binaryio_demo() { char* filepath = \u0026#34;d:\\\\1111111111111\\\\binary_io.txt\u0026#34;; FILE* file = NULL; errno_t err = fopen_s(\u0026amp;file, filepath, \u0026#34;w\u0026#34;); if (err != 0 || file == NULL) { return -1; } fwrite(\u0026#34;hello world\u0026#34;, strlen(\u0026#34;hello world\u0026#34;) + 1, 1, file); int date = 100; fwrite(\u0026amp;date, sizeof(date), 1, file); fclose(file); err = fopen_s(\u0026amp;file, filepath, \u0026#34;r\u0026#34;); if (err != 0 || file == NULL) { return -1; } char buf[128] = { 0 }; fread(buf, strlen(\u0026#34;hello world\u0026#34;) + 1, 1, file); int value = 0; fread(\u0026amp;value, sizeof(value), 1, file); printf(\u0026#34;buf:%s,value:%d\u0026#34;, buf,value); fclose(file); } int main() { binaryio_demo(); return 0; } ","date":"2025-11-10T00:00:00Z","image":"http://localhost:1313/p/11-10/bj_hu_ea35ef0b1f970c1a.jpg","permalink":"http://localhost:1313/p/11-10/","title":"11-10 笔记"},{"content":"第十八课-宏 （1）：宏的定义 例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define PI 3.14 float calc_circle_area(float r) { return PI * r * r; } int main() { printf(\u0026#34;s:%.2lf\u0026#34;, calc_circle_area(1.1f)); return 0; } 宏定义不带分号\n宏定义优缺点 c++ 中可以设置常变量\n带参数的宏定义-MAX 理解宏展开：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define MAX(X,Y) X\u0026gt;Y?X:Y int main() { printf(\u0026#34;max:%d\\n\u0026#34;, MAX(7, 2)); printf(\u0026#34;max:%d\\n\u0026#34;, MAX(1\u0026amp;7, 5-2)); return 0; } 原封不动的打包替换 第二个 1\u0026amp;7\u0026gt;5-2?1\u0026amp;7:5-1 先算减法，然后比较运算，然后与运算，然后三目运算 1\u0026amp;1?1\u0026amp;7:4 1?1:4 修改的话，可以给x y整个变量打上括号，这样替换位置的时候先算括号里的 如果使用 int getmax(int x , int y) { return x\u0026gt;y?x:y; } 不加括号也可以使用 宏定义会直接替换，函数的话会计算之后再传参 带参数的宏与函数优缺点比较 函数有出栈和入栈的调用过程，效率低于宏\n函数还有参数的安全检测，比如参数的类型，如果穿的参数不匹配对应的类型，则无法匹配\n作业 不带参数，优点：效率高，\n缺点：无法调试，无法修改\n带参数，优点：效率高，直接替换，没有进出栈\n缺点：直接替换而无法进行计算，以及不能进行类型检查\n#define calcula_array(arr) (sizeof(arr)/sizeof(arr[0]))\n#define a=a^b,b=a^b,a=a^b\n（2）：宏的应用与注意事项 两个数的交换 宏写法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define SWAP(a,b) \\ int tmp; \\ tmp = a; \\ a = b; \\ b = tmp; int main() { int a = 10; int b = 25; printf(\u0026#34;a is not less than b\\n\u0026#34;); printf(\u0026#34;a:%d,b:%d\\n\u0026#34;, a, b); SWAP(a, b); printf(\u0026#34;a:%d,b:%d\\n\u0026#34;, a, b); return 0; } 会有一个问题\n即，如果在if条件下，原宏定义为使用括号，如果条件下未用括号，会导致宏展开的语句也没有括号，使得程序报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 即 if(a\u0026gt;b) SWAP(a,b); else printf() 两种办法解决 第一种是语句加上括号 第二种是在原宏定义加上do while #define SWAP(a,b) \\ do{ \\\tint tmp; \\ tmp = a; \\ a = b; \\ b = tmp; \\ }while(0) 软件生产宏定义 宏应用 偏移语句中未对0进行解引用，不会引起报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct _S { int i; char ch; }S,*PS; #define OFFSETOF(s,m) (size_t)(\u0026amp;(((s *)0)-\u0026gt;m)) int main() { printf(\u0026#34;offset of i:%d, ch:%d\\n\u0026#34;, OFFSETOF(S, i), OFFSETOF(S, ch)); return 0; } 常用 链表中某一个数据的偏移\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define ARRAYSIZE(a) sizeof(a)/sizeof(a[0]) int main() { char ch[] = \u0026#34;hello world\u0026#34;; printf(\u0026#34;items of ch is :%d\\n\u0026#34;, ARRAYSIZE(ch)); return 0; } 计算数组中元素个数\n1 2 3 abs(a-b) -\u0026gt; a-b的绝对值 abs是math文件里的函数 #define MAX(A,B) ((a)+(b)+abs((a)-(b)))/2 不用比较 if 来计算a和b的最大值\n宏的注意事项 字符串中属于字符串的一部分，不会宏展开\n2.宏名的标识符不能用数字开头\n3.双引号必须完整\n4.标识符必须完整\n#和## 定义一个宏来计算一个数的平方 1 #define power(x) ((x)*(x)) 宏的二义性 作业 偏移：相对于结构体所在内存地址的相对字节数 #define (size_t) \u0026amp;(((s *)0)-\u0026gt;m)\n#define calcula_array(arr) sizeof(arr)/sizrof(arr[0]) #define (a+b+abs(a-b)/2) #是字符串化，将宏参数转化为字符串 ##是拼接，用于将两个参数连接起来 （3）：条件编译 条件编译形式1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define WINVER 6.1 int main() { #ifdef WINVER printf(\u0026#34;WINVER is defined\\n\u0026#34;); #else printf(\u0026#34;WINVER is not defined\\n\u0026#34;); #endif return 0; } 条件编译方式3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define DEBUG 1 int main() { int a = 10; int b = 15; int c = a + b; #if DEBUG printf(\u0026#34;c:%d\\n\u0026#34;,c); #endif return 0; } 判断真假 条件编译方式4 条件编译实际工程例子 头文件的预编译 避免同一个头文件被多次编译\n作业 减少头文件的的重复编译\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ai 条件编译的主要用途： 平台适配 c #ifdef _WIN32 // Windows 专用代码 #elif defined(__linux__) // Linux 专用代码 #endif 调试代码开关 c #ifdef DEBUG printf(\u0026#34;调试信息\\n\u0026#34;); #endif 功能模块化 c #if FEATURE_A // 功能A的代码 #endif 头文件保护 c #ifndef HEADER_H #define HEADER_H // 头文件内容 #endif 不同版本构建 c #if VERSION \u0026gt; 2 // 新版本功能 #endif 好处：同一份源码可编译出不同功能的程序，避免运行时判断的开销。 三种形式，分支语句形式，布尔语句形式，是否进行宏定义形式\n第十九课-递归 （1）：递归定义 函数内部，直接或者间接的调用自身\n递归首先需要有至少一个递归出口，即终止条件，不能无限调用自己\n递归式，原问题划分成子问题，子问题解决性质一样，这样子问题解决之后原问题也会被解决\n阶乘 定义fact无符号数\n满足n==0或==1，即一个递归出口\n1 2 3 4 5 6 7 8 int fact(unsigned int n) { if(n==0 || n==1) { return 1; } return n * fact(n-1); } 斐波那契数列 1 2 3 4 5 6 7 8 9 10 unsigned int feibo(unsigned int n) { if(n==1 || n==2) { return 1; } return feibo(n-1)+feibo(n-2); } printf(\u0026#34;feibo(6)=%d\\n\u0026#34;,feibo(6)) 递归的优缺点 作业 两个，一个是递归的出口，二个是递归式，递归式需要满足符合原式的子式，并且能求解问题\n递归优点：简洁明了 缺点：效率较低，容易导致栈溢出\n迭代优点：效率高， 缺点：代码编写难度高\n","date":"2025-11-09T00:00:00Z","image":"http://localhost:1313/p/11-09/bj_hu_126ab62073b40467.jpg","permalink":"http://localhost:1313/p/11-09/","title":"11-09 笔记"},{"content":"（3）：结构体浅拷贝深拷贝 结构体赋值时的拷贝 是否能像图中一样，s1赋值之后，直接用s1来拷贝到其他结构体\n浅拷贝和深拷贝 左，如果结构体中不包含指针变量，那么s2=s1是正确的\n右，结构体中的拷贝默认是浅拷贝，在赋值的同时也把指针所指向的的地址一起拷贝过去，而且s2中还未给指针分配内存，会导致s1和s2共享分配的100个字节的内存\n如果free(s1.p)，那么s2.p就变成了野指针，指向了一个无效的内存地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; typedef struct _struct1 { int a; char c; }struct1,*pstruct1; typedef struct _struct2 { int a; char *p; }struct2, *pstruct2; int main() { struct1 s1 = { 100,\u0026#39;A\u0026#39; }; struct1 s2=s1; printf(\u0026#34;s1:a:%d,c:%c\\n\u0026#34;, s1.a, s1.c); printf(\u0026#34;s2:a:%d,c:%c\\n\u0026#34;, s2.a, s2.c); struct2 s3; s3.a = 100; s3.p = (char*)malloc(16); if(s3.p == NULL) { return -1; } memset(s3.p, 0, 16); strcpy_s(s3.p, 16, \u0026#34;hello world\u0026#34;); struct2 s4=s3; printf(\u0026#34;s3:a:%d,p:%s\\n\u0026#34;, s3.a, s3.p); printf(\u0026#34;s4:a:%d,p:%s\\n\u0026#34;, s4.a, s4.p); free(s3.p); printf(\u0026#34;s4:a:%d,p:%s\\n\u0026#34;, s4.a, s4.p); return 0; } debug\n深拷贝的实现 需要程序员手动去分配内存\n图解 互有瑕疵\ncopy-on-writr 作业 1.浅拷贝，将对应的值和内存地址直接拷贝到对应的变量当中，也就是，两个指针指向同一个内存地址，共享这一个内存地址\n深拷贝，在拷贝指针中分配新的内存，然后将被拷贝指针中的值拷贝到新地址，原指针的改动对拷贝后的指针无影响\n2.浅拷贝对指针来说是两个指针指向同一个内存地址，如果原指针所在结构体运行完成后释放自己在堆上分配的内存，会导致拷贝后的指针变成野指针\n3.c语言中默认是浅拷贝\n4.拷贝时，先给拷贝指针分配一个内存，然后再对齐进行拷贝\n5.写时拷贝，是一种利用\u0026quot;节点\u0026quot;的拷贝方式,多个指针指向一个节点，然后节点再指向一个内存地址，节点用于记录所指向的指针的个数，当还有指针指向的时候，避免释放内存导致其他指针变为野指针\n另外，写实拷贝还能按某一指针需要修改内存地址中的数据并开辟一个新的地址来存放数据\n（4）：结构体应用 结构体数组 结构体数组的初始化与遍历\n结构体指针数组\n结构体做函数参数 传指针\n传值\n判断两个同学成绩\n作业 1.引用传参，c++中。c语言中指针的效率大于传值\n2.链表待定\n（5）：sizeof计算结构体长度 计算类型或者变量的长度，计算的是所占字节的长度\n基本类型 utf16编码，utf32编码\nlong ：win 都站4个字节，linux x64占8个字节\n结构体对齐-自然对齐 成员一样，位置不太一样\n如果是基本成员，存放地点就必须是成员类型的整数倍\nchar，可以存放在任何地址，地址都是1的整数倍\nshort，0 2 4 6 8\n结构体中包含结构体，按照结构体中子成员中最大的基本类型的整数倍\n最终结果成都必须为sizeof基本类型的整数倍，比如第一个a结构体，计算出来的结果如果是20，需要往后填充4个字节来满足必须要是基本类型double=8的整数倍，也就是24个字节\n一般从零地址开始存，这样计算存完即是结构体所占内存大小\n作用，保证cpu在一个时钟周期内把这些数据拿到，提高存取效率\npragma pack(n) ![pragma pack](pragma pack.png)\npragma示例\n定义结构对齐\n![pragma pack1](pragma pack1.png)\n如果按照1字节对齐，那就不用空格，全部加起来即是字节大小\n栈空间对齐 直接按4字节对齐\n在print函数中float会扩充成double字节。\nx64平台填充\nfloat有专门的寄存器，前四个参数存入寄存器，在栈上还会给这四个参数预留空间\n作业 1.sizeof(s1)=8 short 两个字节，long 四个字节 ，long为4，需要为4的倍数，所以最后为8\nsizeof(s2)= 24 char 1个字节， s1 有8个字节，long long 类有8个字节，结果17，因为要为8的倍数，所以为24\nsizeof(s3)= char 1个字节，short两个字节，long 4个字节，longlong 8个字节 16个字节\n2.sizeof(double) = 8 sizeof (long) = 4 sizeof(char) = 1\nsizeof(a) = 24 sizeof(b)=16\n（6）：联合体 联合体（UNION）定义 “同一段内存”，改变其中一个变量，别的变量可能会受影响\n代码定义形式 ![union dingyi](union dingyi.png)\n红色是标准的联合体定义方式，而且在应用中非常常见\n示例\n前面四个字节，i和s重叠，为i赋值的时候，其实就是覆盖\n为s赋值的时候，i的值也会被破坏，他们同时存在，但是值是否存在不知道\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef union _foo { char s[20]; int i; }foo; int main() { foo a; a.i = 100; printf(\u0026#34;a.i:%d,a.s:%s\\n\u0026#34;, a.i, a.s); strcpy(a.s, \u0026#34;hello world!\u0026#34;); printf(\u0026#34;a.i:%d,a.s:%s\\n\u0026#34;, a.i, a.s); printf(\u0026#34;\u0026amp;a.i:%p,\u0026amp;a.s%p\\n\u0026#34;, \u0026amp;a.i, \u0026amp;a.s); printf(\u0026#34;sizeof(a)=%d\\n\u0026#34;, sizeof(a)); return 0; } UNION的性质 结构体和联合体的区别 ![jiegoutihei](jiegoutihe lianheti.png)\n可以互相包含 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef union _demo1 { int a; struct { int b; char c; }s; float f; }demo1,*pdemo1; typedef struct _demo2 { union { int a; char b; }c; int d; }demo2,*pdemo2; int main() { demo1 dm1; demo2 dm2; dm1.a = 100; printf(\u0026#34;dm1.s.b:%d\\n\u0026#34;, dm1.s.b); printf(\u0026#34;dm1.f:%.2f\\n\u0026#34;, dm1.f); dm2.c.a = 0x12; dm2.d = 0x64; printf(\u0026#34;dm2.d:%d,dn2.c.a:%d\\n\u0026#34;,dm2.d,dm2.c.a); dm2.c.b = \u0026#39;A\u0026#39;; printf(\u0026#34;dm2.d:%d,dn2.c.a:%d\\n\u0026#34;, dm2.d, dm2.c.a); return 0; } DEMO 用union判断存储顺序 作业： 1 2 3 4 5 6 7 1. typedef union _b { char a; int b; float c; }b,*pb; 2.创建一个联合体，存入int整型和char字符指针，整型占四个字节，指针占一个字节，因为两个变量在同一段内存中，并且指针只指向了了一个小部分，然后看指针的输出值来判断是是低位还是高位\n3.根据联合体中包含的最大的基本类型计算，为最大基本类型的倍数\n4.联合体共享一段内存，修改其中任意一个变量会对其他变量造成影响，一般一次只使用一个变量\n结构体可以使用多个变量，变量之间一般不会互相影响\n（6）：枚举类型（enum） 定义 是一种基本类型\n逗号分隔，第一个值如果不指定，默认是0\n中途可以指定，中途不能和前面设定好的值重复\n例子\n上述定义，都是枚举类型的变量，变量不能超出这个范围\n不能再对所定义的枚举常量进行赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef enum _WINVERSION { WIN2000, WINXP, VISTA, WIN7, WIN8 }WINVERSION; int main() { WINVERSION winos = 3; switch (winos) { case WINXP: printf(\u0026#34;the os is winxp\\n\u0026#34;); break; case WIN7: printf(\u0026#34;the os is win7\\n\u0026#34;); break; case WIN8: printf(\u0026#34;the os is win8\\n\u0026#34;); break; default: printf(\u0026#34;unkonwn windows os\u0026#34;) break; } return 0; } sizeof 枚举类型 1 2 3 4 5 printf(\u0026#34;sizeof(WINVERSION):%d,sizeof(WIN8):%d\u0026#34;, sizeof(WINVERSION), sizeof(WIN8)); 长度都是一样的，枚举类型的底层应该是int，都是四个字节 软工中的使用 作业 1 2 3 4 5 6 7 8 9 10 1.typedef enum _day { monday, tuesday, wedensday, thursday, friday, saturday, sunday }day,*pday; 2.4个字节\n3.枚举类型是非构建类型，是基础类型的一种\n4.只能取所构建的类型中所定义的值。所构建的值一般是从0开始排列往后依次加1\n第十六课-位运算 （1）：位运算概述 复习二进制位 扩展位数的时候，用符号为去填充多出来的位数\n位运算定义 \u0026amp; | ~ ^ \u0026laquo; \u0026raquo; and or not xor shl shr 与 或 取反 异或 左移 右移 运算符 作业 1.一个bit为二进制中的一个为数位，一个byte由八个数位组成，成为一个字节\n2.~最高，单目运算 \u0026laquo; \u0026raquo; 次之 然后是 \u0026amp; ^ |\n3.不可以，整型是用32位补码形式存放。浮点数的存储方式与整数不一样，包含了一位符号位还有指数位，所以不能使用移位运算\n4.一种是逻辑运算符一种是位运算符，单个是针对于数的二进制表达进行位移动，两个是对于两个表达之间的真假判断\n5.都是 \u0026ldquo;x = x \u0026amp; 某数\u0026rdquo; 的含义\n（2）：与运算 \u0026amp; 程序表示 7，的二进制表示为0111，一个数与7进行与运算，得到的数，就是其末尾3位\n16，0xF\n子网掩码 255.255.255.0 -\u0026gt; 0xFFFFFF00\nip:192.168.1.100\n前三个字节是网络号。最后一个字节是主机号\n子网掩码，进行与运算获取网络号\n清除整数a二进制中最右边的1 各种性质 作业 1.与运算中，与1运算的值都为本身，与0预算的值都为0，获取低三位低八位，只需要使 0000 0111 , 0000 0000 1111 1111 满足除需要的位数其余数字为0即可获得\n2.某一位为1，也是，假设判断第四位为1，0000 1000 如果结果为1则为1\n（3）：或运算 | 或运算程序 作业 或运算算法，有1即结果为1,所以只需要确保计算的某位置的数为1即可\n（4）：异或运算 ^ 异或运算，相同为0，不同为1、\n异或的程序表达 异或运算的性质 xor eax eax 自己与自己异或，结果为0\n两个数的交换\n单指针实现双链表 作业 1 2 3 4 5 6 7 8 9 1.异或运算，相同为0，相反取1 设a ，b 两个数 int a,b; a = a xor b b = \u0026#39;a\u0026#39; xor b = a xor b xor b = a xor 0 = a a = \u0026#39;a\u0026#39; xor \u0026#39;b\u0026#39; = a xor b xor a = b xor 0 = b 所以 a = b b = a 2.链表暂定\n（5）：取反运算 必须是1个字节，2个或者4个\n程序表示 不存在复合运算\n作业 先计算 ~0xFFFEFFFF 即 1111 1111 1111 1110 1111 1111 1111 1111 取反 0000 0000 0000 0001 0000 0000 0000 0000\n然后计算 0x12345678 即 0001 0010 0011 0100 0101 0110 0111 1000 与其取或，即把其中一位变成1即可\n结果：0001 0010 0011 0101 0101 0110 0111 1000 = 0x12355678\n（6）：移位运算 \u0026laquo; \u0026raquo; 左移运算符 ：\u0026laquo; 举例\n右移运算符 分为逻辑右移和算数右移\nc语言中右移运算符为算数右移\njava \u0026raquo;\u0026gt;逻辑 \u0026raquo;算数\n作业 1.左移n位，空出来的用0填充 右移n位，空出来的用符号位填充\n2.等于将这个数乘以/除以 2^N次方\n3.(0x12345678 = 0001 0010 0011 0100 0101 0110 0111 1000 \u0026raquo; 24) = 0000 0000 0000 0000 0000 0000 0001 0010 \u0026amp; (0xFF=1111 1111)\n结果为 0001 0010 =0x12\n（7）：位运算综合运用 将第N位置0或者置1 对称加密 实际项目运用 作业 127 -\u0026gt; 0111 1111 左移1位，然后用0填充，再加1 1111 1110 加1 结果是1111 1111, 255 (?)\n-1 -\u0026gt; 1111 1111 右移1位，然后用符号位填充，1111 1111 再加1 结果是 1 0000 0000 -256 (?)\n算数运算符优先，也就是1\u0026laquo;5 0000 0001 0010 0000 结果是，乘以2的5次方，32\n15 \u0026amp; 240 换成二进制 0000 1111 1111 0000 与运算，与1运算为本身 , 0\n0000 1010 ^ 0000 1100 异或运算，相同取0，相反取1 即 0000 0110 ，6\n与1111 1111 0000 0000 0000 0000 0000 0000 进行与运算\n1向左移动100位，除以7的余数， 0000 0111取余 (?)\n1~1024 00 0000 0001 - 10 0000 0000 异或取值范围 相同0，不同1 最大即2047，最小(?) 1025 还包含0\n(?)\n解析：\n字符型，-128~127 第一题左移转为十进制254，超出范围，截断，1111 1110 表示为 -2,-2+1=-1\n第二题，右移一位，保持-1，再加1，结果为0\n思路，循环加移位，先将浮点数转换为整数，因为浮点数与整数的编码方式不同，如果直接转换成2进制会出现问题，所以\n需要转换成整数并且一位一位打印\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #define mask 0x1 int main() { float f = 1.0f; int k = *(int*)(\u0026amp;f), j; for (j = 31; j \u0026gt;= 0; j--) printf(\u0026#34;%d\u0026#34;, (k \u0026gt;\u0026gt; j) \u0026amp; mask); return 0; } 网络：https://www.zhihu.com/question/457946470 结果如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ai #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; void print_float_bits(float f) { // 1. 将 f 的二进制表示转为 uint32_t uint32_t u = *((uint32_t*)\u0026amp;f); // 2. 分别提取符号位(1 bit)、指数位(8 bits)、尾数位(23 bits) // 并打印每一位 // 符号位: bit 31 // 指数位: bit 30~23 // 尾数位: bit 22~0 printf(\u0026#34;符号位(1): \u0026#34;); printf(\u0026#34;%d\u0026#34;, (u \u0026gt;\u0026gt; 31) \u0026amp; 1); printf(\u0026#34;\\n指数位(8): \u0026#34;); for (int i = 30; i \u0026gt;= 23; i--) { printf(\u0026#34;%d\u0026#34;, (u \u0026gt;\u0026gt; i) \u0026amp; 1); } printf(\u0026#34;\\n尾数位(23): \u0026#34;); for (int i = 22; i \u0026gt;= 0; i--) { printf(\u0026#34;%d\u0026#34;, (u \u0026gt;\u0026gt; i) \u0026amp; 1); } printf(\u0026#34;\\n\u0026#34;); } int main() { print_float_bits(1.0f); return 0; } 结果：\n","date":"2025-11-08T00:00:00Z","image":"http://localhost:1313/p/11-08/bj_hu_76afbcb97f404dc7.jpg","permalink":"http://localhost:1313/p/11-08/","title":"11-08 笔记"},{"content":"（2）：结构体中的指针与数组 三种不同结构体定义示意图 左：\n设定数组64字节的长度，则考生的名字不能超过64个字节，而考生的名字没有达到64字节，就会出现空间的浪费\n中：\n字符指针，单独指派内存\n可以根据所填入字符串大小来分配内存，不会造成内存的浪费，但是存放的地方不连续，如果要做拷贝，需要单独的进行拷贝\n右：\nname数组中有一个元素，但是一个元素的空间，是可以变长的，这样既能满足空间不浪费，还能够连续便于拷贝\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef struct _info1 { int value; char name[64]; }info1,*pinfo1; typedef struct _info2 { int value; char *name; }info2, *pinfo2; typedef struct _info3 { int value; size_t length; char name[1]; }info3, *pinfo3; int main() { info1* pi1 = (info1*)malloc(sizeof(info1)); if (pi1 == NULL) { goto err; } memset(pi1, 0, sizeof(info1)); pi1-\u0026gt;value = 78; strcpy_s(pi1-\u0026gt;name, 64, \u0026#34;lucy\u0026#34;); info2* pi2 = (info2*)malloc(sizeof(info2)); if (pi2 == NULL) { goto err; } pi2-\u0026gt;value = 78; size_t len = strlen(\u0026#34;lucy\u0026#34;) + 1; pi2-\u0026gt;name = (char*)malloc(len); if (pi2 == NULL) { goto err; } memset(pi2-\u0026gt;name, 0, len); strcpy_s(pi2-\u0026gt;name, len, \u0026#34;lucy\u0026#34;); info3* pi3=(info3*)malloc(sizeof(info3) + strlen(\u0026#34;lucy\u0026#34;) + 1 - 1); if (pi3 == NULL) { goto err; } memset(pi3, 0, sizeof(info3) + strlen(\u0026#34;lucy\u0026#34;) + 1 - 1); pi3-\u0026gt;value = 78; pi3-\u0026gt;length = strlen(\u0026#34;lucy\u0026#34;) + 1; strcpy_s(pi3-\u0026gt;name, pi3-\u0026gt;length, \u0026#34;lucy\u0026#34;); printf(\u0026#34;1:score:%d,name:%s\\n\u0026#34;, pi1-\u0026gt;value, pi1-\u0026gt;name); printf(\u0026#34;2:score:%d,name:%s\\n\u0026#34;, pi2-\u0026gt;value, pi2-\u0026gt;name); printf(\u0026#34;3:score:%d,name:%s\\n\u0026#34;, pi3-\u0026gt;value, pi3-\u0026gt;name); err: if (pi1) free(pi1); if (pi2-\u0026gt;name) free(pi2-\u0026gt;name); if (pi2) free(pi2); if (pi3) free(pi3); return 0; } 作业： 1.用malloc函数为指针在堆上分配内存，然后检验指针是否指向NULL，如果不是就使用memset进行初始化\n2.如上述代码。\n语言练习： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 语言练习1： void inputArray(int *arr, int n); // 用于从键盘给数组输入n个整数。 提示：使用指针或下标arr[i]均可。 void printArray(int *arr, int n); // 用于打印数组的所有元素。 int findMax(int *arr, int n); // 用于找出并返回数组中的最大值。 在main函数中： 定义一个长度为5的整型数组。 依次调用 inputArray, printArray, findMax，并打印出最大值。 第一次： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void Inputarray(int* arr, int n) { printf(\u0026#34;输入\u0026#39;n\u0026#39;个数字：\u0026#34;); scanf((char*)\u0026#34;%s\u0026#34;,\u0026amp;arr); return arr[n]; } void Printarray(int* arr, int n) { for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d\u0026#34;, arr[i]); } return 0; } int findMax(int* arr, int n) { int max = arr[0]; for (int i = 0; i \u0026lt; n; i++) { if (max \u0026lt; arr[i]) { max = arr[i]; }\t} return max; } int main() { int arr[5]; Inputarrat(arr, 5); printf(\u0026#34;%d\u0026#34;, Printarray(arr, 5)); int max = findMax(arr, 5); printf(\u0026#34;%d\u0026#34;, max); return 0; } 检测错误： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void Inputarray(int* arr, int n) { for (int i=0; i \u0026lt; n; i++) { printf(\u0026#34;输入%d个数字：\u0026#34;,n); scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]); } } void Printarray(int* arr, int n) { for (int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } } int findMax(int* arr, int n) { int max = arr[0]; for (int i = 1; i \u0026lt; n; i++) { if (max \u0026lt; arr[i]) { max = arr[i]; }\t} return max; } int main() { int arr[5]; Inputarray(arr, 5); Printarray(arr, 5); int max = findMax(arr, 5); printf(\u0026#34;输入数组中最大的数为：%d\u0026#34;, max); return 0; } error1： void函数，直接对参数进行操作不返回值，清楚函数实现的参数是否需要返回值\nscanf的取值参数，应该用循环依次取值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 任务二：指针与字符串（巩固） 目标： 巩固指针操作，理解字符串（字符数组）。 要求： 不使用标准库函数（如strlen, strcpy），自己实现以下两个函数： int my_strlen(const char *str); // 计算字符串的长度（不包含结尾的‘\\0\u0026#39;）。 提示：用一个指针遍历，直到遇到‘\\0’。 void my_strcpy(char *dest, const char *src); // 将源字符串src复制到目标字符串dest。 提示：用循环逐个字符复制，最后别忘了在dest末尾加上‘\\0’。 在main函数中： 定义一个源字符串 char src[] = \u0026#34;Hello, C!\u0026#34;; 定义一个足够大的目标字符串数组 char dest[20]; 调用你的函数进行复制和计算长度，并打印结果。 思考： const char *src 中的 const 有什么用？（它防止你意外修改源字符串，是一个好习惯）。 如果 dest 的空间比 src 小，会发生什么？（这就是C语言需要程序员自己小心的地方，会“缓冲区溢出”，非常危险）。 第一次： #include \u0026lt;stdio.h\u0026gt; int my_strlen(const char* str) { char* p = str[0]; int tmp = 0; if (*p != \u0026#39;\\0\u0026#39;) { tmp++; p++; } else { printf(\u0026#34;字符串的长度：%d\u0026#34;, tmp); } return tmp; } void my_strcpy(char* det, const char* src) { if (my_strlen(det) \u0026lt; my_strlen(src)) { printf(\u0026#34;新数组长度小于原数组，无法拷贝\u0026#34;); } for (int i = 0; i \u0026lt; my_strlen(src); i++) { det[i] = src[i]; } } int main() { char src[] = \u0026#34;hello,C!\u0026#34;; printf(\u0026#34;%d\u0026#34;, my_strlen(src)); char det[20] = { 0 }; my_strcpy(det, src); for (int i = 0; i \u0026lt; my_strlen(src); i++) { printf(\u0026#34;%c\u0026#34;,src[i]); } return 0; } 修正： #include \u0026lt;stdio.h\u0026gt; int my_strlen(const char* str) { const char *p=str; int tmp = 0; while (*p != \u0026#39;\\0\u0026#39;) { tmp++; p++; } return tmp; } void my_strcpy(char* det, const char* src) { int len1 = my_strlen(src); if (30\u0026lt; my_strlen(src)) { printf(\u0026#34;新数组长度小于原数组，无法拷贝\u0026#34;); } for (int i = 0; i \u0026lt; len1; i++) { det[i] = src[i]; } det[len1] = \u0026#39;\\0\u0026#39;; } int main() { char src[] = \u0026#34;hello,C!\u0026#34;; printf(\u0026#34;字符串长度：%d\\n\u0026#34;, my_strlen(src)); char det[30] = { 0 }; my_strcpy(det, src); for (int i = 0; i \u0026lt; my_strlen(src); i++) { printf(\u0026#34;%c\u0026#34;,src[i]); } return 0; } error2: char* p = str[0] 类型错误，应该是 const char* p = str\n逻辑错误：需要用循环遍历整个字符串，不是只检查第一个字符\n用while循环持续检查直到遇到\u0026rsquo;\\0'\nmy_strlen(det)计算的是det当前字符串内容的长度，不是数组总容量\n在函数传参中的数组会退化为指针，在比较数组容量时要么额外传递容量参数，要么使用设定的常量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 任务3： 任务三：综合应用——数组修改器（挑战） 目标： 综合运用所有概念，解决一个稍微复杂的问题。 要求： 编写一个函数，其原型为： int removeElement(int *nums, int numsSize, int val); 功能： 在数组 nums 中，原地移除所有值等于 val 的元素。元素的顺序可以改变。函数返回移除后数组的新长度。 原地移除 意味着你不能申请新数组，必须在原数组上操作。 示例： 输入：nums = [3, 2, 2, 3], val = 3 你的函数操作后，数组可能变为 [2, 2, ...]，并返回新长度 2。 实现思路（“双指针”法，非常重要！）： 定义一个“慢指针” slow = 0，它指向下一个“有效元素”该存放的位置。 用一个“快指针” fast 从0到numsSize-1遍历整个数组。 如果 nums[fast] != val，说明这个元素应该保留。就把它复制到 nums[slow] 的位置，然后 slow 向前移动一位。 遍历结束后，slow 的值就是新数组的长度。 在main函数中测试你的代码。 第一次： #include \u0026lt;stdio.h\u0026gt; int removeElement(int* nums, int numSize, int val) { char* slow = 0; for (int* fast = nums; fast \u0026lt; numSize; fast++) { if (nums[fast] != val) { nums[slow] = nums[fast]; slow++; } } for (int i = 0; i \u0026lt; numSize; i++) { printf(\u0026#34;%d\u0026#34;, nums[i]); } } 修正： #include \u0026lt;stdio.h\u0026gt; int removeElement(int* nums, int numSize, int val) { int* slow = nums; for (int* fast = nums; fast \u0026lt; nums+numSize; fast++) { if (*fast != val) { *slow = *fast; slow++; } } for (int i = 0; i \u0026lt; numSize; i++) { printf(\u0026#34;%d \u0026#34;, nums[i]); } return slow-nums; } int main() { int a[5] = { 2,3,4,3,2 }; printf(\u0026#34;数组长度：%d\u0026#34;, removeElement(a, 5, 3)); } ","date":"2025-11-07T00:00:00Z","image":"http://localhost:1313/p/11-07/bj_hu_fe7103833b33bbf6.jpg","permalink":"http://localhost:1313/p/11-07/","title":"11-07 笔记"},{"content":"c语言练习实例21-39\n看了一些代码实例。\n","date":"2025-11-06T00:00:00Z","image":"http://localhost:1313/bj.jpg","permalink":"http://localhost:1313/p/11-06/","title":"11-06 笔记"},{"content":"第十五课-结构体 （1）：结构体定义与使用 基本类型与构建类型 结构体定义 一般形式\n第三种没有结构体名称，不能在用来定义新的变量名，只能在这起到临时的变量名1，变量名2的作用\n初始化定义，初始化与成员访问 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; typedef struct _student { int id; int age; char name[20]; char sex; float score; } student, *pstudent; int main() { student s1 = { 1001,19,\u0026#34;tom\u0026#34;,\u0026#39;m\u0026#39;,80.5 }; student s2 = { 0 }; s2.id = 1001; s2.age = 19; strcpy_s(s2.name, 20, \u0026#34;tom\u0026#34;);//名字是数组，需要用stucpy拷贝进去 s2.sex = \u0026#39;M\u0026#39;; s2.score = 99.5f; printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, s1.id,s1.age,s1.name,s1.sex,s1.score); printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, s2.id,s2.age,s2.name,s2.sex,s2.score); return 0; } 结构体的指针访问：-\u0026gt; 1 2 3 4 5 student* ps1 = \u0026amp;s1; pstudent ps2 = \u0026amp;s2;//pstudent = student * printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, ps1-\u0026gt;id, ps1-\u0026gt;age, ps1-\u0026gt;name, ps1-\u0026gt;sex, ps1-\u0026gt;score); printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, ps2-\u0026gt;id, ps2-\u0026gt;age, ps2-\u0026gt;name, ps2-\u0026gt;sex, ps2-\u0026gt;score); 注意，长度，加减\n1 2 3 4 5 6 //ps1+1 //sizeof(ps1) 指针大小，根据平台 ,sizeof(*ps1) = sizeof(student) printf(\u0026#34;sizeof(ps1)=%d,sizeof(*ps1)=%d,sizeof(student)=%d\\n\u0026#34;, sizeof(ps1),sizeof(*ps1),sizeof(student)); printf(\u0026#34;ps1:%p,ps1+1:%p\\n\u0026#34;, ps1, ps1 + 1); 在堆上分配内存来表示结构体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 student* ps3 = (student*)malloc(sizeof(student)); if (ps3 == NULL) { return -1; } memset(ps3, 0, sizeof(student)); ps3-\u0026gt;id = 25; ps3-\u0026gt;age = 21; strcpy_s(ps3-\u0026gt;name, 20, \u0026#34;leilei\u0026#34;); ps3-\u0026gt;sex = \u0026#39;m\u0026#39;; ps3-\u0026gt;score = 86.5f; printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, ps3-\u0026gt;id, ps3-\u0026gt;age, ps3-\u0026gt;name, ps3-\u0026gt;sex, ps3-\u0026gt;score); free(ps3); ps3 = NULL; 注意，在free之后，ps3指针依旧指向之前的地址，如果后续还要使用ps3指针，需要重新设为null，否是使用则是垃圾值\n运算符 *pstdt-\u0026gt;sex 第一个，箭头优先级高，箭头指向运算之后，所表示的值不是一个地址，无法解引用\n*pstdt-\u0026gt;name 依旧是箭头优先级高，取出了name，name是数组名，代表数组指针，可以解引用\n*pstdt.sex 点号优先级高，指针没有点号这个运算\n(*pstdt).sex 解引用指针，解出来是结构体的名字\n结构体中的结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; typedef struct _date { int year; int month; int day; }date, *pdate; typedef struct _student { int id; int age; char name[20]; char sex; float score; date birthday; } student, *pstudent; int main() { student s1 = { 1001,19,\u0026#34;tom\u0026#34;,\u0026#39;m\u0026#39;,80.5f,{1995,2,5} }; student s2 = { 0 }; s2.id = 1001; s2.age = 19; strcpy_s(s2.name, 20, \u0026#34;tom\u0026#34;);//名字是数组，需要用stucpy拷贝进去 s2.sex = \u0026#39;M\u0026#39;; s2.score = 99.5f; s2.birthday.year = 1997; s2.birthday.month = 6; s2.birthday.day = 21; printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f,year:%d,month:%d,day:%d\\n\u0026#34;, s1.id,s1.age,s1.name,s1.sex,s1.score, s2.birthday.year, s2.birthday.month, s2.birthday.day); printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, s2.id,s2.age,s2.name,s2.sex,s2.score); student* ps1 = \u0026amp;s1; pstudent ps2 = \u0026amp;s2;//pstudent = student * printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, ps1-\u0026gt;id, ps1-\u0026gt;age, ps1-\u0026gt;name, ps1-\u0026gt;sex, ps1-\u0026gt;score); printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f\\n\u0026#34;, ps2-\u0026gt;id, ps2-\u0026gt;age, ps2-\u0026gt;name, ps2-\u0026gt;sex, ps2-\u0026gt;score); //ps1+1 //sizeof(ps1) 指针大小，根据平台 ,sizeof(*ps1) = sizeof(student) printf(\u0026#34;sizeof(ps1)=%d,sizeof(*ps1)=%d,sizeof(student)=%d\\n\u0026#34;, sizeof(ps1),sizeof(*ps1),sizeof(student)); printf(\u0026#34;ps1:%p,ps1+1:%p\\n\u0026#34;, ps1, ps1 + 1); printf(\u0026#34;sizeof(student *):%d\\n\u0026#34;, sizeof(student*)); student* ps3 = (student*)malloc(sizeof(student)); if (ps3 == NULL) { return -1; } memset(ps3, 0, sizeof(student)); ps3-\u0026gt;id = 25; ps3-\u0026gt;age = 21; strcpy_s(ps3-\u0026gt;name, 20, \u0026#34;leilei\u0026#34;); ps3-\u0026gt;sex = \u0026#39;m\u0026#39;; ps3-\u0026gt;score = 86.5f; ps3-\u0026gt;birthday.year=1996; ps3-\u0026gt;birthday.month = 8; ps3-\u0026gt;birthday.day = 1; printf(\u0026#34;id:%d,age:%d,name:%s,sex:%c,%f,year:%d,month:%d,day:%d\\n\u0026#34;, ps3-\u0026gt;id, ps3-\u0026gt;age, ps3-\u0026gt;name, ps3-\u0026gt;sex, ps3-\u0026gt;score,ps3-\u0026gt;birthday.year, ps3-\u0026gt;birthday.month, ps3-\u0026gt;birthday.day); free(ps3); ps3 = NULL; return 0; } 结构体中的指针 结构体中有指针必须要为这个指针赋值一个有效的内存\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; typedef struct _student { int id; int age; char* name;//char name[20] 有指针的话，需要专门为指针指定内存 char sex; float score; }student, * pstudent; int main() { student s1 = { 11,21,\u0026#34;tom\u0026#34;,\u0026#39;m\u0026#39;,97.5f };//tom存储在静态常量区，name可以指向 student s2 = { 0 }; s2.id = 15; s2.age = 22; s2.name = (char*)malloc(20);//指向了堆上的内存 if (s2.name == NULL) { return -1; } memset(s2.name, 0, 20); strcpy_s(s2.name,20,\u0026#34;lily\u0026#34;); s2.sex = \u0026#39;F\u0026#39;; s2.score = 94.5f; student* s3 = (student*)malloc(sizeof(student)); if (s3 == NULL) { free(s2.name); return -1; } memset(s3, 0, sizeof(student)); s3-\u0026gt;id=18; s3-\u0026gt;age = 23; s3-\u0026gt;name = (char*)malloc(20); if (s3-\u0026gt;name == NULL) { free(s3); return -1; } memset(s3-\u0026gt;name, 0, 20); strcpy_s(s3-\u0026gt;name, 20, \u0026#34;david\u0026#34;); s3-\u0026gt;sex = \u0026#39;M\u0026#39;; s3-\u0026gt;score = 87.5f; printf(\u0026#34;s1:name:%s\\n\u0026#34;, s1.name); printf(\u0026#34;s2:name:%s\\n\u0026#34;, s2.name); printf(\u0026#34;s3:name:%s\\n\u0026#34;, s3-\u0026gt;name); free(s2.name); s2.name = NULL; free(s3-\u0026gt;name); s3-\u0026gt;name = NULL; free(s3); s3 = NULL; return 0; } 赋值要注意进行深拷贝\n左边，链表节点 右边，二叉树\n作业 1.\n1 2 3 4 5 typedef struct _date { int value; struct _date *next }date,*pdate; 2.\n.运算符加载结构体名称后面，用来访问非指针结构体的内部数据\n-\u0026gt;用来放在指针结构体名称后，访问结构体内数据\n3.结构体在函数中被调用的时候就是在栈上运行\n而在堆上运行需要手动在堆上分配内存\n4.链表看不懂。。。。\n","date":"2025-11-05T00:00:00Z","image":"http://localhost:1313/p/11-05/bj_hu_fcb7d9e565857aa3.jpg","permalink":"http://localhost:1313/p/11-05/","title":"11-05 笔记"},{"content":"（6）：二级指针 二级指针 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main(void) { int a = 10; int* p = \u0026amp;a; int** pp = \u0026amp;p; printf(\u0026#34;a:%d\\n\u0026#34;, a);//10 printf(\u0026#34;\u0026amp;a:%p\\n\u0026#34;, \u0026amp;a);//addr of a printf(\u0026#34;p:%p\\n\u0026#34;, p);//addr of a printf(\u0026#34;\u0026amp;p:%p\\n\u0026#34;, \u0026amp;p);//addr of p printf(\u0026#34;pp:%p\\n\u0026#34;,pp);//addr of p printf(\u0026#34;*p:%d\\n\u0026#34;,*p);//10 printf(\u0026#34;*pp:%p\\n\u0026#34;, *pp);//p,addr of a printf(\u0026#34;**pp:%d\\n\u0026#34;, **pp);//10 return 0; } 二级指针关系图 应用 分析\nstr是一个指针 ，第一个，我们将str作为一个值传递沟渠，函数拿不到这个值，必须串指针的地址，就是用二级指针来保存参数的地址，即\n传参的形式 分析运行结果\n1.\n解答\n作业： 1 2 3 4 5 6 7 8 9 10 1.函数f中，两个变量分别是二级指针**ptr1,指针*ptr2。 定义指针p1=i的地址，p2等于j的地址 然后调用f函数 \u0026amp;p1，也就是取指针p1的地址，作为二级指针**Ptr1；p2，就是j变量的地址作为指针变量导入f函数中 然后int 指针tmp=ptr2 也就是 tmp=ptr2=p2=\u0026amp;j 下一个**ptr1，两次解引用ptr1指针，结果为i，i*10=0，i=0 解ptr2指针，结果为j，j*10=200，j=200 ptr2 = *ptr1，解引用ptr1，即二级指针中存放的是p1的地址，解出来p1存放的i的地址，也就是ptr2 = \u0026amp;i *ptr1 = tmp 就是p1 = p2 = \u0026amp;j 所以，i=0，j=200，p1=p2=\u0026amp;j 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 2.问题：调用的getmemory函数中，malloc没有对应的free来清除堆上使用的内存，会造成内存泄漏 void中调用getmemory函数，传值传入的不是地址，定义getmemory的时候设定的指针，也就是需要传入地址， 所以程序会在调用函数的时候崩溃，还可能会造成内存泄露 修改： void getmemory(char *p) { p=(char*)malloc(100); free(p) } void test(char *s) { char *str = NULL; getmemory(\u0026amp;str); strcpy(str,s); printf(str); } 第十四课-内存管理 物理内存，cpu根据物理地址在物理内存中存储数据\n（1）：内存分类与寻址 R0，内核空间，最高权限。R3，进程空间\n加载程序，就是把数据加载到程序的进程空间中部署运行\n程序内存布局 data 初始化的全局变量，静态变量\nrdata 常量\n堆和栈的区别 堆上的内存需要释放，否则会造成内存些泄露\n栈：自动分配内存，内存大小相对较小且固定，后进先出\n堆：手动分配内存，可以动态调整大小，大小受限于计算机\n指针函数不能返回栈上的地址，函数执行完了之后源地址已经销毁了\n内存碎片：存在着内存，但是无法分配到空闲的内存\n进程的地址空间是私有的，可能拥有相同的，类似的逻辑地址\n寻址模式 分段：用起始地址加偏移地址来表示位置 段的起始地址，低4位设置成零用来让16位寄存器表示段地址\n两个寄存器，一个寄存器中拿到起始地址，然后左移四位，加上段的偏移\n左移四位，低四位是0，未存放，也就是存放时右移四位\ncs 代码段起始地址， ds 数据段起始地址\n扁平模型 不需要设置起始地址，能够直接用一个寄存器寻址整个地址空间\n实模式，段寄存器中的地址加偏移能得到物理地址\n保护模式，地址使用虚拟地址，通过页表段表来映射得到物理地址\n保护模式中无需参与计算\n段选择符加段表和偏移量得到线性地址\nCR3寄存器，获得页目录，确定页表项，通过偏移找到物理地址\n作业 1.底层是静态区，存放了变量，数据，常量；往上是代码区，存放源代码；再往上是堆，一个手动管理的内存池；然后最后是栈，调用函数时存放变量的区域\n2.程序内存分为四个区域，内核区，两个非法区，进程区。内核区和进程区占4GB，内核区的权限最高，进程区R3的权限，非法区域用来隔绝两个区域的相互影响，只占64kb\n3.栈是函数调用时的临时存储区，由系统自动分配，后进先出，效率较高\n堆是由程序员手动分配的内存池，大小由计算机硬件决定，调用灵活，但是效率稍低\n4.分段模型是在计算机寄存器只有16位用来寻址的方法，计算机地址总线有20位，寄存器无法完全存储，于是采用分段模型的方式来存储，将20位总内存大小1m的内存分为16个64kb的段，然后规定最后四位都为0的方式，省略四位零，然后用两个寄存器，一个用来表示起始地址，另一个用来表示偏移量，这样用来将逻辑地址转换为物理地址\n平坦模型，则是计算机发展之后，一个寄存器能够完成将逻辑地址转换为物理地址之后发展出来的方式，能用一个寄存器去遍历所有的地址线\n5.实模式，没有保护，用分段模型构建的物理地址，可以读写任何内存位置\n保护模式，需要页表将虚拟地址转换为物理地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 直接物理内存访问：程序看到的地址就是真实的物理内存地址。一个程序可以读写任何内存位置，包括操作系统的核心代码。 无权限分级：没有“内核态”和“用户态”之分。所有代码都以最高权限运行。 内存空间小：由于16位架构和寻址方式限制，最多只能访问 1MB 内存。 虚拟内存：程序运行在独立的“虚拟地址空间”中，由CPU和操作系统负责映射到真实的物理内存。程序A无法直接访问程序B的内存。 权限分级：通常有4个特权级（Ring 0 ~ Ring 3）。操作系统内核运行在最高特权级（Ring 0），应用程序运行在最低特权级（Ring 3）。应用程序想执行特权指令（如操作硬件）会被CPU拒绝。 内存分段与分页：通过复杂的描述符表和页表来管理内存访问，提供了隔离和保护机制。 支持大内存：可以访问远超过1MB的物理和虚拟内存（如4GB甚至更多）。 （2）：内存分配 静态区，代码区，栈，堆，如何编译一个10m的程序\n全局数组，全局变量， 必然存放在静态区\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int g_iNum = 10; char g_Aarrat[] = \u0026#34;hello worlf\u0026#34;; int main(void) { int a = 123; int b = 127; char buf[128] = { 0 };//栈 char* p = (char*)malloc(256);//堆上，需要内存分配函数，nalloc是一个函数名，返回的变量名是一个void类型*指针 free(p == NULL); if (p == NULL) { return -1; } memset(p, 0, 256);//内存初始化为0 strcpy_s(p, 256, \u0026#34;hello world\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, p); free(p);//释放，把值重新放入到内存去，但是指针指向未必其余的 p = NULL; return 0; } 如果一个数组里面全是0，编译器不会打开数组将值存放在内存，可以压缩成一个存放\n比如 g_data区有10*1024*1024的数组，全是0即被压缩，如果有存放字符，就会开辟一个区域存放\nmalloc/calloc/realloc 作业 1.静态区存放全局变量，静态变量，从静态区分配内存只能从最开始的声明变量，内存由声明类型决定，不由程序员决定\n2.栈的内存是在函数调用时由机器分配使用，根据所写函数的声明类型定义来决定，不受程序员控制\n3.从堆上分配内存需要使用特定的函数，比如malloc，calloc，用来在堆上划取一部分内存来使用\n4.栈是函数调用时的临时存储区，由系统自动分配，后进先出，效率较高\n堆是由程序员手动分配的内存池，大小由计算机硬件决定，调用灵活，但是效率稍低\n（3）：内存泄漏预防与检测 内存泄漏 忘记了将调用的堆的内存释放，即内存泄漏\n系统内存耗尽后，系统会将磁盘的一部分用来存储内存的数据，导致系统性能大幅下降\n图中传参的代码，传的是值，而函数中定义的是指针，调用时并没有真正传入，但是堆上的内存会分配，导致程序崩溃，释放内存也没有用\nAPI不正确调用造成内存泄漏 预防内存泄漏 -1 预防内存泄漏-2 集中处理内存泄漏\n预防内存泄漏-3 预防内存泄漏-4 内存泄漏之后的检测 realloc会检查原来内存的容量，不够会开辟新的内存地址\n作业 1.写代码的时候，声明函数之后跟上释放，让划取和释放成对出现\n或者用goto集中处理所有的堆\n用内存使用计数，使用时+1，释放时-1，最后看是否还有+1\n2.用容器封存指向所划取堆的首地址的指针，在调用完成后检查是否有未释放的指针留存\n","date":"2025-11-04T00:00:00Z","image":"http://localhost:1313/p/11-04/bj_hu_135b6231849dc18.jpg","permalink":"http://localhost:1313/p/11-04/","title":"11-04 笔记"},{"content":"作业 1.指针含义：指针是一个存放内存地址的变量.指针长度：长度由所属变量类型决定，char 即1字节，int 即4字节，如果五类型，由所在平台决定，x86即4个字节，x64即8个字节\n2.p是指针时，*p的情况需要做讨论，如果是没有与int之类的声明语句相结合，则为解引用符号，读取指针中存放的地址，如果与声明语句结合，则可能是二级指针\n3.通过char类型的指针指向int 类型的整数1，然后打印指针值，int类型占四个字节，而char指针只有一个字节，会丢失另外三字节的数据，看打印结果是1或者0就能判断是高位还是低位优先。\n4.x86平台是低位优先储存，所以两个指针读取出的数都是ff，p1用的是有符号的字符型，p2是无符号的字符型，而输出的之后又采取转换成10进制输出，\nff转换成2进制应0111 1111 ，10进制是255，但是有符号数中，数的范围是-128~127，所以p1的输出应该是-1，因为补码的127+1整数溢出，p2的输出应该是255\n导入vs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int main() { int num = 0x000000ff; char* p1 = (char*)\u0026amp;num; unsigned char* p2 = (unsigned char*)\u0026amp;num; printf(\u0026#34;%lu\\n\u0026#34;, *p1); printf(\u0026#34;%lu\\n\u0026#34;, *p2); return 0; } 第一个结果是随机数，第二个结果是255\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 ai解答 1. 整数提升规则 在C语言中，小于int的类型在表达式计算中会被提升为int： char → int unsigned char → int 2. 具体过程分析 对于 *p1 (有符号char，值0xff = -1)： c *p1 = 0xff // 内存中的字节 // 整数提升（保持值不变）： char -1 → int -1 二进制：11111111 (char) → 11111111 11111111 11111111 11111111 (int) // 提升后的int值：0xFFFFFFFF (-1) 对于 *p2 (无符号char，值0xff = 255)： c *p2 = 0xff // 内存中的字节 // 整数提升（保持值不变）： unsigned char 255 → int 255 二进制：11111111 (uchar) → 00000000 00000000 00000000 11111111 (int) // 提升后的int值：0x000000FF (255) printf的可变参数机制 printf 通过 va_list 从栈上读取参数，它不知道实际传入的类型，只按照格式符解释： c printf(\u0026#34;%lu\\n\u0026#34;, *p1); 栈上实际内容： text | 0xFFFFFFFF | (从*p1提升来的int -1) | 格式字符串地址 | printf的理解： %lu 期望 4/8字节的 unsigned long 但从栈上读取到的是 0xFFFFFFFF (int -1) 类型不匹配 → 未定义行为 美化了博客，修复了一堆史山代码\n","date":"2025-11-03T00:00:00Z","image":"http://localhost:1313/p/11-03/bj_hu_8e6fd399c3ba5f20.jpg","permalink":"http://localhost:1313/p/11-03/","title":"11-03 笔记"},{"content":"（3）：函数调用约定 调用约定： cdecl 调用者还原栈\nstdcall 被调用函数自身修改栈\nfastcall 被调用者修改栈\nshort y 在入栈的时候，会将两个字节提升为四个字节（x86每一个都会对齐到4个字节）\n上面是内存的低地址，下面是内存的高地址。内存增长和栈增长方向相反\n首先是参数入栈，然后是返回地址入栈，这个过程中esp一直在往上走\neip 返回地址：调用完函数之后，下一条要执行的命令\n在程序运行期间，程序访问参数是用过[ebp+8]来访问的，访问局部变量通过[ebp-4]。加是高地址，减是低地址。\n返回地址过了就是老ebp入栈，形成老ebp和ebp指针，然后esp往上走一部分，形成局部变量空间\n函数走完了，退出时，发生esp往下走的过程\n首先是esp往下走，走到ebp，然后老ebp出栈，放到ebp寄存器中，然后ebp往下走\n紧接着返回地址出栈，重新放到eip寄存器中，这是esp指到参数1上面\n清理参数空间，也就是所谓的栈平衡，对cdecl来说是调用者完成这个过程\n将esp向下移动（只有栈顶指针指向的内存区域才是有效的，向下走，之前的区域都会无效掉\n其他调用约定是被调用者清理，在函数结束的时候会有return 12；就是rsp向下移动12位来清理参数空间。而fastcal更快，因为1.2个参数存放在寄存器中，只需要返回四个字节即可\n分析：\n。\n死循环问题：当i=16的时候,a[16]读取到的内存地址是i的内存地址，也就是说会把i赋值为0，重新开始循环，循环一直不会结束\n缓冲区溢出-栈溢出 超出200个字节后，多余的数据占用高位空间，假设有208个字节，会占用到老ebp和返回地址，而函数执行完之后的返回地址被占用了，就会去执行被修改之后的恶意代码\n思考：\nx64调用约定 x64 fastcall 变为调用者来维持栈平衡，统一采用fastcall\n栈的整体大小要能被16整除\n作业： 1.\n如图所示，根据x86的调用约定，printf默认使用edecl约定，参数从右往左压入栈中，形成xxyy这种样式\n而后printf开始调用，在存储的时候，int和float都是4字节，压入栈中参数也是4字节，但是在读取是，%f是读取8字节的double，就导致了第一个调用edp+8调用在x上，第二个应该是edp+c却变成edp+10，变到y取值之上，第四个直接取到栈外的垃圾值\n2.\n如图所示，在第一次函数addr调用时，去了k所在的内存地址赋值给*p指针，而后弹出栈，然后第二次调用loop函数，i可能存储的地址与k一模一样，所以在循环中的 (*p)\u0026ndash; 实际上针对的是k所在的地址，也就是现在的i的-1，导致i的值始终满足情况，造成死循环。\n而short，因为 (*p)-- 只修改 2 字节，破坏了i或j的值，使其变成一个很大的正数或特定的值，导致循环条件立即不成立。\n（4）：inline和static关键字 使用inline的效果\n未使用时在printf里使用get函数，会将参数导入函数而计算取返回值再输出，\n使用inline之后直接就将函数里的语句拷贝，对原函数的替换，到此处计算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; inline int mygetmax(int x, int y) { return x \u0026gt; y ? x : y; } int main() { int a = 5; int b = 13; int res = mygetmax(a, b); printf(\u0026#34;max:%d\\n\u0026#34;, res); return 0; } stastic 全局变量，当然源文件有效\n局部变量，记忆作用，生命周期是程序运行时\n只能在当前源文件中有效\n函数设计常见问题与注意事项 问题1：接口设计问题 利用printf打印结果代替返回值 1.凡是在算法中通过printf打印出来，不合格。需要将结果提供给调用者，需要去使用这个结果\n2.十进制转换成36进制，输出无法调用\n问题2：逻辑全部或者部分放在了main函数 main主要用来测试函数功能，不要把逻辑写在main中\n问题3：调用了库函数 自己写算法必须是用纯c来实现\n代码缺少封装 两端重复代码，可以封装成一段单独的函数，然后在此直接调用即可\n问题4：函数内部内存分配 算法中，严禁调用内存分配函数\n让调用者自己去分配内存\n问题5：硬编码 考虑代码的可移植性\n在x64和x86中int为4没问题，但是以后计算机的发展可能会出现问题，而用sizeof来代替可以提高代码的可移植性\n代码中使用可读性的代码更适合\n模块化设计思想 变量都必须初始化 变量命名原则 自解释性代码\n指针移动 char*str和char str[] 写算法 strstr为例子 1.明确的知道算法的输入和输出:输出的应该是字串名 即 char\n2.严进宽出，检测算法中每一个值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; char *_strstr(const char* str, const char* substr) { if (str == NULL || substr == NULL) { return NULL; } if (*substr == \u0026#39;\\0\u0026#39;) { return (char *)str; } char* p1 = (char *)str; while (*p1!=\u0026#39;\\0\u0026#39;) { char* p2 = p1; char* p3 = (char*)substr; while (*p2 \u0026amp;\u0026amp; *p3 \u0026amp;\u0026amp; (*p2 == *p3)) { p2++; p3++; } if (*p3 == \u0026#39;\\0\u0026#39;) { return p1; } p1++; } return NULL; } int main() { printf(\u0026#34;strstr:%s\\n\u0026#34;, _strstr(\u0026#34;hello world\u0026#34;, \u0026#34;orl\u0026#34;)); printf(\u0026#34;strstr:%s\\n\u0026#34;, _strstr(\u0026#34;hello world\u0026#34;, \u0026#34;xyz\u0026#34;)); printf(\u0026#34;strstr:%s\\n\u0026#34;, _strstr(\u0026#34;hello world\u0026#34;, NULL)); return 0; } 第十三课-指针 （1）：指针定义与使用 变量在内存中的地址 \u0026amp;取值运算符\n指针定义 指针也是变量，指针也有类型，指针存放的值是内存地址\n指针字节就是内存地址的长度\n1 2 3 4 5 6 7 8 9 int main() { int i = 1; int* p = \u0026amp;i; printf(\u0026#34;p=%p,\u0026amp;i=%p,sizeof(p):%d\\n\u0026#34;, p, \u0026amp;i, sizeof(p)); return 0; } 指针的定义与初始化形式 初始化：1.指向某个变量的地址 2.指向一个分配的内存或者字符串常量 3.指向NULL\n1 2 int i,*p；定义了一个整型i和整型指针，这里*与int一起 p =\u0026amp;i 野指针，指向随机值 1 2 3 4 5 6 7 8 char *p=(Char*)malloc(100); 在堆上分配了地址，赋值给了一个指针 char *str = \u0026#34;hello world\u0026#34;; 指向的是字符串变量地址 char c=\u0026#39;A\u0026#39;; 一个字符变量\u0026#39;a\u0026#39; char *str = \u0026amp;c; 一个指针str，把c的地址赋值给了str，指向字符变量c char *pch= \u0026amp;c ; 字符指针既可以指向字符串，也可以指向字符变量 赋值给指针的时候，赋值的类型一定要匹配 字符指针赋值给整型指针，需要强制转化 *p：解引用运算符 与指针定义的*不是一个东西 1 2 3 4 5 6 7 int *p1,*p2 中 “*” 是定义指针p1，p2 printf 中*p1 *p2 是解引用符 *p1 == a *p2 == b 对 *p1+1 *p2+2 就是对a，b修改 但是必须要是可写的 a是常量指针，指针的一种形式，指向的数组的首地址 p指向的字符串的首地址 对a和p进行解引用，*a为数组第一个元素，*p为字符串第一个 野指针和NULL都不能被解引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() {\tint a = 100; int b = 10; int arr[10] = { 2,3,4,6,7,8 }; char* s = \u0026#34;hello world\u0026#34;; int* p1 = \u0026amp;a; int* p2 = \u0026amp;b; printf(\u0026#34;*p1=%d,*p2=%d\\n\u0026#34;, *p1, *p2); printf(\u0026#34;a=%d,b=%d\\n\u0026#34;, a, b); *p1 += 1; *p2 += 1; printf(\u0026#34;a=%d,b=%d\\n\u0026#34;, a, b); printf(\u0026#34;*arr:%d\\n\u0026#34;, *arr); printf(\u0026#34;*s:%c\\n\u0026#34;, *s); return 0; } \u0026amp;与* *arr = 100;\r*s = \u0026quot;X\u0026quot;;\r*arr 指向数组第一个元素，可以使用指针修改\n*s指向静态常量区，修改会报错\n\u0026amp;与*互为逆运算：*\u0026amp;与\u0026amp;* *运算符需要和指针联系在一起，a不是指针，所以\u0026amp;*a会报错\n易混淆 指针的赋值与使用 *p2 = *p1 即j = i j和i的值都变为\u0026rsquo;a'\n用双引号直接赋值的字符串是只读的，用数组或malloc创建的字符串是可修改的。\np2=p1 把p1的地址赋值给p2，相当于p2指向了p1的地址\n指针类型与互相转换 少了会导致数据丢失，多了可能会导致破坏其他内存地址。强制转化有可能会导致程序受到影响\n类型不一样宽度就不一样\nvoid *p void *p 没有任何类型，和类型指针不一样\nvoid的指针概念中没有内存长度的概念，拿不到内存长度\n不能用*p来取值，取不了其中的值\nGCC里面的扩展，void默认为1字节\n主要用在函数参数定义的时候，可以接受任何类型的指针的赋值，万能指针型\nvoid赋值成别的类型需要强转，而解引用也需要转换\n一般用在函数的形参位置，不用做任何的强制转换，只是在内部需要转换\n1 2 3 4 void *pv1 = p1 只是对pv1的赋值，类型并未转换，GCC应该可以 sizeof(pv1) 指针本身是变量 sizeof(*pv1) 只是无法解引用 字符指针 sizeof(p)\\sizeog(*p) sizeof(p) 指针对应的长度\nsizeof(*p) 指针对应类型的长度\n4 4 1 4 12 4 1 1\n指针的应用 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdbool.h\u0026gt; bool is_system_little() { int x = 0x1; char* p = (char*)\u0026amp;x; if (*p == 1) return true; else return false; } 作业 ","date":"2025-11-02T00:00:00Z","image":"http://localhost:1313/p/11-02/bj_hu_b9094a861f3953da.jpg","permalink":"http://localhost:1313/p/11-02/","title":"11-02 笔记"},{"content":"字符串作业代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 1. #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char path[50]=\u0026#34;c:\\\\docs\\\\mallocfree.txt\u0026#34;; char* p = strrchr(path,\u0026#39;m\u0026#39;); if (p != NULL) { printf(\u0026#34;found it :%s\\n\u0026#34;, p); } else { printf(\u0026#34;found it not :%s\\n\u0026#34;, p); } return 0; } 2.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char path[100]=\u0026#34;http://www.mallocfree.com/? x=y\u0026amp;mm_gxb=1_87adefc12d\u0026amp;id=9988\u0026#34;; char* p = strstr(path, \u0026#34;1_8\u0026#34;); if (p != NULL) { printf(\u0026#34;found it :%s\\n\u0026#34;, p); } else { printf(\u0026#34;found it not :%s\\n\u0026#34;, p); } return 0; } 3.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char path[100]=\u0026#34;http://www.mallocfree.com/?x=y\u0026amp;mm_gxb=1_98adefc12e\u0026#34;; char* p = strstr(path, \u0026#34;1_9\u0026#34;); if (p != NULL) { printf(\u0026#34;found it :%s\\n\u0026#34;, p); } else { printf(\u0026#34;found it not :%s\\n\u0026#34;, p); } return 0; } 4.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char ip[] = \u0026#34;192.168.100.1\u0026#34;; const char* delim = \u0026#34;.\u0026#34;; char* next = NULL; char* p2 = strtok_s(ip, delim, \u0026amp;next); while (p2 != NULL) { int f = atof(p2); printf(\u0026#34;%d \u0026#34;, f); p2 = strtok_s(NULL, delim, \u0026amp;next); } return 0; } ai生成： #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char ip[] = \u0026#34;192.168.100.1\u0026#34;; const char* delim = \u0026#34;.\u0026#34;; char* next = NULL; unsigned int result = 0; // 32位整数结果 int shift = 24; // 从最高位开始 char* token = strtok_s(ip, delim, \u0026amp;next); while (token != NULL \u0026amp;\u0026amp; shift \u0026gt;= 0) { int num = atoi(token); result |= (num \u0026lt;\u0026lt; shift); // 按位合并 shift -= 8; // 每次移动8位 token = strtok_s(NULL, delim, \u0026amp;next); } printf(\u0026#34;IP地址: %s\\n\u0026#34;, \u0026#34;192.168.100.1\u0026#34;); printf(\u0026#34;32位整数: %u\\n\u0026#34;, result); printf(\u0026#34;十六进制: 0x%08X\\n\u0026#34;, result); return 0; } (4):自己实现字符串api 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; size_t mystrlen(const char* str)//const 表示函数内部不会修改str的值 { size_t count = 0; if (str == NULL) return 0;//如果是指针，判断是否为0 while (*str != \u0026#39;\\0\u0026#39;) { count++; str++; } return count; } size_t mystrlen2(const char* str) { const char* eos = str; while (*eos++); return (size_t)(eos - str - 1);//eos末尾，str开头，相减是元素个数包含0字符，-1是非零字符的个数 } //递归 str==NULL || *str==\u0026#39;\\0\u0026#39; return 0; //1+mystrlen2(str+1) 递归出口 size_t mystrlen3(const char* str) { if (str == NULL || *str == \u0026#39;\\0\u0026#39;) return 0; return 1 + mystrlen3(str + 1);//递归式,子串加一 } size_t mystrlen4(const char* str) { return str == NULL || *str == \u0026#39;\\0\u0026#39; ? 0 : 1 + mystrlen4(str + 1); } //字符串拷贝函数 char* mystrcpy(char* dst, const char* src) { if (dst == NULL || src==NULL) { return NULL; } char* s = dst; while (*s++ = *src++);//依然会引起缓存区报错 //*s = \u0026#39;\\0\u0026#39;; return dst; } int mystrcmp(const char* s1, const char* s2) { // if (s1 == NULL || s2 == NULL) // { // return 0; // } assert(s1 != NULL \u0026amp;\u0026amp; s2 != NULL);//要求括号里面必须为真，如果其中应该为none，那么括号就是假 while (*s1 \u0026amp;\u0026amp; *s2 \u0026amp;\u0026amp; (*s1 == *s2)) { s1++; s2++; } return *s1 - *s2; } int main() { char str[] = \u0026#34;hello world\u0026#34;; char buf[128] = { 0 }; printf(\u0026#34;strlen:%lld\\n\u0026#34;, strlen(str)); printf(\u0026#34;mystrlen:%lld\\n\u0026#34;, mystrlen(str)); printf(\u0026#34;mystrlen2:%lld\\n\u0026#34;, mystrlen2(str)); printf(\u0026#34;mystrlen3:%lld\\n\u0026#34;, mystrlen3(str)); printf(\u0026#34;mystrlen4:%lld\\n\u0026#34;, mystrlen4(str)); mystrcpy(buf, str); printf(\u0026#34;buf: % s\\n\u0026#34;, mystrcpy(buf, str)); char* s1 = \u0026#34;hello world\u0026#34;; char* s2 = \u0026#34;hello world\u0026#34;; if (mystrcmp(s1, s2) == 0) { printf(\u0026#34;%s==%s\\n\u0026#34;, s1, s2); } else { printf(\u0026#34;%s != %s\\n\u0026#34;,s1,s2); } return 0; } 循环效率大于递归，递归，函数在自己调用自己的过程中涉及到入栈和出栈\n递归嵌套太深可能会导致栈溢出，但是递归代码更加简洁，需要保证防止栈溢出\n应用层的栈较大可以使用递归，内核层严禁使用递归\n防止程序崩溃，在定义函数之前应对设定值进行严格的校验\n作业 1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 char* rav_strtok(char* strToken, const char* strDelimit) { //定义局部变量 static char* text = NULL; unsigned char table[32]; const unsigned char* delimit; unsigned char* str; char *head; //更新静态字符串 if (strToken) text = strToken; //对不合法输入进行特殊判断 if (text == NULL) return NULL; if (strDelimit == NULL) return text; //改变 char 为 unsigned char 以便进行位运算 str = (unsigned char*)text; delimit = (const unsigned char*)strDelimit; //初始化位表 for (int i = 0; i \u0026lt; 32; i++) table[i] = 0; for (; *delimit; delimit++) { table[*delimit \u0026gt;\u0026gt; 3] |= 1 \u0026lt;\u0026lt; (*delimit \u0026amp; 7); } // 跳过分隔符直到起始位置 while (*str \u0026amp;\u0026amp; (table[*str \u0026gt;\u0026gt; 3] \u0026amp; (1 \u0026lt;\u0026lt; (*str \u0026amp; 7)))) str++; head = (char*)str; // 找到第一个分隔符 for (; *str; str++) { if (table[*str \u0026gt;\u0026gt; 3] \u0026amp; (1 \u0026lt;\u0026lt; (*str \u0026amp; 7))) { *str++ = \u0026#39;\\0\u0026#39;; break; } } // 更新结果 text = (char*)str; if (*text == \u0026#39;\\0\u0026#39;) text = NULL; return head; } 2.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 atoi: #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;ctype.h\u0026gt; int myAtoi(const char * str) { //判断是否是NULL指针或空白字符串 if (str == NULL) return 0; if (str == \u0026#39;\\0\u0026#39;) return 0; //过滤空白字符 while (isspace(*str)) { str++; } //使用标志flag来判断数字正负 int flag = 1; if (*str == \u0026#39;+\u0026#39;) { flag = 1; str++; } else if (*str == \u0026#39;-\u0026#39;) { flag = -1; str++; } //由于字符串里的数字可能大于int类型的最大值，所以使用long long类型变量记录数据 long long ret = 0; while (*str != \u0026#39;\\0\u0026#39;) { //如果是10进制数据 if (isdigit(*str)) { ret = ret * 10 + (*str - \u0026#39;0\u0026#39;) * flag; str++; if (ret \u0026gt; INT_MAX) ret = INT_MAX; if (ret \u0026lt; INT_MIN) ret = INT_MIN; } //如果不是10进制数据 else { //由于atoi函数返回值为int类型，而刚才定义的变量是long long类型，所以要进行转换 return (int)ret; } } return (int)ret; } 2.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 char* my_itoa(int value, char* str, int base) { if (base \u0026lt; 2 || base \u0026gt; 32) { printf(\u0026#34;Wrong radix!\\n\u0026#34;); return str; } char* ret = str; if (value == 0) { *str++ = \u0026#39;0\u0026#39;; *str = \u0026#39;\\0\u0026#39;; return ret; } if (base == 10 \u0026amp;\u0026amp; value \u0026lt; 0) { value = -value; *str++ = \u0026#39;-\u0026#39;; } char* start = str; // 从右到左依次将数字的每一位存储起来 size_t num = value; while (num != 0) { if (num % base \u0026lt; 10) { *str++ = \u0026#39;0\u0026#39; + (char)(num % base); } else { *str++ = \u0026#39;a\u0026#39; + (char)(num % base - 10); } num /= base; } *str = \u0026#39;\\0\u0026#39;; // 倒置字符串 for (char* left = start, *right = str - 1; left \u0026lt; right; left++, right--) { char tmp = *left; *left = *right; *right = tmp; } return ret; } 3.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;assert.h\u0026gt; char* my_strstr(const char* str1, const char* str2) { const char* cur = str1; //用cur用来记录当前的位置 const char* s1 = NULL; //通过s1 和 s2 比较元素 const char* s2 = NULL; assert(str1 \u0026amp;\u0026amp; str2); //assert断言，如果传入的地址有有一个会空指针，则直接返回str1的地址 if (str2 == \u0026#39;\\0\u0026#39;) return (char*)str1; while (*cur) //当cur中的值不为\u0026#39;\\0\u0026#39;时，进入循环 { s1 = cur; //s1回到比较时的位置 s2 = str2; //s2回到初始位置 while (*s1 \u0026amp;\u0026amp; *s2 \u0026amp;\u0026amp; *s1 == *s2) //当s1和s2指向的值相等时，进入循环 { s1++; //找到下一个元素 s2++; //找到下一个元素 //再次比较 } if (*s2 == \u0026#39;\\0\u0026#39;) //当s2中的元素为\u0026#39;\\0\u0026#39;时，则说明在str1中找到了str2 return (char*)cur; //返回当前的位置 cur++; //第一次没找到，找到下一个元素重新寻找 } return NULL; //如果在循环中没有找到，则返回一个空指针 } int main() { char arr1[] = \u0026#34;abcadefdef\u0026#34;; char arr2[] = \u0026#34;def\u0026#34;; char* ret = my_strstr(arr1, arr2); if (ret != NULL) { printf(\u0026#34;%s\\n\u0026#34;, ret); } else { printf(\u0026#34;找不到\\n\u0026#34;); } return 0; } 第十二课-函数 （1）：函数定义与应用 定义 定义形式与调用，调试 输入参数：外部传递给函数\n输出参数：函数计算的结果，可以通过输出方式传递给调用值；也能用return方式返回给调用值\n有的函数即做了输出参数也做了输入参数\n变参函数：函数的参数个数可以变化，比如printf函数在打印的时候，可以打印多个\n函数应用，头文件写法（导出函数和变量） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; int myadd(int x, int y)//声明的时候可以不用形参，只加两个类型也可以 { int res; res = x + y; return x + y; } int getmax(int x, int y) { return x \u0026gt; y ? x : y; } bool leep_year(int year) { (year % 4 == 0) \u0026amp;\u0026amp; (year % 100 || year % 400 == 0); } char mytolower(char ch) { if (ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) { ch += \u0026#39;a\u0026#39; - \u0026#39;A\u0026#39;; } return ch; } void swap(int x, int y)//整数进行交换就不需要返回值 { int tmp = x; x = y; y = tmp; } 暂时如此，后续实验出现问题有更改 1.使用bool类型需要包含头文件 这是在myfunc.c里面打的函数，跟main函数不在同一个源文件里 写头文件 1 2 3 4 5 6 7 8 #pragma once #include \u0026lt;stdbool.h\u0026gt; int myadd(int x, int y); //保证头文件项目在编译的时候只被包含一次 int getmax(int x, int y); //然后将刚刚写的函数全部放在里面声明 bool leep_year(int year); //再到源文件里写包含 char mytolower(char ch); //自己写的源文件用\u0026#34;\u0026#34;。引号是从当前目录开始查找 void swap(int x, int y); //而\u0026lt;\u0026gt;是从系统目录开始查找 预编译\n1 2 3 4 5 6 7 8 9 10 #ifndef _MYFUNC_H_ #define _MYFUNC_H_ int myadd(int x, int y); int getmax(int x, int y); bool leep_year(int year); char mytolower(char ch); void swap(int x, int y); #endif swap运行之后函数的值没有发生交换\n形参和实参的区别\n在函数内部完成了形参的交换，但实际上设定的函数实参没有发生改变\n采用的传参方法叫传值，传值是不能改变实参的，传值是将实参的值拷贝到了形参的位置，改变形参并不会改变实参，上述定义的函数都是采用传值的方法运行的\nmain函数参数的使用 例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; int _tmain(int argc, _TCHAR* argv[]) { if (argc != 2) { printf(\u0026#34;Invalid parameters\\n\u0026#34;); return 0; } for (int i = 0; i \u0026lt; argc; i++) { _tprintf(_T(\u0026#34;%s\\n\u0026#34;), argv[i]); } return 0; } exe中--\u0026gt;属性--\u0026gt;调试--\u0026gt;命令参数 argv中，argv[0]永远是我们程序自身，此程序中拿两个参数，即自身和在调试中输入的命令行参数，两个\n函数定义注意事项 功能单一 方便维护，可模块化\n输入输出，设计函数的接口\n局部变量要进行初始化\n严进宽出：严格判断是否合法，长度是否合理，类型是否匹配\nassert 断严\n复杂度 时间短 尽量不分配内存\n边界考虑：特殊情况，考虑所有的情况，大于小于，多了少了，内存是否重叠\n功能测试：调用，测试，不同的测试用语\nreturn不可以返回指向栈内存，栈内存在结束时会被释放\n逆置字符串 定义了函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; void reverse_str(char* str) { int len = 0; char* s = str; while (*s != \u0026#39;\\0\u0026#39;) { s++; len++; } for (int i=0; i \u0026lt; len / 2; i++) { char ch = str[i]; str[i] = str[len - 1 - i]; str[len - 1 - i] = ch; } return str; } int main() { char* str = \u0026#34;hello world\u0026#34;; printf(\u0026#34;str before:%s\\n\u0026#34;, str); reverse_str(str); printf(\u0026#34;str after:%s\\n\u0026#34;, str); return 0; } 改为char str[] = \u0026#34;hello world\u0026#34;; 就不会崩溃，这样是在栈上分配的地址，栈上的地址是可读可写的 在进行逆置字符串的操作，这一段内存必须是可读可写的，上述代码会崩溃\n用指针指向的 “hello world” 是存储在静态常量区是不能读写的\n该函数设计上问题：\n1.没有模块化\n也就是需要把计算字符串长度这一段代码单独弄出来形成一个函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; int mystrlen(const char* str) { int len = 0; char* s =(char *) str; while (*s != \u0026#39;\\0\u0026#39;) { s++; len++; } return len; } void reverse_str(char* str) { int len = mystrlen(str); for (int i=0; i \u0026lt; len / 2; i++) { char ch = str[i]; str[i] = str[len - 1 - i]; str[len - 1 - i] = ch; } return str; } int main() { char str[] = \u0026#34;hello world\u0026#34;; printf(\u0026#34;str before:%s\\n\u0026#34;, str); reverse_str(str); printf(\u0026#34;str after:%s\\n\u0026#34;, str); return 0; } 库函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;Windows.h\u0026gt; int main() { char *filename=\u0026#34;d:\\\\docs\\\\1.doc\u0026#34;; //1.txt 可行，改成1.doc不行，所以打错误代码 int res =remove(filename); if(res==0) { printf(\u0026#34;delted!\\n\u0026#34;); } else { printf(\u0026#34;failed\\n\u0026#34;); } errno_t err=GetLastError(); printf(\u0026#34;err:%d\\n\u0026#34;,err) //通过错误码32，tool中搜索得知是因为文件正在运行 return 0; } 面向对象和面向过程 面向过程：抽象出解决问题的步骤，然后用函数表达步骤，解决的时候一一调用\n面向对象：抽象出问题里面的对象，然后分析对象的行为，解决问题是对象发生了什么样的行为，调用对象的行为\n作业 1.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char str[] = \u0026#34;hello world\u0026#34;; int len = sizeof(str) / 2 - 1; char* p1 = str[0]; char* p2 = str[len]; for (int i = 0; i \u0026lt;len; ) { for (int j = len+1 ; j \u0026lt; strlen(str); ) { char tep = str[i]; str[i] = str[j]; str[j] = tep; ++i; ++j; } } for (int i = 0; i \u0026lt; sizeof(str); i++) { printf(\u0026#34;%c\u0026#34;, str[i]); } return 0; } 2.\n（2）：函数传参 传引用是c++里面的\nc语言里面有两种，函数里面传参有三种\n传值 拷贝实参的值，无法改变实参\nfunc1 形参x是a的值的拷贝，x与a独立\n传指针 拷贝实参的地址，可以改变实参\nfunc2 形参*x是a的地址的拷贝，x就是a 引用中取用了a的地址\n传引用 void func3(int \u0026amp;x)\n传过来引用的地址，可以改变实参，x就是a\n如果一个函数有多个参数，每一个参数可以有不同的传值方法\n指针可能会指向错误的内存的地址，难以驾驭，可能破坏程序\n在传引用的情况下，形参就是实参的别名，代表的就是实参\n传值还是传指针 并非函数设定的指针，在传参的时候就是在传指针，而是看传的实参，是否是传的指针\nfunc2(\u0026amp;c2) //传c2的地址，是传指针，传指针的指针，二级指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void func1(char *c); void func2(char **c); int main(void) { char c1; char *c2; func1(\u0026amp;c1); func1(c2); //func1(\u0026amp;c2)错误,func1本身是一级指针，\u0026amp;c2取地址就二级指针了，就是语法错误 func(\u0026amp;c2); return 0; } swap-交换 ![swap jiaohuan](swap jiaohuan.png)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; void swap1(int x,int y) { int tep = x; x = y; y = tep; } void swap2(int *x, int *y) { int tep = *x; *x = *y; *y = tep; } void swap3(int \u0026amp;x, int \u0026amp;y) { int tep = x; x = y; y = tep; } int main() { int x = 10; int y = 20; swap1(x,y); printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x,y); swap2(\u0026amp;x,\u0026amp;y); printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x, y); x = 10; y = 20; swap3(x,y); printf(\u0026#34;x:%d,y:%d\\n\u0026#34;, x, y); return 0; } 函数用参数作为返回值 做输出参数的时候，必须使用传指针或者传引用，因为传值无法改变实参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int add1(int x, int y) { return x + y; } void add2(int x, int y, int* sum) { if (sum == NULL) return; *sum = x + y; } void add3(int x, int y, int\u0026amp; sum) { sum = x + y; } void add4(int* x, int y) { *x = *x + y; } void add5(int \u0026amp;x, int y) { x = x + y; } int main() { int a = 10; int b = 20; int sum = 0; sum = add1(a, b); printf(\u0026#34;sum:%d\\n\u0026#34;, sum); add2(a, b,\u0026amp;sum); printf(\u0026#34;sum:%d\\n\u0026#34;, sum); add3(a, b,sum); printf(\u0026#34;sum:%d\\n\u0026#34;, sum); add4(\u0026amp;a, b); printf(\u0026#34;sum:%d\\n\u0026#34;, sum); a= 10; add5(a,b); printf(\u0026#34;sum:%d\\n\u0026#34;, sum); return 0; } 数组做函数参数 ，防溢出 右边程序，函数设定中\u0026lt;10，但是main函数引用函数时设定了9个元素也就是0-8的数组，会导致内存溢出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 第一种，多设置一个参数 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void print_array(int a[],size_t len) { for (int i = 0; i \u0026lt; len; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int a[9] = { 3,7,2,3,4,5,1,5,6}; print_array(a,9); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 第二种 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void print_array(int (\u0026amp;a)[10]) { for (int i = 0; i \u0026lt;10; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { int a[9] = { 3,7,2,3,4,5,1,5,6}; print_array(a); return 0; } 取值10个元素的一维数组，在编译阶段就无法将九个元素的数组传参过去。 只接收十个数组的函数 分析问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void GetMemory(char **p) { *p = (char*)malloc(100); } void Test(char* s) { char* str = NULL; GetMemory(\u0026amp;str); strcpy_s(str,100,s); printf(str); } malloc 需要头文件 作业 1.\n1 2 3 4 5 6 7 8 fun(c) 输出 9 fun函数设定c[]，忽略了函数长度的影响，但是此题没有涉及函数长度的语句，结果不变 fun2(c) 输出 9 fun2函数设定\u0026amp;c，也就是传递指针，c数组指针传递过去，计算元素个数为9 fun3(c) 输出 报错 fun3中，（\u0026amp;c）[9]限制了输入数组的长度必须为9，但是原数组是1-8八个元素，所以报错 解析： 8 1 9 第一个，数组参数退化为指针，char c[]在函数参数中等价于char *c 即sizeof(char*)，与数组内容无关，只与指针类型有关 第二个， 第三个，(\u0026amp;c)[9]限定的九个元素里是包含了\u0026#39;\\0\u0026#39;这个元素的，所以实际上对于a[8]来说元素个数是符合条件的 2.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 1.传递空指针，会导致程序崩溃 2.手动分配内存，可能会出现导入字节数大于100的情况 ai解答： getmemory函数定义指针值，test传递值应该二级指针 或者get函数定义数组，返回指针 1. void GetMemory(char** p) // 传指针的地址 { *p = (char*)malloc(100); } void Test(char* s) { char* str = NULL; GetMemory(\u0026amp;str); // 传str的地址 if(str != NULL) { strcpy(str, s); printf(\u0026#34;%s\u0026#34;, str); free(str); } } 2. char* GetMemory() { return (char*)malloc(100); } void Test(char* s) { char* str = GetMemory(); if(str != NULL) { strcpy(str, s); printf(\u0026#34;%s\u0026#34;, str); free(str); } } ","date":"2025-11-01T00:00:00Z","image":"http://localhost:1313/p/11-01/bj_hu_f7edab3c703d9c0c.jpg","permalink":"http://localhost:1313/p/11-01/","title":"11-01 笔记"},{"content":"作业：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 思路： for循环从右往左遍历函数然后存入新的字符串中再拷贝 #include \u0026lt;stdio.h\u0026gt; void reverse_str(char *str) { while (*str != \u0026#39;\\0\u0026#39;) { str++; int x = str; } for (int i = str; i \u0026gt;= 0; i--) { char str2[] = \u0026#34;0\u0026#34;; for (int j = 0; j \u0026lt; str; j++) { str2[j] = str[i]; } return 0; } } int main() { char str[] = \u0026#34;hello world\u0026#34;; reverse_str(*str); printf(\u0026#34;%s\u0026#34;,reverse_str(*str)); return 0; } 问题： 1.主函数中，调用函数之后，怎么将函数返回值导入变量中 2.void是什么语法，” 不允许使用不完整的类型 \u0026#34;void\u0026#34; “ 什么叫做不完整，输入void也报错 网络： #include \u0026lt;stdio.h\u0026gt; void Reverse(char* str) { char* left = str;//left指向字符串数组的首元素 char* right = str + strlen(str) - 1;//right指向字符串的最后一个元素 while (left \u0026lt; right)//进行首元素和尾元素的交换，直至left等于right为止，此时字符串完成1逆置 { char temp = *left; *left = *right; *right = temp; ++left; --right; } } int main() { char str[10000]=\u0026#34;hello world\u0026#34;; Reverse(str); printf(\u0026#34;%s\u0026#34;, str); return 0; } 使用指针首位互换，在指针互相相遇后停止 ","date":"2025-10-31T00:00:00Z","image":"http://localhost:1313/p/10-31/bj_hu_db8d56b60bf97e75.jpg","permalink":"http://localhost:1313/p/10-31/","title":"10-31 笔记"},{"content":"作业\n1.\n1 2 3 4 5 6 7 8 9 sizeof(p1)=4 x86 sizeof(p2)=9 sizeof(p3)=1024 sizeof(p4)=8 strlen(p1)=8 strlen(p2)=8 strlen(p3)=1024 strlen(p4)=8 2.\n1 2 3 4 5 char name1[3][20]= 定义一个二维数组，有三行，每一行能存20个字节，引号中的字符存入数组中，按顺序排列，然后数组存放在内存中 char *name2{3}= 定义一个一维数组指针，存放了三个元素，三个元素存在静态常量区，将字符内存的首地址赋值给了指针 char *S1 = \u0026#34;hello world\u0026#34; 定义一个指针指向存放在静态常量区的一个字符串 char s2[] = \u0026#34;hello world\u0026#34; 定义了一个数组，存放了字符串 （3）：字符串API 常见操作和库函数 定义了标准的用来操作字符串的库函数，叫做api\n第一套：str 操作多字节字符串\n第二套：wcs 计算宽字节字符串\n第三套：_tcs #include \u0026lt;tchar.h\u0026gt; 既可以是多字节也可以是宽字节\n建议统一使用第三种方式来定义字符串 比较灵活，可以自动切换\n字符串库函数应用 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;tchar.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #pragma warning(disable:4996) int main() { char *s1 = \u0026#34;hello world 1\u0026#34;; wchar_t *s2 = L\u0026#34;hello world 2\u0026#34;; TCHAR *s3 = _T(\u0026#34;hello world 3\u0026#34;); char buf1[128] = { 0 }; wchar_t buf2[128] = { 0 }; TCHAR buf3[128] = { 0 }; printf(\u0026#34;s1:%s\\n\u0026#34;, s1); printf(\u0026#34;s2:%ws\\n\u0026#34;, s2); _tprintf(_T(\u0026#34;s3:%s\\n\u0026#34;), s3); //tcs 处理方法 //_tcscpy(buf3,s3); // int min_len3 = 128 \u0026gt; len3 ? len3 : 127; //_tcscpy_s(buf3, 128, s3); //_tprintf(_T(\u0026#34;buf3:%s\\n\u0026#34;), buf3); // printf(\u0026#34;%d,%d,%d\\n\u0026#34;, len1, len2, len3); // 两个字符串进行比较 char* st1 = \u0026#34;hello world\u0026#34;; char* st2 = \u0026#34;hello china\u0026#34;; //if (strcmp(st1, st2) == 0) //{ //\tprintf(\u0026#34;%s==%s\\n\u0026#34;, st1, st2); //} //else //{ //\tprintf(\u0026#34;%s!=%s\\n\u0026#34;, st1, st2); //} //if (strnicmp(st1, st2,5) == 0) //{ //\tprintf(\u0026#34;%s==%s\\n\u0026#34;, st1, st2); //} //else //{ //\tprintf(\u0026#34;%s!=%s\\n\u0026#34;, st1, st2); //} //返回位置地址 //strchr从左往右找strrchr从右往左找 //比如在上述的path路径中找冒号 //path:c:\\doc\\test\\mallocfree.txt //strchr(path, \u0026#39;:\u0026#39;);//该函数返回的是path中冒号的指针值，所以应该是: char *p=strchr(path, \u0026#39;:\u0026#39;); if (p != NULL) { printf(\u0026#34;found it:%s\\n\u0026#34;, p); } else { printf(\u0026#34;not found it\\n\u0026#34;); } //对于单独找出文件名部分，从右往左找，找斜线位置，再斜线加一 printf(\u0026#34;filename:%s\\n\u0026#34;, strrchr(path, \u0026#39;\\\\\u0026#39;) + 1); printf(\u0026#34;filename:%s\\n\u0026#34;, strrchr(path, \u0026#39;.\u0026#39;) );//求拓展名 return 0; } strcmp 两个字符串进行整体的比较，有一个字符不对就不相等，相等返回0，如果第一个大于第二个返回正数，小则负数\nstrncmp表示前n个字符，只要前n个字符相同返回0\nstricmp 比较大小时候忽略大小写\nstrnicmp 比较前面n个字符是否一样并且忽略大小写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //计算字符串的长度 size_t len1 = strlen(s1); size_t len2 = wcslen(s3); size_t len3 = _tcslen(s3); //拷贝字符串 //不安全的,只是可以使用\tstrcpy(buf1, s1); // strcpy_s(buf1, 128, s1); 会将拷贝字符串与限定字节大小作比较，如果大于则不会拷贝 // printf(\u0026#34;buf1:%d\\n\u0026#34;, buf1); // linux平台拷贝 // 需要定义长度，计算实际拷贝大小，防止内存溢出 // int min_len = sizeof(buf1) \u0026gt; len1 ? len1 : sizeof(buf1) - 1 //\tstrncpy(buf1, s1,min_len); // printf(\u0026#34;buf1:%s\\n\u0026#34;,buf1); //宽字符的处理 //wcscpy(buf2, s2); //wcscpy_s(buf2,123, s2); //int min_len2 = sizeof(buf2) / sizeof(wchar_t) \u0026gt; len2 ? len2 : sizeof(wchar_t) - 1; //wcsncpy(buf2, s2,min_len2); //printf(\u0026#34;buf2:%ws\\n\u0026#34;, buf2); 1 2 3 4 5 6 7 8 //字符串拼接 char path[260] = \u0026#34;c:\\\\doc\\\\test\\\\\u0026#34;; char* filename = \u0026#34;mallocfree.txt\u0026#34;; //对path来说，filename过长会超出范围，导致缓存区溢出，strcat不检查 strcat(path, filename); printf(\u0026#34;path:%s\\n\u0026#34;, path); 1 2 3 4 5 6 7 8 9 10 11 //strstr 从一个字符串中找到子串 char* p1 = strstr(s1, \u0026#34;orl\u0026#34;); if (p1 != NULL) { printf(\u0026#34;p1:%s\\n\u0026#34;, p1); } else { printf(\u0026#34;not found it\\n\u0026#34;); } //strtok 拆分字符串\rchar ip[] = \u0026quot;192.168.100.1\u0026quot;;\rconst char *delim = \u0026quot;.\u0026quot;;//分隔符可以多设定几个，比如\u0026quot;._ \u0026quot;\rchar* next = NULL;\rchar* p2 = strtok_s(ip, delim,\u0026amp;next);//char *p2 = strtok(ip, delim);\rwhile (p2 != NULL)\r{\rprintf(\u0026quot;%s\\n\u0026quot;, p2);\rp2 = strtok_s(NULL, delim,\u0026amp;next);//拆分之后会记住地址，不用传参到null位置\r}\r1 2 3 4 5 6 7 8 9 10 11 //strstr 从一个字符串中找到子串 char* p1 = strstr(s1, \u0026#34;orl\u0026#34;); if (p1 != NULL) { printf(\u0026#34;p1:%s\\n\u0026#34;, p1); } else { printf(\u0026#34;not found it\\n\u0026#34;); } 1 2 3 4 5 6 7 8 9 10 11 12 13 //字符串，整数，浮点数转换方法 char *value = \u0026#34;3.1415\u0026#34;; float f = atof(value); printf(\u0026#34;f:%f\\n\u0026#34;, f); char* v1 = \u0026#34;123\u0026#34;; int i = atoi(v1); printf(\u0026#34;i:%d\\n\u0026#34;, i); TCHAR *v2 = _T(\u0026#34;678\u0026#34;); int v = _ttol(v2); printf(\u0026#34;v:%d\\n\u0026#34;, v); 作业： ","date":"2025-10-30T00:00:00Z","image":"http://localhost:1313/p/10-30/bj_hu_72198dfee38f1539.jpg","permalink":"http://localhost:1313/p/10-30/","title":"10-30 笔记"},{"content":"考核1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #include \u0026lt;stdio.h\u0026gt; int main() { char array_1; printf(\u0026#34;请输入字符串：\u0026#34;); gets_s(\u0026#34;%s\u0026#34;, array_1); int len=strlen(array_1); printf(\u0026#34;%d\u0026#34;, len); return 0; } //上述自打，搜索得问题 1.未引入头文件，使用gets语法需要引用string.h头文件 2.gets语法使用错误，正确使用方式gets_s(数组名, 数组大小); 3.使用了未定义字符串array，会警告，应在定义时初始化。 这是用strlen函数方法 或许不是通过键盘输入字符串的方式来取得字符串长度 因为输入之前需要定义字符串长度，而用sizeof直接是输出定义长度，strlen输出除\\0长度 //* #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int lens(char str[]) { char *p = str; int counts = 0; while(*p++ != \u0026#39;\\0\u0026#39;) { counts++ ; } return counts+1; } int main() { char str[] = \u0026#34;10d2n821 ma\u0026amp;@\u0026amp;@ 93cdw1!\u0026#34;; int res = lens(str); printf(\u0026#34;%d\u0026#34;, res); return 0; } *//代码来源 https://blog.csdn.net/st66688/article/details/108356361 //自打 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int lens(char str[]) { int j = 0; for (int i=0; str[i] != \u0026#34;\\0\u0026#34;; i++) { j++; } return j+1; } int main() { char str[] = \u0026#34;10d2n821 ma\u0026amp;@\u0026amp;@ 93cdw1!\u0026#34;; int res = lens(str); printf(\u0026#34;%d\u0026#34;, res); return 0; } !!! 注意\u0026#34;\\0\u0026#34; \u0026#39;\\0\u0026#39; 应该是for遍历到\u0026#39;\\0\u0026#39; 而不是字符串\u0026#34;\\0\u0026#34; !!! 考核2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { int a[4][4] = { {0x16,0x99,0xae,0xc3}, {0xf8,0xab,0x8f,0x19}, {0x4d,0xe7,0x65,0x3d}, {0x30,0x91,0xb1,0xb9} }; int b[4][4] = {0}; int x = 0; for (int i= 0;i\u0026lt;4;i++) { for (int j = 0; j \u0026lt; 4; j++) { if (i == 0) { b[i][j] = a[i][j]; } else if (i == 1\u0026amp;\u0026amp;j+1\u0026lt;4) { b[i][j] = a[i][j+1]; } else if (i == 1 \u0026amp;\u0026amp; j == 3) { b[1][3] = a[i][j - 3]; } else if (i == 2\u0026amp;\u0026amp;j+2\u0026lt;4 ) { b[2][j] = a[i][j + 2]; } else if (i == 2) { b[i][2] = a[i][0]; b[i][3] = a[i][1]; } else if (i == 3) { b[i][0] = a[i][3]; b[i][1] = a[i][0]; b[i][2] = a[i][1]; b[i][3] = a[i][2]; } printf(\u0026#34;%02x \u0026#34;, b[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } //ai #include \u0026lt;stdio.h\u0026gt; // 用for循环行移位 void shiftbytes(int arr[4][4]) { int temp; for(int i = 0; i \u0026lt; 4; i++) { // 第0行不移位，第1行左移1位，第2行左移2位，第3行左移3位 int shift = i; for(int s = 0; s \u0026lt; shift; s++) { // 左移一位 temp = arr[i][0]; for(int j = 0; j \u0026lt; 3; j++) { arr[i][j] = arr[i][j+1]; } arr[i][3] = temp; } } } int main() { int a[4][4] = { {0x16,0x99,0xae,0xc3}, {0xf8,0xab,0x8f,0x19}, {0x4d,0xe7,0x65,0x3d}, {0x30,0x91,0xb1,0xb9} }; printf(\u0026#34;原始数组:\\n\u0026#34;); for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 4; j++) { printf(\u0026#34;%02x \u0026#34;, a[i][j]); } printf(\u0026#34;\\n\u0026#34;); } shiftbytes(a); printf(\u0026#34;\\n变换后数组:\\n\u0026#34;); for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 4; j++) { printf(\u0026#34;%02x \u0026#34;, a[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 补作业4代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 2. #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = { 1,7,6,3,4,2 }; int max_num = a[0]; int second_num = 0; for (int i=0; i \u0026lt; sizeof(a)/sizeof(a[0]); i++) { if (max_num \u0026lt; a[i]) { max_num == a[i]; if (second_num \u0026lt; max_num \u0026amp;\u0026amp; second_num \u0026lt; a[i]) { second_num == a[i]; } } printf(\u0026#34;该数组最大值是%d，第二大的值是%d\\n\u0026#34;, max_num, second_num); } return 0; } 问题： 1.赋值符号，= == 不对 2.第二大值的赋值逻辑不对 应该是有两条逻辑 1）second 比max小，max比a[i]小的时候，second更新到max，max更新到更大值 2）second 比max小，但是a[i]值大于second小于max ai修正后 #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = { 1,7,6,3,4,2 }; int max_num = a[0]; int second_num = a[0]; for(int i = 1; i \u0026lt; sizeof(a)/sizeof(a[0]); i++) { if(a[i] \u0026gt; max_num) { second_num = max_num; // 旧最大值变成第二大 max_num = a[i]; // 更新最大值 } else if(a[i] \u0026gt; second_num \u0026amp;\u0026amp; a[i] != max_num) { second_num = a[i]; // 更新第二大值 } } printf(\u0026#34;该数组最大值是%d，第二大的值是%d\\n\u0026#34;, max_num, second_num); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 作业1： 思路， int 一个数组 从右边开始，也就是从 a[sizeof(a)/sizeof(a[0]) -1] int一个整数 int x = sizeof(a)/sizeof(a[0]) 每一次比较a[x-1]与a[x]的大小 if a[x-1]\u0026gt;a[x] 将a[x]填入新数组的从0开始的顺序 else a[x-1] 填入 用i--来表达 限制x的大小，需要使得x-1\u0026gt;0 最后再将所形成的新数组拷贝到原来的a数组 代码： #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = {3,7,2,1,8,9,5}; int b[] = {0,0,0,0,0,0,0}; int x = sizeof(a) / sizeof(a[0]); for (int i=x; i - 2 \u0026gt;= 0; i--) { if (a[i-2] \u0026lt; a[i-1]) { for (int y = 0; y \u0026lt; sizeof(a) / sizeof(a[0]); y++) { b[y] = a[i - 1]; } } else(a[i - 2] \u0026gt; a[i-1]); { for (int y = 0; y \u0026lt; sizeof(a) / sizeof(a[0]); y++) { b[y] = a[i]; } } } for (int i = 0; i \u0026lt; sizeof(a) / sizeof(a[0]); i++) { a[i] = b[i]; } printf(\u0026#34;数组a:%p,数组b:%p\u0026#34;, a, b); return 0; } ai修复： #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = {3,7,2,1,8,9,5}; int b[] = {0,0,0,0,0,0,0}; int x = sizeof(a) / sizeof(a[0]); for (int i = x-1; i - 2 \u0026gt;= 0; i--) // 从最后一个有效索引开始 { if (a[i-2] \u0026lt; a[i-1]) { for (int y = 0; y \u0026lt; sizeof(a) / sizeof(a[0]); y++) { b[y] = a[i - 1]; } } else // 去掉括号和条件 { for (int y = 0; y \u0026lt; sizeof(a) / sizeof(a[0]); y++) { b[y] = a[i - 2]; } } } for (int i = 0; i \u0026lt; sizeof(a) / sizeof(a[0]); i++) { a[i] = b[i]; } printf(\u0026#34;数组a:%p,数组b:%p\u0026#34;, a, b); return 0; } //错误： 1.else后面不跟条件以及； 2.第一次索引a[7]访问未定义内存导致程序崩溃 3.逻辑漏洞 for (int y = 0; y \u0026lt; sizeof(a) / sizeof(a[0]); y++) { b[y] = a[i - 2]; } 此内层循环中，没有设置条件，导致每次都是循环遍历b数组每一个值 #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = { 3,7,2,1,8,9,5 }; int b[] = { 0,0,0,0,0,0,0 }; int x = sizeof(a) / sizeof(a[0]); for (int i = x - 1; i - 2 \u0026gt;= 0; i--) { if (a[i - 2] \u0026lt; a[i - 1]) { for (int i = x - 1; i - 2 \u0026gt;= 0; i--) { if (a[i - 2] \u0026lt; a[i - 1]) { b[i] = a[i - 1]; } else { b[i] = a[i - 2]; } } for (int i = 0; i \u0026lt; sizeof(a) / sizeof(a[0]); i++) { a[i] = b[i]; } printf(\u0026#34;数组a: \u0026#34;); for (int i = 0; i \u0026lt; sizeof(a) / sizeof(a[0]); i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } printf(\u0026#34;\\n数组b: \u0026#34;); for (int i = 0; i \u0026lt; sizeof(b) / sizeof(b[0]); i++) { printf(\u0026#34;%d \u0026#34;, b[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } } } 主要问题 1. 循环嵌套混乱 c for (int i = x - 1; i - 2 \u0026gt;= 0; i--) { if (...) { for (int i = x - 1; i - 2 \u0026gt;= 0; i--) { // 重复的循环 内外层循环都用同一个变量名 i，造成混乱。 2. 逻辑不完整 只处理了 a[i-2] \u0026lt; a[i-1] 的情况 else 分支没有对应的内层循环 3. 提前返回 return 0 在第一次满足条件时就结束程序。 正确的冒泡思路： #include \u0026lt;stdio.h\u0026gt; int main() { int a[] = {3,7,2,1,8,9,5}; int n = sizeof(a) / sizeof(a[0]); // 冒泡排序 for(int i = 0; i \u0026lt; n-1; i++) { for(int j = 0; j \u0026lt; n-1-i; j++) { if(a[j] \u0026gt; a[j+1]) { // 交换相邻元素 int temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; } } } // 输出结果 printf(\u0026#34;排序后: \u0026#34;); for(int i = 0; i \u0026lt; n; i++) { printf(\u0026#34;%d \u0026#34;, a[i]); } return 0; } (2):程序中的字符串 1.赋值给了字符指针，其字符存放在静态常量区，赋值是将字符内存的首地址赋给了该指针\n通过指针++，可以不断的扫描该字符，直到遇到\\0字符为止\n2.赋值给了字符数组 str2 ，与上面不同，是将静态区的字符拷贝到str2数组里面，而且字符数组的内存是可以修改的，元素个数，即包含0字符在内的所有字符\n3.该字符数组包含了100个元素，赋值的字符串没有100个元素，多余的部分默认为0\n4.该字符数组占12个字符，相当于整体的字符串赋值进入，sizeof(str4)=12,但是如果用strlen来计算字符串的值的话，会在第一个\\0截断\n程序中使用字符串 堆上 可以存在全局数组里面，可以用指针指向，可以拷贝到栈上，可以从堆里分配字节来存放\n堆上用了之后需要free，否则会造成内存的泄露\ns2指向了hello world的地址，不能通过s2来更改数组里元素的值 编译发现不了，但是程序会崩溃\n静态常量区是不可以修改的\n字符串的遍历 字符串做参数 字符串与字符数组 1.纯粹的字符数组\n2.可以当作一个字符串\n3.作为字符数组有5个元素，作为字符串有前面三个元素\n4.即是数组也是字符串\n字符串数组 作业\n","date":"2025-10-29T00:00:00Z","image":"http://localhost:1313/p/10-29/bj_hu_9285a17996426751.jpg","permalink":"http://localhost:1313/p/10-29/","title":"10-29 笔记"},{"content":"字符数组 strlen(str1)是非法的，str1不是一个字符串\nstrlen会从左到右遍历所有元素直到找到最后的0为止，然后减去0，用来计算str1会导致内存溢出\n字符串的规定就是最后一位是0\na必须是实参，如果是形参的话会导致计算出错，形参的a会退化成指针，一个指针的长度是四个字节或者说是八个字节\n作业：\n1.随机访问：指能通过 a[下标值] 直接访问到数组中这个下标所在的值 原因：数组的存储方式是按照顺序一个一个字节数相同，连续排列的组合，通过长度乘以下标值能够直接找到对应的内存地址，所以数组能够支持随机访问\n2.在C语言中，数组的长度是固定的，因此无法直接删除数组中的某一项。通常通过覆盖法或辅助数组法来实现删除操作。\n覆盖法 确定需要删除元素的下标位置，然后从此位置开始将后续元素全部往前移动一位，而后更新数组长度或者将最后一位换为0\n代码示例：(百度复制)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; void removeElement(int arr[], int *size, int index) { if (index \u0026lt; 0 || index \u0026gt;= *size) { printf(\u0026#34;索引超出范围\\n\u0026#34;); return; } for (int i = index; i \u0026lt; *size - 1; i++) { arr[i] = arr[i + 1]; } (*size)--; // 更新数组长度 } int main() { int arr[] = {1, 2, 3, 4, 5}; int size = 5; int index = 2; // 要删除的元素索引 removeElement(arr, \u0026amp;size, index); for (int i = 0; i \u0026lt; size; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } return 0; } 辅助数组 创建一个新的数组，然后将除了删除元素的其他元素复制到新数组，再复制回去\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; void removeElement(int arr[], int *size, int index) { if (index \u0026lt; 0 || index \u0026gt;= *size) { printf(\u0026#34;索引超出范围\\n\u0026#34;); return; } int temp[*size - 1]; int j = 0; for (int i = 0; i \u0026lt; *size; i++) { if (i != index) { temp[j++] = arr[i]; } } for (int i = 0; i \u0026lt; j; i++) { arr[i] = temp[i]; } (*size)--; // 更新数组长度 } int main() { int arr[] = {1, 2, 3, 4, 5}; int size = 5; int index = 2; // 要删除的元素索引 removeElement(arr, \u0026amp;size, index); for (int i = 0; i \u0026lt; size; i++) { printf(\u0026#34;%d \u0026#34;, arr[i]); } return 0; } 3.\n1 2 3 #define array_number[int a[],int len] len = sizeof(a)/sizeof(a[]); return 0; 4.数组溢出：访问到数组未定义的内存地址\n现象：如果是内存中未定义的地址，进入非法区域，会导致程序崩溃\n或者是访问到其他数据所在的地址，导致数据破坏影响程序运行\n或者是得到一些未定义的垃圾值\nc语言并不检测数组溢出，所以这算是一个隐性的bug\n注意事项\n右边，在定义时候打了； 也就是没有进行初始化，用循环进行遍历初始化\n第十课-数组 （2）：二维数组 在内存中依然是线性编址\n内存页：\n两种遍历的实例：\n思考：\n数组中用（）括起来的是逗号表达式，需要计算其中的值，此数组中的值{2，4，3，0，0，0}，因为是二维数组，所以写为\n1 2 3 {2,4 3,0 0,0} 作业2：\n1.\n1）直接赋值\n1 int a[1][1]={{1,2},{1,2}} 2）循环遍历输入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 int a[6][6]={0}; for(int i;i\u0026lt;6;i++) { for(int j;j\u0026lt;6;j++) { a[i][j] = rand // 固定数值，或者随机数生成 } } //*还可以通过键盘输入来往数组里面输入值 参考 for(int i=0;i\u0026lt;10;i++) { for(int j=0;j\u0026lt;5;j++) { printf(\u0026#34;Please input the score for %d\\n\u0026#34;,o) scanf_s(\u0026#34;%d\u0026#34;,\u0026amp;score[i][j]); } } //* //个人想法，未搜索 //*以下是网络搜索 #include \u0026lt;stdio.h\u0026gt; int main() { int rows = 3; // 定义二维数组的行数 int cols = 4; // 定义二维数组的列数 int matrix[3][4]; // 定义一个3行4列的二维数组 // 为二维数组的每个元素赋值 for(int i=0; i\u0026lt;rows; ++i) { // 外层循环遍历行 for(int j=0; j\u0026lt;cols; ++j) { // 内层循环遍历列 // 赋值操作 matrix[i][j] = i * cols + j; // 赋值逻辑，这里只是示例，可以根据需要修改 } } // 打印二维数组以验证赋值是否成功 for(int i=0; i\u0026lt;rows; ++i) { for(int j=0; j\u0026lt;cols; ++j) { printf(\u0026#34;%d \u0026#34;, matrix[i][j]); // 打印矩阵元素 } printf(\u0026#34;\\n\u0026#34;); // 每行结束后换行 } return 0; } ———————————————— 版权声明：本文为CSDN博主「凭栏落花侧」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/m0_67484548/article/details/140399701 2.\n存储方式：\n线性存储方式，按照a[0]行，a[1]行的方式，一行一行一个数据一个数据的方式存储，每个元素的长度根据定义长度来\n3.按行遍历的效率高\n因为涉及内存页存储\n内存页是操作系统分配内存的最小单位，通常大小为4KB，用于实现虚拟内存和内存管理。\n内存页的定义:内存页（Memory Page）是操作系统在内存管理中使用的基本单位。它将物理内存划分为固定大小的块，通常为4KB（4096字节）。操作系统通过页表来管理这些内存页，记录虚拟地址与物理地址之间的映射关系\n如果存储数据过多，二维数组的数据存放在不同的内存页，那么按列遍历的方式 就是在内存中频繁跳转，容易导致缓存未命中，预取的命中率不高的问题\n现代cpu可以做到提前加载数据，按行遍历的方式能够完全利用这个机制快速遍历，而按列方式预取器难以预测\n（3）：数组重要注意事项 首地址\na1，代表的int *类型的指针\n\u0026amp;a1，代表的是整个的一维数组\na2，代表二维数组中的一行\n\u0026amp;a2，代表一整个数组\n地址相同，类型不一样，指向的内存也不一样，a1代表的指针就指向了4个字节的内存，而\u0026amp;a1代表十个元素也就是指向了40个字节\na1+1,\u0026amp;a1+1\na2+1,\u0026amp;a2+1 意思是，当前数组所在内存地址，向前移动所属类型的字节数的地址，比如int类型4个字节，这个意思就是a1所在内存地址，向前移动4个字节。\u0026amp;a1+1代表了移动40个字节\n代码：\n1 2 3 4 5 6 7 8 9 10 int a1[10]={0}; int a2[4][5]={0}; printf(\u0026#34;a1:%d,\u0026amp;a1:%d\\n\u0026#34;,a1,\u0026amp;a1); printf(\u0026#34;a2:%d,\u0026amp;a2:%d\\n\u0026#34;,a2,\u0026amp;a2); printf(\u0026#34;a1+1:%d,^a1+1:%d\\n\u0026#34;,a1+1,\u0026amp;a1+1); printf(\u0026#34;a2+1:%d,^a2+1:%d\\n\u0026#34;,a2+1,\u0026amp;a2+1); return 0; 数组做参数\n外部计算长度为40个字节，传入函数内部计算长度退化为指针，长度为4个字节，但是依然可以通过这个指针来访问数组中的每一个元素的\n数组的溢出\n内存溢出，如果访问的该内存地址不存在，导致非法访问，会造成程序崩溃，如果访问的内存地址存在，有可能访问到其他数据，有可能访问到一个垃圾值，对其进行修改可能会破坏程序中其他有用的值，引起整个程序出现异常\n程序1：for循环中i\u0026lt;=16，但是定义的a[16]只有0-15号元素，会导致数组溢出\n程序2：第一个循环遍历里面设定了i\u0026lt;10，也就是说i会遍历0-9号元素，第二个函数定义里面定义a[9]，只包含了0-8号元素，第九号没有定义，也会导致数组溢出\n程序3：i = i+1，a[i]是不存在的，也会导致数组的溢出\n1.代码输出：\nprintf(\u0026ldquo;sizeof(a)=%d\\n\u0026rdquo;,sizeof(a)) 输入应是 40 字节长度 int是整型，代表四字节长度，a数组里有10个元素，共40字节的长度\nfunc(a,10）输入应该4字节长度，因为数组导入函数之后，缩成指针，函数中输出int a 应是int对应的指针长度为4\n2.\n如图，在内存区高到低存储的内存地址分布， ！！！！低到高！！！！\nptr1 int * \u0026amp;a+1 取整个数组a的内存长度往前移动一位 移动之后如图中红色部分所示\nptr2 int) a+1 将数组指针a强制转化为整型并且移动一位\nprintf() ptr1[-1] 往前移动一位之后，再往后取一位，也就是如图中蓝色部分\n​ ptr2 a所处的地址被转化为int型，然后移动一位就是移动一个字节，ptr2所输出是图中黄色部分\n（4）：数组应用 1.斐波那契数列求和（前20项）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int a[20]={0}; a[0]=1; 1[1]=1; for(int o=2;i\u0026lt;20;i++) { a[i]=a[i-1]+a[i-2]; } for(int i=0li\u0026lt;20;i++) { printf(\u0026#34;%d\u0026#34;,a[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; 字符串变大小写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 char str[]=\u0026#34;Hello World, 12345678\u0026#34;; //*从键盘上输入 char str[128]={0}; printf(\u0026#34;Please input a str:\\n\u0026#34;); gets_s(str,128); //* int len = sizeof(str)/sizeof(str[0]); for(int i=0;i\u0026lt;len;i++) { if(str[i]\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp; str[i]\u0026lt;=\u0026#39;Z\u0026#39;) { str[i] += \u0026#39;a\u0026#39;-\u0026#39;A\u0026#39;; } } printf(\u0026#34;%s\\n\u0026#34;,str); return 0; 计算平均值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int score[10]={0}; for(int i=0;i\u0026lt;10;i++) { pruintf(\u0026#34;Please input the score for %d\\n\u0026#34;,o) scanf_s(\u0026#34;%d\u0026#34;,\u0026amp;score[i]); } for(int i=0;i\u0026lt;10;i++) { total += score[i]; } float average_score = (float)total/10; printf(\u0026#34;average score is:%f\\n\u0026#34;,average_score); return 0; 求数组中的最大值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 int a[]={98,123,7,2,77,95,23,999,1001,273}; int max_num=a[0]; for (int i=0;i\u0026lt;sizeof(a)/sizeof(a[0]);i++) { if(max_num\u0026lt;a[i]) { max_num=a[i]; } } printf(\u0026#34;%d\\n\u0026#34;,max_num); return 0; 剪刀石头布： 0,1,2\nresult=(man-computer+4)%3-1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include\u0026lt;stdlib.h\u0026gt; %include\u0026lt;time.h\u0026gt; char name[3][20]={\u0026#34;剪刀\u0026#34;，\u0026#34;石头\u0026#34;，\u0026#34;布\u0026#34;}; int computer=0; int man=0; srand((unsigned int)time(0)); computer=rand()%3 printf(\u0026#34;0:剪刀\\n1：石头\\n2：布3:退出\\n请输入一个数字与计算机一起玩石头剪刀布:\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;man); if(man\u0026lt;0\u0026amp;\u0026amp;man\u0026gt;2) { printf(\u0026#34;非法输入\\n\u0026#34;); return -1; } else if(man==3) { break } printf(\u0026#34;computer:%s,man:%s\\n\u0026#34;,name[computer],name[man]); int res=(man-computer+4)%3-1; if(res\u0026gt;0) { printf(\u0026#34;man win\\n\u0026#34;); } else if(res==0) { printf(\u0026#34;draw\\n\u0026#34;); } else(res\u0026lt;0) { printf(\u0026#34;computer win\\n\u0026#34;); } return 0; //* while(1) { computer=rand()%3 printf(\u0026#34;0:剪刀\\n1：石头\\n2：布\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;man); if(man\u0026lt;0\u0026amp;\u0026amp;man\u0026gt;2) { printf(\u0026#34;非法输入\\n\u0026#34;); return -1; } printf(\u0026#34;computer:%s,man:%s\\n\u0026#34;,name[computer],name[man]); int res=(man-computer+4)%3-1; if(res\u0026gt;0) { printf(\u0026#34;man win\\n\u0026#34;); } else if(res==0) { printf(\u0026#34;draw\\n\u0026#34;); } else(res\u0026lt;0) { printf(\u0026#34;computer win\\n\u0026#34;); } return 0; } 求五位同学三个科目每一个科目的平均成绩：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 char name[3][20]={\u0026#34;Math\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;Foxpro\u0026#34;}; int score[3][5]={ {80,61,59,85,76}, {75,65,63,87,77}, {92,71,70,90,85} }; for(int i=0;i\u0026lt;3;i++) { int total=0; float average=0.0f; for(int j=0;j\u0026lt;5;j++) { total+=score[i][j]; } average=(float)total/5; printf(\u0026#34;%s\u0026#39; s average score is:%.2f\\n\u0026#34;,name[i],average); } return 0; 作业：\n第十一课-字符串 （1）：字符串定义 定义：\n\u0026lsquo;0\u0026rsquo;\u0026ndash;\u0026gt;48\n\u0026lsquo;\\0\u0026rsquo;\u0026ndash;\u0026gt;0\n遇到\\0字符串即结束\n转义字符：\nc语言中字符串是用双引号包裹起来的，需要用转移字符表示此处双引号只是一个引号\n单引号包裹起来的字符叫字符常量\n字符串常量：\n“hello world” 字符常量\n‘a’是一个字符，\u0026ldquo;a\u0026quot;是一个字符串\n“123”是一个字符串，123是一个整数值 可以调用函数互相切换\n“1”.‘1’,1 字符串，字符，整数\n“0”，‘0’，‘\\0’，0，NULL 字符串，字符，字符，整数，指针\n“” 空字符串，仍然有看不见的0字节\nchar *str = \u0026ldquo;hello world\u0026rdquo; 字符指针 ，字符串存放在静态常量区，赋值给了字符指针，指向了常量区\nchar str[]= \u0026ldquo;hello world\u0026rdquo; 字符常量区的字符赋值给了这个字符数组，并且有0字节，一共12个字节\nstr1指向静态常量区，静态常量区不能更改 (str1+1)=\u0026lsquo;a\u0026rsquo; 会报错\nstr2[1]=\u0026lsquo;1\u0026rsquo;;\n字符不可以赋值给指针，地址可以赋值给指针\nL\u0026rsquo;a\u0026rsquo; 占两个字节 unicode编码\n\u0026lsquo;a\u0026rsquo; 占一个字节\n作业：\n0:一个整数，数值 \u0026lsquo;0\u0026rsquo;一个字符常量，值类型 \u0026ldquo;0\u0026rdquo; 一个表示0的字符串 \u0026lsquo;\\0\u0026rsquo; 一个字符变量 “123” 一个字符串 123 一个整数数值 用\\转义符，表示此引号不具有特殊含义 用双引号括起来,然后内部再用两个斜杠来表示 9，1-8八个字符再加上\\0的末尾不可见字符 区别在于每一个元素所占字节数，未标注L 所用是ASCII编码，每一个元素占一个字节，标注L所用UNICODE编码，每一个元素占两个字节 ","date":"2025-10-28T00:00:00Z","image":"http://localhost:1313/p/10-28/bj_hu_cf11fd87aa5b674d.jpg","permalink":"http://localhost:1313/p/10-28/","title":"10-28 笔记"},{"content":"\n补作业代码4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 用while来写 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int a=0,b=0; printf(\u0026#34;Please input two shuzi:\\n\u0026#34;); scanf_s(\u0026#34;%d,%d\u0026#34;, \u0026amp;a, \u0026amp;b); while (a / b \u0026gt; 0) { printf(\u0026#34;%d\u0026#34;,a); goto out; } printf(\u0026#34;%d\u0026#34;,b); out: return 0; } 用一个while和goto来写。\nif除了报错就是程序运行不完善，还在重写。\n除了goto不知道如何在循环执行完了之后忽略后续printf直接到return\n思路缺陷：\n1.怎么将第二次相除之后的结果是否为0和除数代入下一次运算的被除数\n2.循环中如何使用，应该使用几个变量来写入代码\n以下是网络搜索思路：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int a, b, t; printf(\u0026#34;请输入两个数字:\\n\u0026#34;); scanf_s(\u0026#34;%d,%d\u0026#34;, \u0026amp;a, \u0026amp;b); while (a % b != 0) { t = b;//存上一轮的除数 b = a % b;//这一轮的余数做下一轮的除数 a = t;//做下一轮的被除数 } printf(\u0026#34;%d\u0026#34;, b);//最后剩下的除数就是答案 return 0; } 多设置了一个变量在循环体内赋值，更改算式的值，用的是while循环语句\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; int main(void) { int x, y, gcd; printf(\u0026#34;请输入两个正整数：\u0026#34;); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); if(x \u0026lt; y) gcd = x; else gcd = y; while(x % gcd ||y % gcd) gcd--; printf(\u0026#34;gcd = %d\\n\u0026#34;, gcd); return 0; } 用if和while语句并且加上逻辑判断符，先判断大小，\n第十课-数组 （1）：一维数组 统计多个人的平均成绩，引入数组\n数组，一组相同类型的变量连续的存储在一段内存上，并共用一个名字（数组名）。\n每个变量使用下标来区别，并被称作数组的元素。数组的下标是从0开始的\n由定义看出，每个元素的类型相同，因此各个元素在内存中存放的长度也一样，即他们占用的空间等长的，而数组名，就是这段内存的首地址。存放数组的内存也是连续的\n数组根据存放的数据的类型，可分为数值数组，字符数组，指针数组，结构数组等各种类别；而按照数组的维度，又可以分为一维数组，二维数组，三维数组等\n最容易出错，很容易溢出\n数组名，跟表示名一样，必须使用字母，数字，下划线，且数字不开头\na[10]中有0-9，没有10，如果访问a[10]会导致数组溢出，但是程序依然会编译成功，如果溢出之后访问内存，程序会崩溃，读出垃圾数据，或者影响到存储的其他数据。编译器不检测\n“7”的位置可以是表达式，但是必须是常量表达式\n使用a[i]可以直接访问到某个元素（随机访问，通过固定长度乘以下标，能够直接算出地址并对其进行访问连续，加偏移，加固定长度）\n链表不可以，每一个元素不是连续的，每一次找节点必须要从开头开始一个一个寻找\n定义实例：\n*a表示指针\n#define SIZE 宏定义\n初始化：\n已定义了的数组的值可以改变\n如果只定义了一些，没有定义完，那么剩下未定义的值默认为0\n3.是逗号表达式，等价于 int a[10]={1,3,4}\n5.未指定个数，通过后续定义的值来定义数组的长度\n程序赋值，i\u0026lt;10，满足有效元素\n或者通过键盘来输入一个数\n一维数组的初始化与遍历\n键盘为数组赋值例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; int main() { int a[10] = {0}; for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;Please input the value for %d\\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d\u0026#34;, a[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } 定义函数用来打印数组\n1 2 3 4 5 6 7 8 9 10 11 boid print_array(int a[],int len) { for(int i=0;i\u0026lt;len;i++) { printf(\u0026#34;%d\u0026#34;,a[i]); } printf(\u0026#34;\\n\u0026#34;) } print_array(a,number) sizeof(a) a数组所占的长度\nsizeof(a[0]) a数组中第一个元素所占的长度\n因为数组中每一个元素所占长度相同，所以用总长度除以每一个元素所占长度，就能够计算出数组中元素个数\n即sizeof(a)/sizeof(a[0])\n","date":"2025-10-27T00:00:00Z","image":"http://localhost:1313/p/10-27/bj_hu_d5957c798504a6a6.jpg","permalink":"http://localhost:1313/p/10-27/","title":"10-27 笔记"},{"content":"第七课（2）：表达式 表达式由运算符、常量及变量构成。每一个表达式，都有对应的一个值。该值与表达式中操作符的优先级和结合律有关\n逗号表达式：先算a的值，再算b的值，从左往右依次计算，f的值，就是整个式子最终的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main() { int a, b, c; a = b = 1; printf(\u0026#34;%d\\n\u0026#34;, (c = a++, b++, ++b); printf(\u0026#34;a:%d\\n\u0026#34;, a); printf(\u0026#34;b:%d\\n\u0026#34;, b); printf(\u0026#34;c:%d\\n\u0026#34;, c); return 0; } 输出结果为\n3 a:2 b:3 c:1\n1 2 3 4 int get_max(int a,int b,int c) { return (a\u0026gt;b?a:b)\u0026gt;c?(a\u0026gt;b?a:b):c; } ()(a++)++)+b会报错，a++之后是常量，常量不能再进行++\n作业\n1.\ni++和++i 单独成语句的时候，都是对i进行加1操作，无区别\n但是在赋值语句中\na = i++ 意为，先把i的值赋给a，在对其进行加1操作\na = ++i 意为，先对i进行加1操作，在赋值给a\n2.\nc=a++,b++,++b\n先算\u0026quot;=\u0026quot;,即c=a++ 结果是c = 1 ，a = 2\n然后是逗号运算符，b++和++b，取++b的值为逗号运算符的结果，即为2\n算完++b，最后算b++，即b=3\n分析结果为 a=2,c=1,b=3\n输入代码查看结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int a, b, c; a = b = 1; c = a++, b++, ++b; printf(\u0026#34;a:%d\\n,b:%d\\n,c:%d\\n\u0026#34;, a, b, c); return 0; } 结果正确\n3.分析，\n逗号运算符，从右往左开始运算，\u0026ndash;i,先减1再取i，第四个值取9，也就是整个逗号运算的值取9\n然后是i\u0026ndash;，先取i再减1，第三个值为9，i=8，\n之后++i，先加后取，i=9\n最后i++，先取后加，取9，i = 10\n表达式求值顺序结果应该为 9,9,9,9\n从编译器角度，从左到右编译，即\ni++, 取10,i=11\n++i,取12，i=12\ni\u0026ndash;,取12，i=11\n\u0026ndash;i,取10，i=10\n从左到右编译器取值应该为 10,12,12,10\n导入c语言程序中，取值为9.10.9.10。询问ai得知：\n//为了得到 9,10,9,10，我们需要一个更“激进”的假设：编译器在处理前置操作时，考虑到了所有排队中的后置操作。\n初始状态：i = 10 编译器发现：有两次后置操作（i++ 和 i--）在排队。它们的效果是 +1 和 -1，净效果为0。所以编译器“聪明地”认为，在计算前置操作时，可以忽略这些后置操作的影响，因为它们会相互抵消。 计算前置操作： ++i：基于 i=10，10 + 1 = 11。 --i：基于 i=10，10 - 1 = 9。 注意：这里 --i 的结果变成了 9。 计算后置操作： i++：取当前 i 的值。如果编译器在计算完所有前置操作后，将 i 的最终值（基于所有修改）临时设定为 9（来自 --i 的效果），那么 i++ 取到的值就是 9。 i--：同样，如果此时 i 被认为是 10（比如 ++i 的效果也应用了），那么 i-- 取到的值就是 10。 通过这种极其混乱且不符合常规逻辑的中间状态计算，理论上编译器可能产生 9,10,9,10 这样的输出。//\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int i = 10; printf(\u0026#34;%d,%d,%d,%d\\n\u0026#34;, i++, ++i, i--, --i); return 0; } 4.可以之间让两个数相减或者相除，然后进行if判定，是否大于0，或者大于1，或者余数大于0等\n1 2 3 4 5 6 7 8 9 int main() { int a,b; printf(\u0026#34;Please input two shuzi\u0026#34;); if(a/b\u0026gt;0): printf(\u0026#34;%d,a\u0026#34;); else: printf(\u0026#34;%d,b\u0026#34;); } 第八课：程序的语句 三种结构\n定义语句\u0026amp;表达式语句\u0026amp;赋值语句 定义语句，在使用变量之前必须要对去其进行定义\nint i=1; \u0026ndash;\u0026gt;定义一个整型变量i，它的值为1，值为1相当于初始化，也可以不初始化，不初始化i的值就是一个垃圾值，尽量不要不初始化，定义一个值\n表达式语句\ni++; 自增\ni+1; 无意义\ni; 无意义\n5； 无意义\na=5;\n函数调用语句\n#include\u0026lt;stdlib.h\u0026gt;\nsrand((int)time(0)); srand生成随机数的种子，一般是以当前时间作为随机数的种子\nrand() ; 生成一个随机整数 必须包含上述stdlib的头文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() {\tsrand((unsigned int)time(0)); for (int i = 0; i \u0026lt; 10; i++) { printf(\u0026#34;%d\u0026#34;, rand()%100); } printf(\u0026#34;\\n\u0026#34;); return 0; } 控制语句之分支语句：\n1.if{}\n2.if{}\nelse{}\n3.if{}else if 可以有多个else if\n{}\nelse //else部分可以省略\n{}\n判断函数奇偶性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() {\tint value = 0; printf(\u0026#34;Please input an integer:\\n\u0026#34;); scanf_s(\u0026#34;%d\u0026#34;, \u0026amp;value); if (value % 2 == 0) { printf(\u0026#34;%d is an even number\\n\u0026#34;, value); } else { printf(\u0026#34;%d is an odd number\\n\u0026#34;, value); } return 0; } 语句里只有一句话可以不加大括号，否则需要\n大写转换小写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() {\tchar ch; printf(\u0026#34;Please input an character:\\n\u0026#34;); scanf_s(\u0026#34;%c\u0026#34;,\u0026amp;ch,1); if(ch\u0026gt;=\u0026#39;A\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;Z\u0026#39;) { ch+=\u0026#39;a\u0026#39;-\u0026#39;A\u0026#39;; } printf(\u0026#34;%c\\n\u0026#34;,ch); return 0; } 条件判断必不可少，否则如果输入了其他数字会导致输出出错\n控制语句之分支语句：switch语句 switch语句是一种多路判定语句，它测试表达式是否与一些常量整数值中的某一个值匹配，并执行相应的分值动作。所以switch语句也是一种分支语句，可以和if语句互相转换。\nswitch(a) // a只能为整数(char,short,int,long等)，不能为指针，浮点数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { char ch; printf(\u0026#34;Please unput the score level:\\n\u0026#34;); scanf_s(\u0026#34;%c\u0026#34;, \u0026amp;ch, 1); switch (ch) { case \u0026#39;A\u0026#39;: printf(\u0026#34;your score \u0026gt;=90\\n\u0026#34;); break; case \u0026#39;B\u0026#39;: printf(\u0026#34;your score \u0026gt;=80\\n\u0026#34;); break; default: printf(\u0026#34;your score \u0026lt;=60\\n\u0026#34;); } return 0; } 控制语句之循环语句：for,while,do-while 表达式1，可以进行初始化\n条件表达式，用来控制循环是否开始或退出的\n表达式3，更新，比如i++，用来更新循环里的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 循环求和 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int sum = 0; for (int i = 0; i \u0026lt; 10; i++) { sum += i; } printf(\u0026#34;sum:%d\\n\u0026#34;,sum); return 0; } do while循环后有分号，\n先执行循环体，再执行是否符合条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int i = 0; do { printf(\u0026#34;i:%d\\n\u0026#34;,i); i++; } while (i \u0026gt; 100); return 0； } 会输出一个i = 0，因为是先执行循环体语句，再执行while语句，不符合条件即停止。\n控制语句之转向语句 goto\n慎用goto\n出错处理（2内存，1文件打开失败）；\n跳出多重循环\n循环中的转向语句\nbreak 退出循环\ncontinue // 吃饭看到头发？break；吃饭筷子夹肉掉地上了？continue\n即忽略之后的语句，重新开始下一次的循环\nreturn：返回语句，后面是返回值，一般存储在寄存器中，32位放在eax中，64位放在rax中\n未定返回值可以直接return，定了就必须返回一个值\nreturn不仅退出循环，退出的是整个函数，执行return后，后续的代码将不再被执行\nreturn 0；\nreturn；\nbreak跳出多重循环\ngoto out\n可以直接跳到out的语句，一部能跳出多重循环\n复合语句\u0026amp;空语句 复合语句-{}；\n空语句-；\n第九课：编码风格 断行 一般按照运算符切断\n每一行只写一条语句方便进行调试\n1 2 a += 5; b -= 10; 分行定义变量\n1 2 3 int a=10; int b=20; int c=30; 空行分割代码块\n功能相近的代码块之间可以用空行\n1 2 3 4 5 6 7 8 9 int a=10; int b=20; int c=30; a += 5; b -= 10; printf(\u0026#34;a:%d\\n\u0026#34;,a); printf(\u0026#34;b:%d\\n\u0026#34;,b); 未缩进示例：\n判断比较\n","date":"2025-10-26T00:00:00Z","image":"http://localhost:1313/p/10-26/bj_hu_df269ae190dc3e5a.jpg","permalink":"http://localhost:1313/p/10-26/","title":"10-26 笔记"},{"content":"\n输出16进制前缀的整数\n%#x\\n 即可，如果想用0补充位数不够显示的，比如15转化为16进制为f，想要显示0f就\u0026quot;%02x\\n\u0026quot;\n输出64位整数\n__int64 value=100I64\nprintf(\u0026quot;%I64d\\n\u0026quot;,value)\nhd，短整型。d，标准整形。ld，长整型\n无符号：%u 来打印\n%f 单精度浮点数 %lf 双精度浮点数 %.7lf 保留到7位双精度浮点数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #pragma warning(disable : 4996) int main(int argc) { //char c; //wchar_t wc; //float f; //double d; char buf[80] = {0}; printf(\u0026#34;Please input a string:\\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, buf); //数组名称代表了内存地址，之前的所有数都需要取内存地址输入 printf(\u0026#34;%s\\n\u0026#34;, buf); //scanf函数遇到空格即退出函数， return 0; } 浮点数和整数可以不设定长度，因为长度固定且已知\n字符，字符串等都需要设定长度，如果输入超过设定长度的数，那么多出来的数会破坏原本存储在内存空间里的其他的数据，导致其他破坏\nscanf_s(\u0026quot;%s,buf,80\u0026quot;)\ngets_s(\u0026quot;%s,buf,80\u0026quot;)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; #pragma warning(disable : 4996) int main(int argc) { char c; wchar_t C; short s; int i; long l; __int64 value = 100I64; float f; double d; char buf[80] = {0}; printf(\u0026#34;Please input the data:\\n\u0026#34;); scanf(\u0026#34;%c%hd%d%ld%I64d%f%lf%s\u0026#34;,\u0026amp;c,\u0026amp;s,\u0026amp;i,\u0026amp;l,\u0026amp;value,\u0026amp;f,\u0026amp;d,buf); printf(\u0026#34;c:%c s:%hd i:%d l:%ld value:%I64d f:%f lf:%lf buf:%s\\n\u0026#34;, c, s, i, l, value, f, d, buf); return 0; } 多重输出，加宽字节会出bug导致无法输出。\nfd，文件描述符表，每个进程独立拥有的指向任何一打开的文件，管道，设备等任何资源的引用或句柄，一种资源调配的数字编号\n1.输入一个变量需要用取值符\u0026amp;获取其内存地址，字符串不需要，字符串的数组存储在计算机\n2.scanf函数调用\u0026quot;%ws\u0026quot;或\u0026quot;%S\u0026quot;,用w加s或者大写s来输入，printf(\u0026quot;%S\u0026quot;)同样用%S来表示输出\n3.scanf不检测缓存区，只将输入值原封不动导入，如果大于其原本设置的内存长度，会挤压其内存空间中其他数据，导致数据错误等安全问题。scanf_s能够检测缓存区，比scanf更安全\n溢出检测\n4.scanf遇到空格即会退出函数，gets会包括空格一起输入\n5.gets与gets_s和scanf与scanf_s一样，是否检测缓存区的问题\n6.getch不显示输入字符，按下任意一个键即返回.\ngetchar显示输入字符，需要按下回车键才返回\n7._getch是新的安全的函数,安全在哪：1.函数内部对线程的调动上锁，防止字符或者字节在调用的过程中被不同线程影响。2.两次不同的调用，来增加安全\n8.代码中某些函数过时，有安全风险，没有安全检测，容易产生安全漏洞\n第七课 (1):运算符 运算符是指对特定类型的变量或者常量要进行的操作，在运算符中被操作的变量或者常量叫做操作数。只有一个操作数的运算符叫单目运算符，只有两个操作数的叫双目运算符，有三个操作数的叫三目运算符。\n举例：\n1 2 3 4 \u0026amp;，++，！，~ 都是单目运算符 sizeof也是单目运算符 + - * / 就是一种二目运算符 ？： 唯一的三目运算符 逻辑非 !false !FALSE !0\ntrue\n!-1,!1,!2\nfalse\n自增，自减：I++,++i,i\u0026ndash;,\u0026ndash;i\ni++和i\u0026ndash; 1,c语言的内建型别：\ni++；\n++i；是没有任何区别的，单独形成语句，都是把i进行+1操作\n2.c++里\n如果i是一个对象，不是内建型别，++i的效率要比i++要高\n3.在复合表达式或者赋值语句里：\nint i=0;\nint a = i++; 先把i的值赋值给a，然后再对i进行相加// a = i ; i = i + 1 \u0026mdash;. a = 0 , i = 1\nint i=0;\nint b = ++i; // i = i + 1 ; b = i ; \u0026mdash;\u0026gt; b == 1,i == 1\n4.函数中：\nint i=0;\nprintf(\u0026ldquo;i:%d\\n\u0026rdquo;,i++);\ni = 0;\nprintf(\u0026ldquo;i:%d\\n\u0026rdquo;,++i);\ni = 0;\nprintf(\u0026quot;%d %d\\n\u0026quot;,i++,++i); // 不同的编译器产生的结果不一样\n强转 (int)3.14f \u0026ndash;\u0026gt;浮点转整数\nsizeof 用来计算类型，变量，常量的长度 如图，类型必须加括号，常量、变量可以不加括号\n/ 取商 %取余数\n比较运算符 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= == !=\n写a\u0026gt;b\u0026gt;c，需要写成 a\u0026gt;b \u0026amp;\u0026amp; b\u0026gt;c 必须单独比较\n可以用常量 == 变量的相等方式来验证是否赋值 （常量与变量比较）\na == 1 a = 1 1 = a 1 == a\n0和整数进行比较直接用== 即可\n如果是和浮点数和零比较 ,不能直接进行比较，浮点数不精确 fabs是math.h中的绝对值\nfabs(x)\u0026lt;=1e-6 \u0026mdash;\u0026gt;\n逻辑运算符：含义与计算顺序 \u0026amp;\u0026amp;：只要一个为0就停止计算 和\n||：只要一个为1就停止运算 或\n与的优先级大于或的优先级\n三目 ？： 常量变量都可以，也可以是一个符合要求的表达式\na?b:c \u0026ndash;\u0026gt;如果a为真，则取b的值为这个式子的表达式\n​ 如果a为假，则取c的值为运算符的值\n复合运算符 =\n+= a = a+50 a += 50\n*= a=a *100 a *= 100\n-= a = a -20 a -= 20\n/=\n%=\na \u0026laquo;= 2; a = a\u0026laquo;2 a左移两位\n逗号运算符 , i++,j++,(逗号表达式的求值，非常容易错)\n运算符的结合律与优先 运算符的优先级和结合律决定操作数的结合方式，当复合表达式中的运算符的优先级不同时操作数的结合方式是由优先级决定。当符合表达式中的运算符的优先级相同时，操作数的结合方式由结合律决定。不过，我们也可以使用扩号强制把操作数结合在一起。\n作业\n1.\n代码中的比较 NULL == p ,p ==NULL ,0 == i 与 i == 0 比较意义上是等效的，不过反写成0 == i ,NULL == p可以防止，如果在少打了一个等号的情况下，代码打成 0 = i 这样的代码会报错，能够有效的检查出代码错误\n2.\na %= 5 等效为 a = a % 5\na *= 5 等效为 a = a * 5\n","date":"2025-10-25T00:00:00Z","image":"http://localhost:1313/p/10-25/bj_hu_c61698d7d7a62cf7.jpg","permalink":"http://localhost:1313/p/10-25/","title":"10-25 笔记"},{"content":"栈增长，高地址到低地址\n数据存入，低地址到高地址\nesp ding ebp di\neip 保存吓一跳要执行的指令的地址\nleave指令相当于\nrip64 eip32\n第六个：输入输出 stdio scanf 输入 printf 输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #pragma warning(disable : 4996) int main(int argc, _TCHAR* argv[]) { char c; wchar_t wc; short s; int i; long 1; //float f; //double d; //char buf[80] = {0}; printf(\u0026#34;Please input a character:\\n\u0026#34;); //scanf(\u0026#34;%c\u0026#34;, \u0026amp;c); scanf_s(\u0026#34;%c\u0026#34;, \u0026amp;c, 1); //只能用在windos平台 printf(\u0026#34;%c\\n\u0026#34;, c); fflush(stdin); //清空回车键 printf(\u0026#34;Please input a another character:\\n\u0026#34;); scanf(\u0026#34;%C\u0026#34;, \u0026amp;wc); //宽字符，大写的C,或者wc也可以 printf(\u0026#34;%wc\\n\u0026#34;, wc); scanf_s(\u0026#34;%c\u0026#34;, \u0026amp;c, 1); fflush(stdin); printf(\u0026#34;please input a char\\n\u0026#34;); char c1 = getch();//不会显示在屏幕上 ,a prindf(\u0026#34;plesse int input a char\\m\u0026#34;); char c2 = getchar(); printf(\u0026#34;c1:%c,c2:%c\\n\u0026#34;,233,c2); fflush(stdin); return 0; } 其中scanf会提示4996的错误，调用scanf可能会导致数据溢出带来的安全风险。\n","date":"2025-10-24T00:00:00Z","image":"http://localhost:1313/p/10-24/bj_hu_a05c4a6bdb74789f.jpg","permalink":"http://localhost:1313/p/10-24/","title":"10-24 笔记"},{"content":"查漏补缺 初始化与预处理 区别：预处理发生在程序运行之前，也就是导入模块，替换头文件等操作\n​ 初始化发生在程序开始运行时，将代码中的值写入变量对应的内存\n程序构成 预处理，导入代码中需要的模块，函数\n编译，将输入的高级语言，转化为汇编语言，\n汇编，将汇编语言转变为机器语言，也就是二进制语言\n链接，将多个文件合并装订在一起，形成可执行文件\n壳 将原本的文件加密压缩到新文件，然后混合壳的代码形成新的可执行文件，在新的可执行文件中，文件头记录的ep即是壳的入口也就是更改之后的文件入口，而原始文件入口oep被隐藏，此为加壳\n调试信息 调试信息包含源代码，内存地址，寄存器，函数地址等大量汇编简化信息，用来辅助调试程序运行和修复错误\n程序，进程，线程 程序是静态的，是代码的链接，进程的启动器\n进程是一次程序的执行过程，拥有开始到结束运行的完整的生命周期，进程与进程之间相互隔离，通信难度大\n线程是一个进程内的cpu调度，一个进程可以有多个线程来帮助完成作业，但是线程与线程之间相互影响\n进程是资源分配的基本单元，线程是调度的基本单元\n处理器，核，cpu 核是一个计算核心，包括了算术逻辑单元核浮点数逻辑单元\ncpu是用来运算核流程控制的部件，可以同时装载多个核来提高并行处理能力\n处理器是完整的计算芯片，可能包含多个cpu和gpu\n内建型别 即函数的基本类型，c语言中一定要明确函数的类型，不同类型的数不能够轻易改变\n字符，数据，整形，布尔，头文件，实数，\n数据结构体，列表节点，二次参数 数据结构体相当于一个自定义的数据包裹，捆绑了多个不同类型的数据变量，作为一个整体来使用\n列表节点是构成“链表”的基本单元，用来帮助链表动态的增长或者缩短\n二次参数，主函数的命令行参数\n","date":"2025-10-23T00:00:00Z","image":"http://localhost:1313/p/10-23/bj_hu_b4ea9c55e4fb2c4.jpg","permalink":"http://localhost:1313/p/10-23/","title":"10-23 笔记"},{"content":"第五课-变量 c语言变量定义与命名 常量:固定不变的量 100 //int 整数\n‘a’ //character 字符\n\u0026ldquo;hello world\u0026rdquo; //string 字符串\n3.1415926 //double 双精度浮点数\n1.732f //float 单精度浮点数\n#define PI 3.1415926 定义一个PI，宏定义\n变量 变量是内存或寄存器中用一个标识符命名的存储单元，可以用来存储一个特定类型的数据，并且数据的值在程序运行的过程中可以进行修改\n变量就至少可为我们提供两个信息：\n一是变量的地址，也就是操作系统为变量在内存中分配的若干内存的首地址\n二是变量的值，也就是，变量在内存中所分配的那些内存单元中所存放的数据\nint a = 10 常量赋值整型a\na = 100 修改a的值\n\u0026amp;a \u0026amp;：取值符，获得变量a在内存中的地址，常量是没有内存的，不能在常量前加\nprintf(\u0026ldquo;addr.%p,value:%d\\n\u0026rdquo;,\u0026amp;a,a);\n变量命名原则 ***变量名由字母，下划线和数字组成，但第一个字符必须为字母，下划线也被看做是字母。***大写字母与小写字母是有区别的，比如a与A是两个不同的变量名。一般大写字母组成的名字用作符号常量。\n变量名不能与C编译系统中哥已经预定义的，具有特殊用途的关键字同名。比如float,auto,break等\n一个变量的名字，一般说来，变量名与函数名应该足够长，以有效地描述所命名的变量或函数。应该避免使用短而模糊的名字，因为它们在别人理解你的程序时会带来麻烦。大多数ANSI编译程序允许有至少31个有效字符，即只有变量或函数名的钱31个字符的唯一性会被检查。一种较好的经验是使函数名的前31个字符的唯一性会被检查。一种较好的经验是使函数名或变量名读起来符合英语习惯。代码的自解释性。\n一般来说，一个局部变量的名字，建议使用比较短的名，而全局变量，使用比较长的名字。比如，一个用于循环的局部变量，一般用一个i来作为名字就足够了\n在windows平台，变量的命名一般遵循匈牙利法则，unix和linux不推荐\n基本原则：变量名=属性+类型+对象描述\nlinux：不推荐大小写混用，一般标识符或者函数名只有小写字母和数字和下划线构成\n匈牙利命名法则 图中helloworld改成人名更贴切\n其他变量法则\nlinux也可以叫做下划线命名法\n作业\n变量作用域，存储空间，生命周期 重点 绝对重点\n系统内存布局\n内核空间，只能有最高权限的内核代码才能访问\n进程空间，\nNULL空间是无法访问的\n非法区域隔离内核和进程，所有的进程进入内核空间，对所有进程共享，每个进程在进程空间中是互相隔离的，不能互相访问，传递；或者使用专门的通信\n程序内存布局\n一个进程空间的布局\n代码区存放代码，静态区存放数据\n堆区，可以在堆区上手动分配内存\n栈是从上往下增长，空间有限，不能无限增长\n内核空间严禁使用递归算法，不断调用自己的时候会吞空间\n未初始化的全局变量和静态变量（没有被定义）的值默认为零\n汇编代码会在程序运行时将没有定义的变量全部设为0，变量需要经过初始化才能使用\n变量分类：全局变量，局部变量，静态变量（静态全局变量和静态局部变量），寄存器变量\n全局变量：全局变量的说明的位置在所有函数之外，整个程序可见，生命周期为整个程序运行期间，存储位置为静态存储区\n全局静态变量：与全局变量唯一不同的地方是作用域：当前源文件，别的文件不饿能访问该变量-demo\n局部变量：在函数内部说明的变量为局部变量，只有在函数执行时，局部变量才存在，当函数执行完推出后，局部变量随之消失。作用域为函数内部，存储空间为栈\n局部静态变量：与局部变量的区别是，存储在静态区，整个程序运行期间有效，具有记忆功能，值初始化一次，下次调用函数，保留着上次函数运行之后的值-demo\n寄存器变量：不像其他变量那样在内存中存放数据，而是在cpu的寄存器中暂存数据，使用寄存器变量比使用内存变量的操作速度快得多，只有整形和字符型变量可定义为寄存器变量，由于cpu中寄存器有限，尽量减少使用数量和占用时间，用完马上释放；不能定义为全局变量，也不能定义在结构或者类中\n举例\n初始化的全局变量，存放在.data区，未初始化的全局变量存放在.bss区。例如例子中的0和p1，一个是初始化了存放在data区，一个没有初始化存放在bss区\n生命周期：变量的有效期，从创建到消亡到失去作用。全局变量，即从程序开始运行到结束运行，都有意义\n在不同源文件中定义的全局变量，他们的初始化是不分先后的。如果在同意文件中给，先定义的就先初始化。\n全局静态变量，存储空间和生命周期都与全局变量一样，但是作用域不一样，只能在当前源文件可以访问使用，别的源文件无法访问和使用，用来防止命令冲突（一个项目中不能同时出现两个一样的变量名 ）\n用extern 来声明，导入其他源文件的全局变量\n函数的调用，数据的传递，内存的分配都是在栈上\n作业\npython 集合 集合中所有元素都是无序的且独一无二的\n创建一个集合\n1.花括号\n{\u0026ldquo;fish\u0026rdquo;,\u0026ldquo;python\u0026rdquo;}\n2.集合推导式\n{s for s in \u0026ldquo;fish\u0026rdquo;} -\u0026gt; {\u0026lsquo;h\u0026rsquo;,\u0026lsquo;i\u0026rsquo;,\u0026lsquo;f\u0026rsquo;,\u0026rsquo;s\u0026rsquo;}\n3.类型构造器 set\nset(\u0026lsquo;fish\u0026rsquo;)\n集合不能使用下标来访问\n可以使用in来判断某个元素是否存在于集合中\n或者使用for in迭代来访问集合中的元素\n唯一性 可以给元素去重\ns = [1,1,2,3,5] len(s) == len(set(s))\ncopy 浅拷贝操作\nt = s.copy()\n检验是否毫不相干 相干，即是否拥有交集\ns.isdisjoint(set(\u0026quot;python\u0026quot;))\n当然，也可以直接传入一个字符串\ns.isdisjoint(\u0026quot;python\u0026quot;)\n子集\ns.issubset(\u0026quot; \u0026quot;)\n超集\ns.issuperset(\u0026quot; \u0026quot;)\n并集：将其他元素与原集合合并\ns.union({ })\n交集\ns.intersection(\u0026quot; \u0026quot;)\n差集\ns.difference(\u0026quot; \u0026quot;)\n对称差集：不支持多参数\ns.symmetric_difference(\u0026quot; \u0026ldquo;)\n可以用运算符直接运算\n\u0026lt;= 检测子集 \u0026lt; 检测真子集 \u0026gt; 真超集 \u0026gt;= 超集\n| 并集 \u0026amp; 交集 - 差集 ^ 对称差集\n使用运算符的话左右两边需要都需要是集合\n可变和不可变 set \u0026amp; frozenset update(*others) 将使用others参数的值来更新集合 （多个）\ns.update([1,1],\u0026quot;23\u0026quot;)\n上述代码得到的集合内容则会只添加\u0026quot;1\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;3\u0026rdquo;\nintersection_update\ndifference_update\nsymmetric_difference_update\n如果没有update则返回的是计算结果，并不会更改该集合里面的内容\n单纯的只添加数据\ns.add(\u0026quot;\u0026quot;)\n之前是迭代出每个元素插入，add是可以将字符串插入\ns.remove 会抛出异常\ns.discard 会静默处理\npop 随机从集合中弹出一个元素\nclear 直接清空\n可哈希\n正确创建字典或者说集合，必须要求键或元素必须是可哈希的\nhash(object)\nhash(1) = hash(1.0) 对一个相等的值，尽管是不同的对象\n大多数可变对象是不可哈希的，不可变对象是可哈希的\n集合的嵌套，需要使用frozenset\n","date":"2025-10-22T00:00:00Z","image":"http://localhost:1313/p/10-22/bj_hu_3ba1bc852e2ca5af.jpg","permalink":"http://localhost:1313/p/10-22/","title":"10-22 笔记"},{"content":"c语言基础 类型长度与取值范围 类型长度-sizeof sizeof(char) 1 sizeof(wchar_t) 2或4 sizeof(short) 2 sizeof(int) 4 sizeof(long) 4 linux X86为4，X64为8 sizeof(float) 4 sizeof(double) 8 sizeof(bool) 1 C99之后或者C++ sizeof(BOOL） 4 win 在需要使用类型长度的时候，不要使用硬编码，直接使用1，2，4这种就是使用硬编码，使用sizeof，比如用sizeof（int）代替4，提高代码的可移植性，（同一串代码的不同平台的移植性）\nsizeof计算类型或者变量长度，字节为单位，是操作符，不是函数，在编译阶段确定，而不是运行阶段 决定一串代码是函数还是操作符，看其结果是在编译阶段确定还是在运行阶段确定，sizeof在编译阶段即确定\n各个类型表示的数的范围 最大值和最小值表示： 无符号： unsigned int max = (unsigned int)-1;//1111 1111 1111 1111 unsigned int min = 0 有符号 int max = 0x7fffffff=0111 1111 1111 1111 0x7f ff ff ff int min =0x80000000 = 1000 0000 0000 1111,0x80 00 00 00 （除了符号位之外其他的全部为0）\n整数溢出之后发生什么 char(-128*-1) 上溢 1：变成最小值 下溢出1：最大值 举例：有符号 -129-1// -129 -\u0026gt;127 127+1//128 -\u0026gt;-128 无符号 255+1 = 0 0-1=255\nUTC 世界标准时，与GMT（格林尼治时间）\n类型转换 强制转换 类型转换：将一种类型转换为另一种类型，一种类型指针转为另一种类型指针 强制转换：（新类型，写要转换的哪一个量）变量 从小到大：小，指的是字节小，从字节小的转化为字节大的 char c = \u0026lsquo;a\u0026rsquo; short i = (short)c int a = (int)i unsigned int u = (unsigned int)a （有符号数和无符号数也能强制转化） long b = (long)a float c = (float)b double d = (double)c 小到大转换的时候，符号位填充多出的尾数 00110101 \u0026ndash;\u0026gt; 00000000 00110101 \u0026ndash;\u0026gt; 10110100 \u0026ndash;\u0026gt;11111111 10110100 \u0026ndash;\u0026gt; short s = 0x12 int i = (int) s ..i -\u0026gt;0x00 00 00 12 short s = -0xff ee //-18 int i = (int)s //i -\u0026gt;0xff ff ff ee\n浮点数到整数 int i =(int)3.14 //取整，非四舍五入\n从大到小： int x = 0x12345678 short y = (short)x y==0x5678截断，丢弃高位 大字节缩小到小字节\n自动（隐式）转换（1） 1）若参与运算量的类型不同，则先转换成同一类型，然后进行运算 2）转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算 a.若两种类型的字节数不同，转换成字节数高的一种类型 b.若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型 3）所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，在做运算 4）char型和short型参与运算时，必须先转换成int型 5）再赋值运算中，赋值号两边量数据类型不同时，赋值号右边量的类型将转换为左边量的类型，类型不一致，可以能降低精度 6）算数运算中，加减乘除取余以及符号运算。 不同类型数据必须转换成同一类型的数据才能运算，算数转换的原则为： a若运算数中有double型或float型，则其他类型数据均转换成该类型进行运算 b若运算数种最长的类型为long型，则其他类型数据转换lang型函数 c若运算数种最长类型为int型，则char型也转换成int型进行运算，算术转换是再运算过程中自动填充而行的 7）函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。char和short会被转换成int，float会被转化为double 8）函数有返回值时，系统将隐式地返回表达式类型转换为返回值类型，赋值给调用函数 无论是强制转换后世自动转换，都只是为了本次运算的需要而对变量的数据长度进行的临时性转换，而不改变数据说明是对该变量定义的类型 float f = 5.34f int x = (int)f f虽为强制转为int型，但只在运算中起作用，是临时的，而f本身的类型并不改变\n赋值中的类型转换 当赋值运算符两边的运算对象类型不匹配时，将要发生的类型转换，转换的规则是：把赋值运算符右侧表达式的类型转换为左侧变量的类型 （1）浮点型与整形 将浮点数（单双精度）转换为整数时，将舍弃浮点数的小数部分，只保留整数部分。将整型值赋给浮点型变量，数值不变，只将形式改为浮点形式，即小数点后带若干个0，注意，负值时的类型转换实际上是强制的 （2）单双精度浮点型 由于c语言中的浮点值总是用双精度 表示的，所以float型数据知识在尾部加0延长为double型数据参加运算，然后直接赋值，double型数据转换为float型时，通过截尾数来实验，截断前要进行四舍五入操作 （3）char型与int型 int型数值赋给char型变量时，只保留其最低八位，高位部分舍弃 char型数值赋给int型变量时，一些编译程序不管其值大小都做整数处理，而另一些编译程序在转换时，若char型数据值大于127，就作为负数处理。对使用者来讲，如果原来char型数据取正值，转换后仍然为正值；如果原来char型值可正可负，则转换后也仍然保持原值，只是数据的内部表示形式有所不同 （4）int型与long型 long型数据赋给int型变量时，将低16位值送给int型变量，而将高16位截断舍弃。（这里假定int型占两个字节）将int型数据送给long型变量时，其外部值保持不变，而内部形式有所改变。 （5）无符号整数 将一个unsigned型数据赋给一个占据同样长度存储单元的整形变量时（如：unsigned-\u0026gt;int，unsigned long-\u0026gt;long，unsigned short -\u0026gt;short），原值照赋，内部的存储方式不变，但外部的值却可能改变。 将一个signed整形数据赋给长度相同的unsigned型变量时，内部存储形式不变，但外部表示时总是无符号的。\n","date":"2025-10-21T00:00:00Z","image":"http://localhost:1313/p/10-21/bi_hu_6517c387130871dc.jpg","permalink":"http://localhost:1313/p/10-21/","title":"10-21 笔记"},{"content":"c语言基础 ASCII码，美国标准信息交换代码\nASCII码是单字节编码系统，它使用指定的7位或者8位二进制数组合来表示128或256种可能的字符 标准ASCII码也叫基础ASCII码，使用7位二进制数来表示所有的大写和小写字母，数字0-9，标点符号，以及在美式英语中使用的特殊控制字符 char c= \u0026lsquo;A\u0026rsquo;,//c=65\nchar ch=\u0026lsquo;0\u0026rsquo;;//ch=48\nUNICODE编码 ASCII编码只能表示有限的字符数，为了能够将世界上所有的字符都纳入编码范围，UNICODE字符编码便产生了，在UNICODE字符编码中，经常采用的是用2个字节或4个字节来表示一个字符，UNICODE编码的具体实现包括UTF-8，UTF-16和UTF-32。其中UTF-8中的字符占用的字节可以从1到4个，而UTF-16占两个字节，UTF-32占4个字节。 unicode编码兼容ASCII编码 \u0026lsquo;0\u0026rsquo; \u0026lsquo;1\u0026rsquo;被引号括起来，表示1和0的字符，有对应的编码，而0，和1对应的就是整数的值， 如何把一个字符转化成整数： c - \u0026lsquo;0\u0026rsquo;// \u0026lsquo;5\u0026rsquo;-\u0026lsquo;0\u0026rsquo;=5 (减0这个字符) 整数转化成字符： i + \u0026lsquo;0\u0026rsquo;// 5+\u0026lsquo;0\u0026rsquo;=\u0026lsquo;5\u0026rsquo; （加0这个字符） 大写转小写 char c = \u0026lsquo;M\u0026rsquo; c + \u0026lsquo;a\u0026rsquo; - \u0026lsquo;A\u0026rsquo; 字母大小写之间转化差32位值，所以加上小a减大A，不直接写32是为了能看懂 char ch=\u0026lsquo;y\u0026rsquo; ch + \u0026lsquo;A\u0026rsquo;-\u0026lsquo;a\u0026rsquo; a=97 A=65\n整形 short int 简写为 short int long int 简写为 long long long _int64 char也可以看作一种整型 short a1 = 100 int a2 = 0x64 long a3 = 100L unsigned short a4 = 100 unsigned int a5 100 unsigned long a6 = 100UL long long a7 100ll;Linux _int64 a8 = 100i64 ;windows 长度不对，会容易出很多漏洞，\n浮点类型 float//单精度, 4个字节 double//双精度，8个字节 float x=3.1415f 如果不写f系统会认为这是一个双精度浮点数 double y = 1.732\n自定义新的类型 typedef int INTl typedef unsigned int UINT typedef unsigned short USHORT typedef char CHAR typedef unsigned long ULONG typedef usigned short WORD typedef unsigned int DWORD typedef unsigned char BYTE typedef unsigned int size_t\n数据结构体，列表节点，二次参数 可以用来应对c语言代码中的标准或者平台发生了变化，重新定义可以减少代码的修改量 代码更简单 统一编码风格\npython 学习了字典及其基础语法知识\n","date":"2025-10-20T00:00:00Z","image":"http://localhost:1313/p/10-20/bj_hu_11ea6599ea83224e.jpg","permalink":"http://localhost:1313/p/10-20/","title":"10-20 笔记"},{"content":"python基础课 序列中有关于字符串，列表，元组的知识总结 补充了一些常用函数\nc语言基础 ##内建型别## c语言是一个强类型的语言，数据必须明确指定类型，C++还加强了类型安全的检查 程序与数据：程序的任务：处理数据（信息），图片，视频，文本，日志，数据库等。 一个人的年龄，身高，体重，名字，健康状况，性别等数据，对应了不同的类型\nc语言标准，所有的都支持，占字节意为在磁盘中进行存储的时候必须要占这么多空间才能进行存储 字符类型：char/wchar_t 2个字节或者4个字节 char对应 wchar_t对应 整型：short 短暂，2个字节/int 标准，4个字节/long 长整型，winx86 8个字节/longlong 再linux用的多/_int64 win多，8字节 实数单精度：float 4字节 实数双精度：double 8字节 有符号和无符号：signed 有/unsigned 无,(signed)int 默认有/ unsigned int 布尔类型：bool,0/1(true/false) C99 \u0026lt;stdbool.h\u0026gt; 头文件 c语言内部支持的型别\n数据类型的实例 char gender = \u0026lsquo;M\u0026rsquo;;ASCII字符 wchar_t sex = L\u0026rsquo;F\u0026rsquo;;UNICODE字符 此字符一个字符占两个字节，ios和linux占4个字节 char name[16] = \u0026rsquo;tom\u0026rsquo;; 字符组有16个元素 wchar_t nick[16] = L\u0026rsquo;Jcak\u0026rsquo;;\nint age=30; float weight=79.1f; double height= 1.80 bool bhealthy= ture;\n内建型别，数据以字节为单位存储在内存中，不同类型的数据，存储占用的内存空间长度不同\n#字符型：char./wchar_t sizeof(char) = 1 即char类型占1个字节空间 采用ASCII编码，一个字符对应一个字节 sizeof(wchar_t) = 2或者4,字符数与字节数的区别 Unicode编码，一个字符对应多个字节 char c=\u0026lsquo;a\u0026rsquo;// \u0026lsquo;a\u0026rsquo;是字符常量，c是字符变量。常量用单引号包围 \u0026lsquo;\u0026rsquo;\u0026rsquo;-\u0026gt;\u0026rsquo;'\u0026rsquo; 表示字符常量的时候用单引号引起来，单引号也是一个字符，需要用转义字符来表示该引号不是字符 wchar_t wc=L\u0026rsquo;a\u0026rsquo;; unsigned char/signed char,只写char，由编译器决定是有符号无符号 字符编码：字符在计算机中是通过字符编码（字符的id）的形式存储的，\u0026lsquo;a\u0026rsquo;-\u0026gt;97,\u0026lsquo;A\u0026rsquo;-\u0026gt;65 ASCII码，美国标准信息交换代码 ASCII码是单字节编码系统，它使用指定的7位或者8位二进制数组合来表示128或256种可能的字符\n","date":"2025-10-19T00:00:00Z","image":"http://localhost:1313/p/10-19/bj_hu_24ba452ff7b4968e.jpg","permalink":"http://localhost:1313/p/10-19/","title":"10-19 笔记"},{"content":"10.18 美化博客 新增了背景图片，修改了字体，增加遮光罩，部分路径代码优化很差，网页加载变卡\npython熟练 洛谷B2007-B2014的入门编程题，新增语法表达，逻辑优化 如： ￥round(number, ndigits) 四舍五入函数 要舍入的数字和保留的小数位数（ 默认为0）不会强制保留小数 ￥f-string 字符串格式化 f\u0026quot;{变量：格式}\u0026quot; f\u0026rsquo; {} {} \u0026rsquo; 引号内相当于字符串，大括号内可以加变量 {} 内可以简洁表达 {:10 :\u0026lt;10 ^10}右对齐，左对齐，居中对齐 {:,.2f :.1%}千分位加保留2位 保留一位和百分比\n后续继续学习序列和巩固之前所学语法\nc语言学习 程序基础 程序的编译和链接\nvc\n预处理 a.c 编译 a.i 汇编 a.s 链接 a.o(a.obj) \u0026gt; a.exe c \u0026gt; i \u0026gt; s \u0026gt; o \u0026gt; exe\n多个c会编辑成多个obj，然后与lib一起链接成exe。pe格式 (可执行文件)\npe格式存放了程序执行的代码啊，数据，资源 是一种规范和标准\nwin:. exe/.dll/.sys =\u0026gt; pe Linux: elf\n病毒分析逆向\ndos ‘MZ’ e_magic MZ 开头 0X5a4d\ndos stub 主要起兼容作用\ne_lfanew 指向 pe文件头 PE\\0\\0: 0x50 0x45 00 00\n块表 记录每一个块的位置\n块 存放着可执行代码\n调试信息\nsection 节，块，段 eop 入口点，第一条指令所在地址 oep 原入口点，壳里面的概念 epo 入口模糊 病毒概念 病毒感染了程序，模糊了入口点 imageBase:0x4000000 exe从磁盘加载到内存中，有一个基地值，不修改的话是固定的（）编译可修改 VA 加载到内存中，pe文件的每一条指令，数据，变量的虚拟地址 RVA 相对虚拟地址，相对于imagebase VOFFSET 每一节的起始的虚拟地址减去imagebase得到的值 内存中起始地址截取imagebase ROFFSET 每一节的起始地址减去文件的首地址得到的偏移 磁盘中起始地址减去文件的首地址\npeid/petool pe petool 查壳查地址 notepad++/winhex\nextrypoint eop\nep section 所在的节 text 存放代码\n程序，是指令和数据的有序集合，本身没有任何运行的含义，静态概念\n存放在磁盘上的exe程序叫做映像文件 imagefile\n进程是程序在处理机上的一次执行过程，他是一个动态的概念，拥有一个完整的生命周期\n进程的是指是程序在系统中的一次执行过程，进程是动态产生，动态消亡的\n一个程序在不同的数据集里就构成不同的进程\n不同的程序可以启动不同数量的进程\n程序在运行的时候就有一个pid标识\n进程的三个状态：\n1，就绪状态\n已经获得除了处理器的所需资源，等待分配处理器\n2，运行状态\n占用cpu资源，\n3，阻塞状态\n等待某种条件，在条件满足前无法继续执行\n线程：为了提高系统并发的度。\n一个程序至少有一个进程\n一个进程至少有一个线程，进程是资源分配的基本单元，线程的调度的基本单元\n冯诺依曼体系 cpu(算术逻辑单元和浮点数逻辑单元) 寄存器 内存(RAM) 磁盘\ncpu 》计算 》计算器 》 储存\n系统总线，控制总线，地址总线，数据总线 连接cpu和内存，通过线路传输连接计算\ncpu：多核时代，一个cpu上有多个核，每一个核就是一个processor，操作系统的视角中一个核就是一个逻辑处理器\n系统内存布局\n分为俩个部分\nuser space 应用程序运行空间 2GB内核空间 0xffffffff\nkernel space 内核空间，操作系统的运行空间 0x7fffffff 64kb非法区域\n最下层是硬件 0x7fff0000 进程空间（私有的，每一个进程 之间的内存）\n64kb null空间 应用层程序R3\n内核层R0（最高权限）\nx86支持32位寻址，pae技术可以扩大内存空间\n2^32=4GB 32位系统，四个字节\nx64内存理论上支持2^64的寻址空间，目前一般只支持到40多位\n整数 ##整数##\n#进制转换\n十进制，二进制，十六进制，八进制\n1.c：\n十六进制：0x71ef（0x开头 A(10)B(11)C(12)D(13)E(14)F(15)）\n八进制：0127（0-7）\n二进制：101101(c里面没有单独的二进制表示方法)\n十进制：100\n2.进制只是整数值的表现形式，\n值123：123/0x7b/0173/01111011\n3.汇编语言：\n十六进制：1aH\n八进制：17O\n十进制：12D\n二级制：110B\n4.进制转换计算\nx进制转换10进制：\nA(n)A(n-1)\u0026hellip;..=A(n)*x^(n-1)\u0026hellip;\n十进制（A）转换x进制：\nA除以x取余数，再取商除以x取余数，直到商为0，再把所有余数逆序.\n有小数的数，十进制转二进制，小数点前后分开转换\n22.8125 00010110.1101\n对2进制分组，将每一个二进制专门转化为十六进制，每四位分一组，便于计算二进制转十六进制 整 数：1，2，4，8字节 浮点数：4个或者8个字节 5.特性 十六进制的特性 根据十六进制转化为二进制的方法，可以得出：在十六进制中，1个数字占四位，2个数字为一个字节 可以直接观察这个数在内存中每个字节的内容 8位二进制为一个字节，十六进制中每两个数字是一个字节 #整数编码 1.计算机存储数据的bit（位）与byte（字节） bit：位，小b，最小单位 byte：字节，大B，1Byte=8bit 网路带宽使用bit计算的 1个bit只能存储两个信息：0，1 1个Byte能存储2^8个信息：【-128，127】，【0，255】8位二进制，两位十六进制 2个Byte，4个Byte，8个Byte 数据存储位置，寄存器，内存，磁盘 一般按byte来计算存储单位 2.整数的正负表示\n有符号数：最高位做符号位这种表示的整数叫做有符号数（有正负之分）\n最高位做符号位，1表示负数，0表示正数\n如果用1个字节来表示整数，那么：\n10110110:负数\n01001011:正数\n无符号数：无负数，表示0和正整数，最高位无需表示正负，参与数值运算。\n一个字节的整数\n有符号：【-128，127】\n无符号：【0，255】\n3.整数的编码\n（最终采取了补码）整数是按照二进制储存的，二进制需要进行特定的编码规则存储：原码，反码，补码\n原码：在数值前面增加了一位符号位（即最高位位符号位），该位为0表示整数，该位为1表示负数，其余位标识数值的大小。\n以一个byte作为整数存储长度为例子：\n1： 00000001\n-1： 10000001\n那么1-1=1+（-1）=00000001+10000001=10000010=-2错误，符号位无法参加运算\n反码：正整数的反码就是其自身，而负整数的反码可以通过对其绝对值逐位求反来求得。\n以一个byte作为整数存储长度为例子：\n1： 00000001\n-1： 11111110\n那么1-1=1+（-1）=00000001+11111110=11111111=0错误，反码的问题在于+0和-0的情况，人常识的计算概念中0是没有正负之分的 补码：整数的补码为它本身，负数的补码就是它的绝对值求反加1，0的补码就是0 计算机采用补码储存整数\n以一个byte作为整数存储长度为例子：\n1： 00000001\n-1： 11111111\n100： 01100100\n-100： 10011100 （取反加1等于其绝对值）\n47： 00101111\n-47： 11010001\n-128： 10000000\n127： 01111111\n两个字节的100：00000000 01100100\n两个字节的-100：11111111 10011100\n两个字节的-1 ：11111111 11111111\n一个字节的补码扩充到两个字节，四个字节：\n正数：零扩充\n负数：一扩充\n用最高位的符号位去扩充\n4.整数的存储方式\n0x 12 34 56 78 左边是高位 右边是地位，设计的逻辑顺序\n内存存放，从左往右，由低到高\n低位优先-》低位存放在低地址 ：little-endian\n高位优先-》高位存放在低地址 ：big-endian\nx86系统，低位优先系统 同一种东西的不同存储方式\n0x 00 00 00 01\n低位优先： 01 00 00 00\n高位优先： 00 00 00 01\nhtons() 主机字节序到网络字节序转换\nhtohs() 网络字节序到主机字节序转换\n网络字节序是高位优先的\n","date":"2025-10-18T00:00:00Z","image":"http://localhost:1313/p/10-18/tutu_hu_64d12a5cb395fe5.jpg","permalink":"http://localhost:1313/p/10-18/","title":"10-18 笔记"},{"content":"第一周学习总结（未完） 首先是在ctfplus做的题\n做了一部分misc和一部分re的题\n先说re\n有两道sign题\nsign1 在ida中反编译在代码中直接能看到flag\nsign2 根据运行提示和代码分析，flag应该是通过ROT47方式加密的\nROT47：凯撒加密变种，通过映射ASCII 字符集进行移位加密。可以将数字，字母，符号全部混合互换\n加密解密算法完全相同\n此题已知flag开头为\u0026quot;0xGame\u0026quot;,将问题喂给ai，通过python代码暴力破解可以得到答案\n不过此题中还进行了一个变换\n其中decrypt是一个解密函数，并不是常规rot47解密，此题是一个rot47的变种\n一道BaseUPX的题\n用软件检查exe发现是UPX壳，然后脱壳之后再查看反编译代码\n根据代码中base64_encode的提示，找到base64的编码，再利用ai解码\n一道睡觉zzz的题\n此题的核心是sha-256，ASCII字符，长度验证，%8x格式说明符\n根据代码提示，format error和wrong的区别，先检查格式问题，再排查其他\n然后是sscanf(s1, \u0026ldquo;0xGame{%8x%8x%8x%8x}\u0026rdquo;, \u0026amp;x1, \u0026amp;x2, \u0026amp;x3, \u0026amp;x4)这一段说明是4个8位十六进制数\nSHA=256哈希无法反推出原始数据\n最后就是编写代码使得4个十六进制数满足代码中所给出的方程，导入ai可得\n但本题还有一个问题，已在程序中获得正确提示的答案提交不对\n一道简单异或题\n找到str函数对应代码，导入ai进行编译可得\n一道dydebug复杂加密问题，四种加密方式，也是利用ai解出，具体图片未保存\n然后是misc方向的题目\n一道base64编码和凯撒加密的题目\n一道图片lsb隐写题，利用stegsolve看RGB编码解出\n最后一道是docx，利用010查询编码发现是504b0304，改格式解压得出\n接着是学习的linux基本命令，询问ai之后在系统中试过抄写命令\n","date":"2025-10-12T00:00:00Z","image":"http://localhost:1313/p/first-week/gui_hu_71ce81c2b99a7331.png","permalink":"http://localhost:1313/p/first-week/","title":"第一周总结"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2025-10-08T00:00:00Z","image":"http://localhost:1313/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"http://localhost:1313/p/emoji-support/","title":"Emoji Support"},{"content":"第一篇文章 介绍 我已出仓，感觉良好。\n刚看啥也不是，点开一看更是啥也不是\n在第一篇文章里面做一些尝试\n引用 我曾经爱过你，爱情，也许；\n在我的心灵里还没有完全消亡；\n但愿它不会再打扰你；\n我也不想再使你难过悲伤；\n我曾经默默无语，毫无指望地爱过你；\n我既忍受着羞怯，又忍受着嫉妒的折磨；\n我曾经那样真诚，那样温柔地爱过你；\n但愿上帝保佑你，它会比我更爱你。\n\u0026mdash;普希金\n莫言在《晚熟的人》里这样写道：\n“烟火人间，各有遗憾。\n想过安稳日子的女人，却嫁给了挣不来qian的男人；\n想过安稳日子的男人，却娶了爱败家的女人；\n做得一手好菜的女人，等不到回家吃饭的男人；\n经常回家吃饭的男人，偏偏娶了不会做饭的女人。\n山山而川，不过尔尔。在喜欢你的人那里去热爱生活，在不喜欢你的人那里去看清世界，就这么简单。”\n活着活着你就会明白，这个世界是守恒的。\n很多婚姻好的人，事业不行；\n事业好的人，婚姻不行；\n事业婚姻都好的人，可能身体不好。\n大部分有成就的人，大多是六亲无靠，六亲无靠大概就是他们用来交换成功的代价，所以对于很多事不必太执着。\n枕边人成不了心上人，心上人也成不了枕边人。枕边人给不了爱，心上人给不了家；\n最终，枕边人守着过了一辈子，心上人待在心里一辈子。\n我们本不善言辞，为了生活，却不得不忙于交际；\n我们本喜欢独处，为了生活，却不得不四处奔波。\n在无人问津的地方，拿尊严换qian；\n在人声鼎沸的地方，拿qian换取尊严。\n有工作的地方没有家，有家的地方没有工作。\n他乡容不下灵魂，故乡安不了肉身。\n上苍不会让所有幸福集中到某个人身上。\n得到了爱情未必拥有金qian，拥有金qian未必得到快乐；\n得到快乐未必拥有健康，拥有健康未必一切都会如愿以偿。\n你得到了这个，还想要那个，但不可能所有的好处你都能得到。你不可能同时拥有春花和秋月，也不可能同时拥有硕果和繁花。\n人生最忌讳的就是过于圆满，不信你看看身边的人。\n有人婚姻不好，但子女很优秀；\n有人婚姻很好，但身体不太好；\n有人事业很顺，但家庭不和睦；\n有人家庭和睦，日子却过得很清贫。\n人生哪能都如意，万事只能半称心。美满的婚姻是由瞎子女人和聋子男人缔成，我们都是和对方的优点谈恋爱，却和他们的缺点生活在一起，天下没有十全十美的男女。婚姻不是争输赢，半睁眼半闭眼过生活，少用放大镜看对方，否则连上帝身上都能挑出毛病。\n时光煮雨，岁月缝花。这烟火人间，事事遗憾，但事事也值得！\n图片 注意 +++ \u0026mdash; +++ 和 \u0026mdash; 是两种语法\n","date":"2021-09-03T00:00:00Z","image":"http://localhost:1313/p/first-word/121_hu_217da5c3ce36f442.jpg","permalink":"http://localhost:1313/p/first-word/","title":"人生总有第一次"}]
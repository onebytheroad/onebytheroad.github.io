---
title: 12-02 笔记
description: 遇见你是我最大的幸福
date: 2025-12-02
slug: 12-02
image: bj.jpg
categories:
  - 每日
---

### adc 指令

adc是带进位加法指令，利用CF上记录的进位值

`adc 操作对象1 操作对象2`

`操作对象1 = 操作对象1 + 操作对象2 + CF`

~~~
adc ax,bx
(ax) = (ax) + (bx) + CF

例子：
mov ax,2
mov bx,1
sub bx,ax
adc ax,1

(ax) = 4  (ax) + 1 + CF = 2 + 1 + 1 = 4

mov ax,1
add aax,ax
adc ax,3

(ax) = 5  (ax) + 3 + CF = 2 + 3 + 0 =5

mov al,98H
add al,al
adc al,3

(al) = 34H (al) + 3 + CF = 30H + 3 + 1 = 34H
~~~

指令意义：

可以对高位进行相加

如果数据的位数大于16，并且相加还有进位的情况，那么单纯的用add就无法进行计算

```
计算 1ef000h + 201000h

mov ax,001eh
mov bx,0f0000h
add bx,1000h
adc ax,0020h

计算 1ef0001000h + 2010001ef0h

mov ax,001eh
mov bx,0f000h
mov cx,1000h
add cx,1ef0h
adc bx,1000h
adc ax,0020h
```



### sbb 指令

 带借位减法指令，利用CF记录的借位值

`sbb 操作对象1 操作对象2`

`操作对象1 = 操作对象1 - 操作对象2 - CF`

`sbb ax,bx    (ax) = (ax) - (bx) - CF`

~~~
计算003e1000h - 00202000h

mov bx,1000h
mov ax,003eh
sub bx,2000h
sbb ax,0020h
~~~



### cmp 指令 

比较指令，功能相当于减法，只是不保存结果

`cmp指令格式：cmp 操作对象1 操作对象2`

`计算  操作对象1 - 操作对象2  `

执行cmp指令后，会影响flag寄存器的变化，通过这些变化可以得出比较的结果

~~~
cmp ax,bx

ax =  bx   结果为0          zf = 1
ax != bx   结果不为0        zf = 0
ax <  bx   产生借位         cf = 1
ax >= bx   不借位           cf = 0 zf可能
ax >  bx   不借位不为0       cf = 0 && zf =0
ax <= bx   可能借位可能为0   cf = 1 或 zf = 1
~~~



负数的记录，`SF = 1 `并不能说明` cmp ax,bx `中 ax 比 bx 小

因为数在运算过程中可能会导致溢出，并不能用寄存器来单纯的说明计算结果

```
mov ah,08ah
mov bh,070h
cmp ah,bh
```

结果`sf = 0` `(ah) - (bh) = 1AH`,在逻辑上运算的结果是`(-118) - 112 = -230` ，sf记录实际结果的正负，所以sf = 0

但不能因此说明在逻辑上的正确结果，而逻辑结果的正负才是cmp指令应该得到的真正结果

逻辑结果和实际结果产生差别的原因是因为计算之间产生的溢出

所以想得到逻辑结果需要同时考察SF和OF

```
cmp ah,bh

1; sf=1,of=0
of=0 说明没有溢出，逻辑正负=实际正负
sf=1 实际为0，逻辑为负，所以(ah) < (bh)

2; sf=1,of=1
of=1 说明有溢出，逻辑正负!=实际正负
sf=1 实际为负
实际结果为负，而又有溢出，说明是由于溢出导致了实际结果为负，逻辑上的真正结果为正 (ah) > (bh)

3; sf=0;of=1
of=1 说明有溢出，逻辑正负!=实际正负
sf=0 实际为正
实际结果为正，又有溢出，说明溢出导致为正，实际结果为负 (ah) < (bh)

4; sf=0,of=0
of=0 无溢出
sf=0 为正
(ah) >= (bh)
```





###  条件转移指令

转移：修改IP

`cmp同时进行两种比较。根据cmp的结果进行的转移的指令也分为两种`

| 指令 | 含义         | 检测相关标志位  |
| ---- | ------------ | --------------- |
| je   | 等于则转移   | zf=1            |
| jne  | 不等于则转移 | zf=0            |
| jb   | 低于则转移   | cf=1            |
| jnb  | 不低于则转移 | cf=0            |
| ja   | 高于则转移   | cf=0 && zf=0    |
| jna  | 不高于则转移 | cf = 1 \| zf =1 |

`e = equal  b = below  a = above  n = not`

 

je的相等且转移的含义来源于与cmp指令的配合使用，实际上检测的是CF是否等于1，如果不与cmp配合使用就有可能不表示相等





### DF标志和串传送指令

方向标志位，串处理指令，控制每次操作后si，di的增减

`df = 0 ` 每次操作后si，di递增

`df = 1 ` 每次操作后si，di递减

~~~
movsb
((es) * 16 + (di)) = ((ds) * 16 + (si))

if df = 0
   (si) = (si) + 1
   (di) = (di) + 1
if df = 1
   (si) = (si) - 1
   (di) = (di) - 1
   
将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df的值，将si或di递减

当然也可以传送一个字
movsw
将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df的值，将si和di递增2或递减2

rep
根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或者递减指向后一个或者前一个单元，则rep movsb就可以循环实现(cx)个字符的传送
也可以使用rep movsw


由于df控制着执行指令后si和di的转移方向
所以需要由指令对其进行控制，来控制si和di的转移方向
cld：将标志器df位置0
std：将标志器df位置1

~~~





### pushf 和 popf

pushf 将标志寄存器的值压栈

popf 从栈中弹出数据送入标志寄存器





### debug 中flag寄存器的表示

| 标志 | 为1  | 为0  |
| ---- | ---- | ---- |
| of   | OV   | NV   |
| sf   | NG   | PL   |
| zf   | ZR   | NZ   |
| pf   | PE   | PO   |
| cf   | CY   | NC   |
| df   | DN   | UP   |





### 内中断

中断信息，来源于内部或者外部的 `使得cpu立即处理的信息` ，本章着重讨论内部产生的中断信息

~~~
1；除法错误 如执行div产生的除法溢出
2；单步执行
3；into指令
4；int指令
~~~

8086通过中断类型码的数据来表示终端信息的来源。

中断类型码为一个字节型数据，表示256种中断信息的来源

~~~
中断类型码

1；除法错误  0 
2；单步执行  1
3；into指令  4
4；int指令   int n,指令中的n为字节型立即数，提供给cpu的中断类型码
~~~



中断处理程序：用来处理中断信息的程序

中断向量表，中断处理程序入口地址的列表，在内存中保存，储存着256个中断源所对应的中断处理程序的入口，cpu知晓中断类型码之后，将中观类型吗作为中断向量表的表象好，定位相应的表项，就能够获得中断处理程序的入口地址

8086中规定，0000:0000 到 0000:03FF 的1024个单元中存放着中断向量表

向量表中，一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，入口地址包括段地址和偏移地址





中断执行过程

~~~
1.从中断信息中取得中断类型码
2.标志寄存器的值入栈
3.设置标志寄存器的第八位TF，第九位IF的值为0
4.CS的内容入栈
5.IP入栈
6.从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS
~~~

由于cpu随时可能检测到中断信息，就是cpu随时可能执行中断程序，所以中断处理程序必须一直存储在内存某段空间之中，而中断处理程序的入口地址，即中断向量，必须储存在对应的中断向量表表项中

~~~
1；保存用到的寄存器
2；处理中断
3；恢复用到的寄存器
4；用iret指令返回

iret
pop ip
pop cs
popf
~~~




---
title: 12-02 标志寄存器
description: 遇见你是我最大的幸福
date: 2025-12-02
slug: 12-02
image: bj.jpg
categories:
  - 汇编语言
---

### 标志寄存器（flag寄存器）

==flag寄存器每一都有专门的含义，用于记录特定的信息==

`flag 寄存器 结构`

| 15   | 14   | 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| :--- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      | OF   | DF   | IF   | TF   | SF   | ZF   |      | AF   |      | PF   |      | CF   |



ZF 标志

零标志位，记录执行指令后的结果是否为0

结果为`0 -> ZF = 1`     结果不为`0 -> ZF = 0`

为1为0的背后逻辑：标记计算结果是否为0，标记为真，即`ZF = 1` 说明成立，标记为假，等于0，说明不成立



PF 标志

奇数偶数标志位，记录执行后结果中的 1 的个数是否为偶数

```
mov al,1
add al,10

ax = 0000 1011
num(1) = 3
PF = 0

if ax = 0000 0011
num(1) = 2
PF = 1
```



SF 标志

符号标志位。记录执行指令后结果是否为负数

结果为负 `SF = 1` ，  结果为正  `SF = 0 `

计算机中的数分为有符号数和无符号数两种，两种数表示的范围不一样，同一段二进制码不同的表达会表示不同的数

~~~
00000001B  无符号数1.有符号数+1
10000001B  无符号数129，有符号数-127
~~~



CF 标志

进位标志位。用来记录借位或进位。

```
mov al,98H
add al,al  两个8为数据相加大于8为可容纳值时，会产生从最高有效位想更高维的进位，之前只是说这会导致数据丢失
           其实在运算的时候会将他记录在一个特殊寄存器的某一位中，8086中是用CF来记录
           执行后 (al) = 30H , CF = 1
add al,al  执行后 (al) = 60H , CF = 0


mov al,97h 减法的借位值也会记录下来
sub al,98h 执行后 (al) = FFH , CF = 1
sub al,al  执行后 (al) = 0 , CF = 0
```



OF 标志

溢出标志位。记录了有符号数运算的结果是否发生了溢出。发生溢出：OF = 1 ,未发生溢出 ： OF = 0

cpu在执行计算指令的时候，就包含了两种含义：无符号数运算和有符号数运算。

而OF和CF的存储实际上是相互独立的，对于同一个计算结果从两个不同的角度来储存，区别只在于调用从哪那个方向理解





### adc 指令

adc是带进位加法指令，利用CF上记录的进位值

`adc 操作对象1 操作对象2`

`操作对象1 = 操作对象1 + 操作对象2 + CF`

~~~
adc ax,bx
(ax) = (ax) + (bx) + CF

例子：
mov ax,2
mov bx,1
sub bx,ax
adc ax,1

(ax) = 4  (ax) + 1 + CF = 2 + 1 + 1 = 4

mov ax,1
add aax,ax
adc ax,3

(ax) = 5  (ax) + 3 + CF = 2 + 3 + 0 =5

mov al,98H
add al,al
adc al,3

(al) = 34H (al) + 3 + CF = 30H + 3 + 1 = 34H
~~~

指令意义：

可以对高位进行相加

如果数据的位数大于16，并且相加还有进位的情况，那么单纯的用add就无法进行计算

```
计算 1ef000h + 201000h

mov ax,001eh
mov bx,0f0000h
add bx,1000h
adc ax,0020h

计算 1ef0001000h + 2010001ef0h

mov ax,001eh
mov bx,0f000h
mov cx,1000h
add cx,1ef0h
adc bx,1000h
adc ax,0020h
```



### sbb 指令

 带借位减法指令，利用CF记录的借位值

`sbb 操作对象1 操作对象2`

`操作对象1 = 操作对象1 - 操作对象2 - CF`

`sbb ax,bx    (ax) = (ax) - (bx) - CF`

~~~
计算003e1000h - 00202000h

mov bx,1000h
mov ax,003eh
sub bx,2000h
sbb ax,0020h
~~~



### cmp 指令 

比较指令，功能相当于减法，只是不保存结果

`cmp指令格式：cmp 操作对象1 操作对象2`

`计算  操作对象1 - 操作对象2  `

执行cmp指令后，会影响flag寄存器的变化，通过这些变化可以得出比较的结果

~~~
cmp ax,bx

ax =  bx   结果为0          zf = 1
ax != bx   结果不为0        zf = 0
ax <  bx   产生借位         cf = 1
ax >= bx   不借位           cf = 0 zf可能
ax >  bx   不借位不为0       cf = 0 && zf =0
ax <= bx   可能借位可能为0   cf = 1 或 zf = 1
~~~



负数的记录，`SF = 1 `并不能说明` cmp ax,bx `中 ax 比 bx 小

因为数在运算过程中可能会导致溢出，并不能用寄存器来单纯的说明计算结果

```
mov ah,08ah
mov bh,070h
cmp ah,bh
```

结果`sf = 0` `(ah) - (bh) = 1AH`,在逻辑上运算的结果是`(-118) - 112 = -230` ，sf记录实际结果的正负，所以sf = 0

但不能因此说明在逻辑上的正确结果，而逻辑结果的正负才是cmp指令应该得到的真正结果

逻辑结果和实际结果产生差别的原因是因为计算之间产生的溢出

所以想得到逻辑结果需要同时考察SF和OF

```
cmp ah,bh

1; sf=1,of=0
of=0 说明没有溢出，逻辑正负=实际正负
sf=1 实际为0，逻辑为负，所以(ah) < (bh)

2; sf=1,of=1
of=1 说明有溢出，逻辑正负!=实际正负
sf=1 实际为负
实际结果为负，而又有溢出，说明是由于溢出导致了实际结果为负，逻辑上的真正结果为正 (ah) > (bh)

3; sf=0;of=1
of=1 说明有溢出，逻辑正负!=实际正负
sf=0 实际为正
实际结果为正，又有溢出，说明溢出导致为正，实际结果为负 (ah) < (bh)

4; sf=0,of=0
of=0 无溢出
sf=0 为正
(ah) >= (bh)
```





###  条件转移指令

转移：修改IP

`cmp同时进行两种比较。根据cmp的结果进行的转移的指令也分为两种`

| 指令 | 含义         | 检测相关标志位  |
| ---- | ------------ | --------------- |
| je   | 等于则转移   | zf=1            |
| jne  | 不等于则转移 | zf=0            |
| jb   | 低于则转移   | cf=1            |
| jnb  | 不低于则转移 | cf=0            |
| ja   | 高于则转移   | cf=0 && zf=0    |
| jna  | 不高于则转移 | cf = 1 \| zf =1 |

`e = equal  b = below  a = above  n = not`

 

je的相等且转移的含义来源于与cmp指令的配合使用，实际上检测的是CF是否等于1，如果不与cmp配合使用就有可能不表示相等





### DF标志和串传送指令

方向标志位，串处理指令，控制每次操作后si，di的增减

`df = 0 ` 每次操作后si，di递增

`df = 1 ` 每次操作后si，di递减

~~~
movsb
((es) * 16 + (di)) = ((ds) * 16 + (si))

if df = 0
   (si) = (si) + 1
   (di) = (di) + 1
if df = 1
   (si) = (si) - 1
   (di) = (di) - 1
   
将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df的值，将si或di递减

当然也可以传送一个字
movsw
将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df的值，将si和di递增2或递减2

rep
根据cx的值，重复执行后面的串传送指令。由于每执行一次movsb指令si和di都会递增或者递减指向后一个或者前一个单元，则rep movsb就可以循环实现(cx)个字符的传送
也可以使用rep movsw


由于df控制着执行指令后si和di的转移方向
所以需要由指令对其进行控制，来控制si和di的转移方向
cld：将标志器df位置0
std：将标志器df位置1

~~~





### pushf 和 popf

pushf 将标志寄存器的值压栈

popf 从栈中弹出数据送入标志寄存器





### debug 中flag寄存器的表示

| 标志 | 为1  | 为0  |
| ---- | ---- | ---- |
| of   | OV   | NV   |
| sf   | NG   | PL   |
| zf   | ZR   | NZ   |
| pf   | PE   | PO   |
| cf   | CY   | NC   |
| df   | DN   | UP   |
